% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/saemix.R
\name{saemix_model}
\alias{saemix_model}
\alias{saemix_data}
\title{Create saemix models from mmkin row objects}
\usage{
saemix_model(object, cores = 1)

saemix_data(object, ...)
}
\arguments{
\item{object}{An mmkin row object containing several fits of the same model
to different datasets}

\item{cores}{The number of cores to be used for multicore processing using
\code{\link[parallel:mclapply]{parallel::mclapply()}}. Using more than 1 core is experimental and may
lead to uncontrolled forking, apparently depending on the BLAS version
used.}

\item{\dots}{Further parameters passed to \link[saemix:saemixData]{saemix::saemixData}}
}
\value{
An \link[saemix:SaemixModel-class]{saemix::SaemixModel} object.

An \link[saemix:SaemixData-class]{saemix::SaemixData} object.
}
\description{
This function sets up a nonlinear mixed effects model for an mmkin row
object for use with the saemix package. An mmkin row object is essentially a
list of mkinfit objects that have been obtained by fitting the same model to
a list of datasets.
}
\details{
Starting values for the fixed effects (population mean parameters, argument psi0 of
\code{\link[saemix:saemixModel]{saemix::saemixModel()}} are the mean values of the parameters found using
mmkin. Starting variances of the random effects (argument omega.init) are the
variances of the deviations of the parameters from these mean values.
}
\examples{
ds <- lapply(experimental_data_for_UBA_2019[6:10],
 function(x) subset(x$data[c("name", "time", "value")]))
names(ds) <- paste("Dataset", 6:10)
sfo_sfo <- mkinmod(parent = mkinsub("SFO", "A1"),
  A1 = mkinsub("SFO"))
\dontrun{
f_mmkin <- mmkin(list("SFO-SFO" = sfo_sfo), ds, quiet = TRUE)
library(saemix)
m_saemix <- saemix_model(f_mmkin, cores = 1)
d_saemix <- saemix_data(f_mmkin)
saemix_options <- list(seed = 123456,
  save = FALSE, save.graphs = FALSE, displayProgress = FALSE,
  nbiter.saemix = c(200, 80))
f_saemix <- saemix(m_saemix, d_saemix, saemix_options)
plot(f_saemix, plot.type = "convergence")
}
# Synthetic data with two-component error
sampling_times = c(0, 1, 3, 7, 14, 28, 60, 90, 120)
dt50_sfo_in <- c(80, 90, 100, 111.111, 125)
k_in <- log(2) / dt50_sfo_in

SFO <- mkinmod(parent = mkinsub("SFO"))

pred_sfo <- function(k) {
  mkinpredict(SFO, c(k_parent = k),
    c(parent = 100), sampling_times)
}

ds_sfo_mean <- lapply(k_in, pred_sfo)
set.seed(123456L)
ds_sfo_syn <- lapply(ds_sfo_mean, function(ds) {
  add_err(ds, sdfunc = function(value) sqrt(1^2 + value^2 * 0.07^2),
     n = 1)[[1]]
 })
\dontrun{
f_mmkin_syn <- mmkin("SFO", ds_sfo_syn, error_model = "tc", quiet = TRUE)
# plot(f_mmkin_syn)
m_saemix_tc <- saemix_model(f_mmkin_syn, cores = 1)
d_saemix_tc <- saemix_data(f_mmkin_syn)
f_saemix_tc <- saemix(m_saemix_tc, d_saemix_tc, saemix_options)
plot(f_saemix_tc, plot.type = "convergence")
}
}
