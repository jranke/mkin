<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Fit nonlinear mixed models using nlmixr — nlmixr.mmkin • mkin</title>


<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<!-- Bootstrap -->

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous" />

<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script>

<!-- bootstrap-toc -->
<link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script>

<!-- Font Awesome icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous" />

<!-- clipboard.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script>

<!-- headroom.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script>

<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script>




<meta property="og:title" content="Fit nonlinear mixed models using nlmixr — nlmixr.mmkin" />
<meta property="og:description" content="This function uses nlmixr::nlmixr() as a backend for fitting nonlinear mixed
effects models created from mmkin row objects using the Stochastic Approximation
Expectation Maximisation algorithm (SAEM) or First Order Conditional
Estimation with Interaction (FOCEI)." />


<meta name="robots" content="noindex">

<!-- mathjax -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->



  </head>

  <body data-spy="scroll" data-target="#toc">
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">mkin</a>
        <span class="version label label-info" data-toggle="tooltip" data-placement="bottom" title="In-development version">1.1.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../reference/index.html">Functions and data</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="../articles/mkin.html">Introduction to mkin</a>
    </li>
    <li>
      <a href="../articles/FOCUS_D.html">Example evaluation of FOCUS Example Dataset D</a>
    </li>
    <li>
      <a href="../articles/FOCUS_L.html">Example evaluation of FOCUS Laboratory Data L1 to L3</a>
    </li>
    <li>
      <a href="../articles/web_only/FOCUS_Z.html">Example evaluation of FOCUS Example Dataset Z</a>
    </li>
    <li>
      <a href="../articles/web_only/compiled_models.html">Performance benefit by using compiled model definitions in mkin</a>
    </li>
    <li>
      <a href="../articles/twa.html">Calculation of time weighted average concentrations with mkin</a>
    </li>
    <li>
      <a href="../articles/web_only/NAFTA_examples.html">Example evaluation of NAFTA SOP Attachment examples</a>
    </li>
    <li>
      <a href="../articles/web_only/benchmarks.html">Some benchmark timings</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/jranke/mkin/">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
      
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header>

<div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Fit nonlinear mixed models using nlmixr</h1>
    <small class="dont-index">Source: <a href='https://github.com/jranke/mkin/blob/master/R/nlmixr.R'><code>R/nlmixr.R</code></a></small>
    <div class="hidden name"><code>nlmixr.mmkin.Rd</code></div>
    </div>

    <div class="ref-description">
    <p>This function uses <code><a href='https://rdrr.io/pkg/nlmixr/man/nlmixr.html'>nlmixr::nlmixr()</a></code> as a backend for fitting nonlinear mixed
effects models created from <a href='mmkin.html'>mmkin</a> row objects using the Stochastic Approximation
Expectation Maximisation algorithm (SAEM) or First Order Conditional
Estimation with Interaction (FOCEI).</p>
    </div>

    <pre class="usage"><span class='co'># S3 method for mmkin</span>
<span class='fu'><a href='https://rdrr.io/pkg/nlmixr/man/nlmixr.html'>nlmixr</a></span><span class='op'>(</span>
  <span class='va'>object</span>,
  data <span class='op'>=</span> <span class='cn'>NULL</span>,
  est <span class='op'>=</span> <span class='cn'>NULL</span>,
  control <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/list.html'>list</a></span><span class='op'>(</span><span class='op'>)</span>,
  table <span class='op'>=</span> <span class='fu'>tableControl</span><span class='op'>(</span><span class='op'>)</span>,
  error_model <span class='op'>=</span> <span class='va'>object</span><span class='op'>[[</span><span class='fl'>1</span><span class='op'>]</span><span class='op'>]</span><span class='op'>$</span><span class='va'>err_mod</span>,
  test_log_parms <span class='op'>=</span> <span class='cn'>TRUE</span>,
  conf.level <span class='op'>=</span> <span class='fl'>0.6</span>,
  degparms_start <span class='op'>=</span> <span class='st'>"auto"</span>,
  eta_start <span class='op'>=</span> <span class='st'>"auto"</span>,
  <span class='va'>...</span>,
  save <span class='op'>=</span> <span class='cn'>NULL</span>,
  envir <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/sys.parent.html'>parent.frame</a></span><span class='op'>(</span><span class='op'>)</span>
<span class='op'>)</span>

<span class='co'># S3 method for nlmixr.mmkin</span>
<span class='fu'><a href='https://rdrr.io/r/base/print.html'>print</a></span><span class='op'>(</span><span class='va'>x</span>, digits <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/Extremes.html'>max</a></span><span class='op'>(</span><span class='fl'>3</span>, <span class='fu'><a href='https://rdrr.io/r/base/options.html'>getOption</a></span><span class='op'>(</span><span class='st'>"digits"</span><span class='op'>)</span> <span class='op'>-</span> <span class='fl'>3</span><span class='op'>)</span>, <span class='va'>...</span><span class='op'>)</span>

<span class='fu'>nlmixr_model</span><span class='op'>(</span>
  <span class='va'>object</span>,
  est <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='st'>"saem"</span>, <span class='st'>"focei"</span><span class='op'>)</span>,
  degparms_start <span class='op'>=</span> <span class='st'>"auto"</span>,
  eta_start <span class='op'>=</span> <span class='st'>"auto"</span>,
  test_log_parms <span class='op'>=</span> <span class='cn'>TRUE</span>,
  conf.level <span class='op'>=</span> <span class='fl'>0.6</span>,
  error_model <span class='op'>=</span> <span class='va'>object</span><span class='op'>[[</span><span class='fl'>1</span><span class='op'>]</span><span class='op'>]</span><span class='op'>$</span><span class='va'>err_mod</span>,
  add_attributes <span class='op'>=</span> <span class='cn'>FALSE</span>
<span class='op'>)</span>

<span class='fu'>nlmixr_data</span><span class='op'>(</span><span class='va'>object</span>, <span class='va'>...</span><span class='op'>)</span></pre>

    <h2 class="hasAnchor" id="arguments"><a class="anchor" href="#arguments"></a>Arguments</h2>
    <table class="ref-arguments">
    <colgroup><col class="name" /><col class="desc" /></colgroup>
    <tr>
      <th>object</th>
      <td><p>An <a href='mmkin.html'>mmkin</a> row object containing several fits of the same
<a href='mkinmod.html'>mkinmod</a> model to different datasets</p></td>
    </tr>
    <tr>
      <th>data</th>
      <td><p>Not used, as the data are extracted from the mmkin row object</p></td>
    </tr>
    <tr>
      <th>est</th>
      <td><p>Estimation method passed to <a href='https://rdrr.io/pkg/nlmixr/man/nlmixr.html'>nlmixr::nlmixr</a></p></td>
    </tr>
    <tr>
      <th>control</th>
      <td><p>Passed to <a href='https://rdrr.io/pkg/nlmixr/man/nlmixr.html'>nlmixr::nlmixr</a></p></td>
    </tr>
    <tr>
      <th>table</th>
      <td><p>Passed to <a href='https://rdrr.io/pkg/nlmixr/man/nlmixr.html'>nlmixr::nlmixr</a></p></td>
    </tr>
    <tr>
      <th>error_model</th>
      <td><p>Optional argument to override the error model which is
being set based on the error model used in the mmkin row object.</p></td>
    </tr>
    <tr>
      <th>test_log_parms</th>
      <td><p>If TRUE, an attempt is made to use more robust starting
values for population parameters fitted as log parameters in mkin (like
rate constants) by only considering rate constants that pass the t-test
when calculating mean degradation parameters using <a href='mean_degparms.html'>mean_degparms</a>.</p></td>
    </tr>
    <tr>
      <th>conf.level</th>
      <td><p>Possibility to adjust the required confidence level
for parameter that are tested if requested by 'test_log_parms'.</p></td>
    </tr>
    <tr>
      <th>degparms_start</th>
      <td><p>Parameter values given as a named numeric vector will
be used to override the starting values obtained from the 'mmkin' object.</p></td>
    </tr>
    <tr>
      <th>eta_start</th>
      <td><p>Standard deviations on the transformed scale given as a
named numeric vector will be used to override the starting values obtained
from the 'mmkin' object.</p></td>
    </tr>
    <tr>
      <th>...</th>
      <td><p>Passed to nlmixr_model</p></td>
    </tr>
    <tr>
      <th>save</th>
      <td><p>Passed to <a href='https://rdrr.io/pkg/nlmixr/man/nlmixr.html'>nlmixr::nlmixr</a></p></td>
    </tr>
    <tr>
      <th>envir</th>
      <td><p>Passed to <a href='https://rdrr.io/pkg/nlmixr/man/nlmixr.html'>nlmixr::nlmixr</a></p></td>
    </tr>
    <tr>
      <th>x</th>
      <td><p>An nlmixr.mmkin object to print</p></td>
    </tr>
    <tr>
      <th>digits</th>
      <td><p>Number of digits to use for printing</p></td>
    </tr>
    <tr>
      <th>add_attributes</th>
      <td><p>Should the starting values used for degradation model
parameters and their distribution and for the error model parameters
be returned as attributes?</p></td>
    </tr>
    </table>

    <h2 class="hasAnchor" id="value"><a class="anchor" href="#value"></a>Value</h2>

    <p>An S3 object of class 'nlmixr.mmkin', containing the fitted
<a href='https://rdrr.io/pkg/nlmixr/man/nlmixr.html'>nlmixr::nlmixr</a> object as a list component named 'nm'. The
object also inherits from 'mixed.mmkin'.</p>
<p>An function defining a model suitable for fitting with <a href='https://rdrr.io/pkg/nlmixr/man/nlmixr.html'>nlmixr::nlmixr</a>.</p>
<p>An dataframe suitable for use with <a href='https://rdrr.io/pkg/nlmixr/man/nlmixr.html'>nlmixr::nlmixr</a></p>
    <h2 class="hasAnchor" id="details"><a class="anchor" href="#details"></a>Details</h2>

    <p>An mmkin row object is essentially a list of mkinfit objects that have been
obtained by fitting the same model to a list of datasets using <a href='mkinfit.html'>mkinfit</a>.</p>
    <h2 class="hasAnchor" id="see-also"><a class="anchor" href="#see-also"></a>See also</h2>

    <div class='dont-index'><p><a href='summary.nlmixr.mmkin.html'>summary.nlmixr.mmkin</a> <a href='plot.mixed.mmkin.html'>plot.mixed.mmkin</a></p></div>

    <h2 class="hasAnchor" id="examples"><a class="anchor" href="#examples"></a>Examples</h2>
    <pre class="examples"><div class='input'><span class='co'># \dontrun{</span>
<span class='va'>ds</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/lapply.html'>lapply</a></span><span class='op'>(</span><span class='va'>experimental_data_for_UBA_2019</span><span class='op'>[</span><span class='fl'>6</span><span class='op'>:</span><span class='fl'>10</span><span class='op'>]</span>,
 <span class='kw'>function</span><span class='op'>(</span><span class='va'>x</span><span class='op'>)</span> <span class='fu'><a href='https://rdrr.io/r/base/subset.html'>subset</a></span><span class='op'>(</span><span class='va'>x</span><span class='op'>$</span><span class='va'>data</span><span class='op'>[</span><span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='st'>"name"</span>, <span class='st'>"time"</span>, <span class='st'>"value"</span><span class='op'>)</span><span class='op'>]</span><span class='op'>)</span><span class='op'>)</span>
<span class='fu'><a href='https://rdrr.io/r/base/names.html'>names</a></span><span class='op'>(</span><span class='va'>ds</span><span class='op'>)</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/r/base/paste.html'>paste</a></span><span class='op'>(</span><span class='st'>"Dataset"</span>, <span class='fl'>6</span><span class='op'>:</span><span class='fl'>10</span><span class='op'>)</span>

<span class='va'>f_mmkin_parent</span> <span class='op'>&lt;-</span> <span class='fu'><a href='mmkin.html'>mmkin</a></span><span class='op'>(</span><span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='st'>"SFO"</span>, <span class='st'>"FOMC"</span>, <span class='st'>"DFOP"</span>, <span class='st'>"HS"</span><span class='op'>)</span>, <span class='va'>ds</span>, quiet <span class='op'>=</span> <span class='cn'>TRUE</span>, cores <span class='op'>=</span> <span class='fl'>1</span><span class='op'>)</span>
<span class='va'>f_mmkin_parent_tc</span> <span class='op'>&lt;-</span> <span class='fu'><a href='mmkin.html'>mmkin</a></span><span class='op'>(</span><span class='fu'><a href='https://rdrr.io/r/base/c.html'>c</a></span><span class='op'>(</span><span class='st'>"SFO"</span>, <span class='st'>"FOMC"</span>, <span class='st'>"DFOP"</span><span class='op'>)</span>, <span class='va'>ds</span>, error_model <span class='op'>=</span> <span class='st'>"tc"</span>,
  cores <span class='op'>=</span> <span class='fl'>1</span>, quiet <span class='op'>=</span> <span class='cn'>TRUE</span><span class='op'>)</span>

<span class='kw'><a href='https://rdrr.io/r/base/library.html'>library</a></span><span class='op'>(</span><span class='va'><a href='https://github.com/nlmixrdevelopment/nlmixr'>nlmixr</a></span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='message'></span>
#&gt; <span class='message'>Attaching package: ‘nlmixr’</span></div><div class='output co'>#&gt; <span class='message'>The following object is masked from ‘package:mkin’:</span>
#&gt; <span class='message'></span>
#&gt; <span class='message'>    saem</span></div><div class='input'><span class='va'>f_nlmixr_sfo_saem</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/pkg/nlmixr/man/nlmixr.html'>nlmixr</a></span><span class='op'>(</span><span class='va'>f_mmkin_parent</span><span class='op'>[</span><span class='st'>"SFO"</span>, <span class='op'>]</span>, est <span class='op'>=</span> <span class='st'>"saem"</span>,
  control <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/pkg/nlmixr/man/saemControl.html'>saemControl</a></span><span class='op'>(</span>print <span class='op'>=</span> <span class='fl'>0</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> parameter labels from comments are typically ignored in non-interactive mode</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> Need to run with the source intact to parse comments</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'>→ generate SAEM model</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>RxODE 1.1.1 using 8 threads (see ?getRxThreads)</span>
#&gt; <span class='message'>  no cache: create with `rxCreateCache()`</span></div><div class='output co'>#&gt; <span class='message'>Calculating covariance matrix</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ creating full model...</span></div><div class='output co'>#&gt; <span class='message'>→ pruning branches (<span style='color: #262626; background-color: #DADADA;'>`if`</span>/<span style='color: #262626; background-color: #DADADA;'>`else`</span>)...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ loading into <span style='color: #0000BB;'>symengine</span> environment...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ compiling EBE model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>Calculating residuals/tables</span></div><div class='output co'>#&gt; <span class='message'>done</span></div><div class='input'><span class='va'>f_nlmixr_sfo_focei</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/pkg/nlmixr/man/nlmixr.html'>nlmixr</a></span><span class='op'>(</span><span class='va'>f_mmkin_parent</span><span class='op'>[</span><span class='st'>"SFO"</span>, <span class='op'>]</span>, est <span class='op'>=</span> <span class='st'>"focei"</span>,
  control <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/pkg/nlmixr/man/foceiControl.html'>foceiControl</a></span><span class='op'>(</span>print <span class='op'>=</span> <span class='fl'>0</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> parameter labels from comments are typically ignored in non-interactive mode</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> Need to run with the source intact to parse comments</span></div><div class='output co'>#&gt; <span class='message'>→ creating full model...</span></div><div class='output co'>#&gt; <span class='message'>→ pruning branches (<span style='color: #262626; background-color: #DADADA;'>`if`</span>/<span style='color: #262626; background-color: #DADADA;'>`else`</span>)...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ loading into <span style='color: #0000BB;'>symengine</span> environment...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ creating full model...</span></div><div class='output co'>#&gt; <span class='message'>→ pruning branches (<span style='color: #262626; background-color: #DADADA;'>`if`</span>/<span style='color: #262626; background-color: #DADADA;'>`else`</span>)...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ loading into <span style='color: #0000BB;'>symengine</span> environment...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ calculate jacobian</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate sensitivities</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate ∂(f)/∂(η)</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate ∂(R²)/∂(η)</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in inner model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in inner model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in EBE model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in EBE model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ compiling inner model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in FD model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ compiling EBE model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ compiling events FD model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; calculating covariance matrix
#&gt; done</div><div class='output co'>#&gt; <span class='message'>Calculating residuals/tables</span></div><div class='output co'>#&gt; <span class='message'>done</span></div><div class='output co'>#&gt; <span class='warning'>Warning: initial ETAs were nudged; (can control by foceiControl(etaNudge=., etaNudge2=))</span></div><div class='output co'>#&gt; <span class='warning'>Warning: last objective function was not at minimum, possible problems in optimization</span></div><div class='output co'>#&gt; <span class='warning'>Warning: gradient problems with initial estimate and covariance; see $scaleInfo</span></div><div class='input'>
<span class='va'>f_nlmixr_fomc_saem</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/pkg/nlmixr/man/nlmixr.html'>nlmixr</a></span><span class='op'>(</span><span class='va'>f_mmkin_parent</span><span class='op'>[</span><span class='st'>"FOMC"</span>, <span class='op'>]</span>, est <span class='op'>=</span> <span class='st'>"saem"</span>,
  control <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/pkg/nlmixr/man/saemControl.html'>saemControl</a></span><span class='op'>(</span>print <span class='op'>=</span> <span class='fl'>0</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> parameter labels from comments are typically ignored in non-interactive mode</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> Need to run with the source intact to parse comments</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'>→ generate SAEM model</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>Calculating covariance matrix</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ creating full model...</span></div><div class='output co'>#&gt; <span class='message'>→ pruning branches (<span style='color: #262626; background-color: #DADADA;'>`if`</span>/<span style='color: #262626; background-color: #DADADA;'>`else`</span>)...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ loading into <span style='color: #0000BB;'>symengine</span> environment...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ compiling EBE model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>Calculating residuals/tables</span></div><div class='output co'>#&gt; <span class='message'>done</span></div><div class='input'><span class='va'>f_nlmixr_fomc_focei</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/pkg/nlmixr/man/nlmixr.html'>nlmixr</a></span><span class='op'>(</span><span class='va'>f_mmkin_parent</span><span class='op'>[</span><span class='st'>"FOMC"</span>, <span class='op'>]</span>, est <span class='op'>=</span> <span class='st'>"focei"</span>,
  control <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/pkg/nlmixr/man/foceiControl.html'>foceiControl</a></span><span class='op'>(</span>print <span class='op'>=</span> <span class='fl'>0</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> parameter labels from comments are typically ignored in non-interactive mode</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> Need to run with the source intact to parse comments</span></div><div class='output co'>#&gt; <span class='message'>→ creating full model...</span></div><div class='output co'>#&gt; <span class='message'>→ pruning branches (<span style='color: #262626; background-color: #DADADA;'>`if`</span>/<span style='color: #262626; background-color: #DADADA;'>`else`</span>)...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ loading into <span style='color: #0000BB;'>symengine</span> environment...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ creating full model...</span></div><div class='output co'>#&gt; <span class='message'>→ pruning branches (<span style='color: #262626; background-color: #DADADA;'>`if`</span>/<span style='color: #262626; background-color: #DADADA;'>`else`</span>)...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ loading into <span style='color: #0000BB;'>symengine</span> environment...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ calculate jacobian</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate sensitivities</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate ∂(f)/∂(η)</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate ∂(R²)/∂(η)</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in inner model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in inner model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in EBE model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in EBE model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ compiling inner model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in FD model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in FD model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ compiling EBE model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ compiling events FD model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; calculating covariance matrix
#&gt; done</div><div class='output co'>#&gt; <span class='message'>Calculating residuals/tables</span></div><div class='output co'>#&gt; <span class='message'>done</span></div><div class='output co'>#&gt; <span class='warning'>Warning: initial ETAs were nudged; (can control by foceiControl(etaNudge=., etaNudge2=))</span></div><div class='output co'>#&gt; <span class='warning'>Warning: ETAs were reset to zero during optimization; (Can control by foceiControl(resetEtaP=.))</span></div><div class='output co'>#&gt; <span class='warning'>Warning: last objective function was not at minimum, possible problems in optimization</span></div><div class='output co'>#&gt; <span class='warning'>Warning: gradient problems with initial estimate and covariance; see $scaleInfo</span></div><div class='input'>
<span class='va'>f_nlmixr_dfop_saem</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/pkg/nlmixr/man/nlmixr.html'>nlmixr</a></span><span class='op'>(</span><span class='va'>f_mmkin_parent</span><span class='op'>[</span><span class='st'>"DFOP"</span>, <span class='op'>]</span>, est <span class='op'>=</span> <span class='st'>"saem"</span>,
  control <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/pkg/nlmixr/man/saemControl.html'>saemControl</a></span><span class='op'>(</span>print <span class='op'>=</span> <span class='fl'>0</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> parameter labels from comments are typically ignored in non-interactive mode</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> Need to run with the source intact to parse comments</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'>→ generate SAEM model</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>Calculating covariance matrix</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ creating full model...</span></div><div class='output co'>#&gt; <span class='message'>→ pruning branches (<span style='color: #262626; background-color: #DADADA;'>`if`</span>/<span style='color: #262626; background-color: #DADADA;'>`else`</span>)...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ loading into <span style='color: #0000BB;'>symengine</span> environment...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ compiling EBE model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>Calculating residuals/tables</span></div><div class='output co'>#&gt; <span class='message'>done</span></div><div class='input'><span class='va'>f_nlmixr_dfop_focei</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/pkg/nlmixr/man/nlmixr.html'>nlmixr</a></span><span class='op'>(</span><span class='va'>f_mmkin_parent</span><span class='op'>[</span><span class='st'>"DFOP"</span>, <span class='op'>]</span>, est <span class='op'>=</span> <span class='st'>"focei"</span>,
  control <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/pkg/nlmixr/man/foceiControl.html'>foceiControl</a></span><span class='op'>(</span>print <span class='op'>=</span> <span class='fl'>0</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> parameter labels from comments are typically ignored in non-interactive mode</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> Need to run with the source intact to parse comments</span></div><div class='output co'>#&gt; <span class='message'>→ creating full model...</span></div><div class='output co'>#&gt; <span class='message'>→ pruning branches (<span style='color: #262626; background-color: #DADADA;'>`if`</span>/<span style='color: #262626; background-color: #DADADA;'>`else`</span>)...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ loading into <span style='color: #0000BB;'>symengine</span> environment...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ creating full model...</span></div><div class='output co'>#&gt; <span class='message'>→ pruning branches (<span style='color: #262626; background-color: #DADADA;'>`if`</span>/<span style='color: #262626; background-color: #DADADA;'>`else`</span>)...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ loading into <span style='color: #0000BB;'>symengine</span> environment...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ calculate jacobian</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate sensitivities</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate ∂(f)/∂(η)</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate ∂(R²)/∂(η)</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in inner model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in inner model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in EBE model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in EBE model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ compiling inner model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in FD model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in FD model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ compiling EBE model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ compiling events FD model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; calculating covariance matrix
#&gt; done</div><div class='output co'>#&gt; <span class='message'>Calculating residuals/tables</span></div><div class='output co'>#&gt; <span class='message'>done</span></div><div class='output co'>#&gt; <span class='warning'>Warning: initial ETAs were nudged; (can control by foceiControl(etaNudge=., etaNudge2=))</span></div><div class='output co'>#&gt; <span class='warning'>Warning: last objective function was not at minimum, possible problems in optimization</span></div><div class='output co'>#&gt; <span class='warning'>Warning: gradient problems with initial estimate and covariance; see $scaleInfo</span></div><div class='input'>
<span class='va'>f_nlmixr_hs_saem</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/pkg/nlmixr/man/nlmixr.html'>nlmixr</a></span><span class='op'>(</span><span class='va'>f_mmkin_parent</span><span class='op'>[</span><span class='st'>"HS"</span>, <span class='op'>]</span>, est <span class='op'>=</span> <span class='st'>"saem"</span>,
  control <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/pkg/nlmixr/man/saemControl.html'>saemControl</a></span><span class='op'>(</span>print <span class='op'>=</span> <span class='fl'>0</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> parameter labels from comments are typically ignored in non-interactive mode</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> Need to run with the source intact to parse comments</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'>→ generate SAEM model</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>Calculating covariance matrix</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ creating full model...</span></div><div class='output co'>#&gt; <span class='message'>→ pruning branches (<span style='color: #262626; background-color: #DADADA;'>`if`</span>/<span style='color: #262626; background-color: #DADADA;'>`else`</span>)...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ loading into <span style='color: #0000BB;'>symengine</span> environment...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ compiling EBE model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>Calculating residuals/tables</span></div><div class='output co'>#&gt; <span class='message'>done</span></div><div class='input'><span class='va'>f_nlmixr_hs_focei</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/pkg/nlmixr/man/nlmixr.html'>nlmixr</a></span><span class='op'>(</span><span class='va'>f_mmkin_parent</span><span class='op'>[</span><span class='st'>"HS"</span>, <span class='op'>]</span>, est <span class='op'>=</span> <span class='st'>"focei"</span>,
  control <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/pkg/nlmixr/man/foceiControl.html'>foceiControl</a></span><span class='op'>(</span>print <span class='op'>=</span> <span class='fl'>0</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> parameter labels from comments are typically ignored in non-interactive mode</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> Need to run with the source intact to parse comments</span></div><div class='output co'>#&gt; <span class='message'>→ creating full model...</span></div><div class='output co'>#&gt; <span class='message'>→ pruning branches (<span style='color: #262626; background-color: #DADADA;'>`if`</span>/<span style='color: #262626; background-color: #DADADA;'>`else`</span>)...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ loading into <span style='color: #0000BB;'>symengine</span> environment...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ creating full model...</span></div><div class='output co'>#&gt; <span class='message'>→ pruning branches (<span style='color: #262626; background-color: #DADADA;'>`if`</span>/<span style='color: #262626; background-color: #DADADA;'>`else`</span>)...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ loading into <span style='color: #0000BB;'>symengine</span> environment...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ calculate jacobian</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate sensitivities</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate ∂(f)/∂(η)</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate ∂(R²)/∂(η)</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in inner model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in inner model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in EBE model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in EBE model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ compiling inner model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in FD model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in FD model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ compiling EBE model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ compiling events FD model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; calculating covariance matrix
#&gt; done</div><div class='output co'>#&gt; <span class='message'>Calculating residuals/tables</span></div><div class='output co'>#&gt; <span class='message'>done</span></div><div class='output co'>#&gt; <span class='warning'>Warning: initial ETAs were nudged; (can control by foceiControl(etaNudge=., etaNudge2=))</span></div><div class='output co'>#&gt; <span class='warning'>Warning: last objective function was not at minimum, possible problems in optimization</span></div><div class='output co'>#&gt; <span class='warning'>Warning: gradient problems with initial estimate and covariance; see $scaleInfo</span></div><div class='input'>
<span class='va'>f_nlmixr_fomc_saem_tc</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/pkg/nlmixr/man/nlmixr.html'>nlmixr</a></span><span class='op'>(</span><span class='va'>f_mmkin_parent_tc</span><span class='op'>[</span><span class='st'>"FOMC"</span>, <span class='op'>]</span>, est <span class='op'>=</span> <span class='st'>"saem"</span>,
  control <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/pkg/nlmixr/man/saemControl.html'>saemControl</a></span><span class='op'>(</span>print <span class='op'>=</span> <span class='fl'>0</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> parameter labels from comments are typically ignored in non-interactive mode</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> Need to run with the source intact to parse comments</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'>Calculating covariance matrix</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ creating full model...</span></div><div class='output co'>#&gt; <span class='message'>→ pruning branches (<span style='color: #262626; background-color: #DADADA;'>`if`</span>/<span style='color: #262626; background-color: #DADADA;'>`else`</span>)...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ loading into <span style='color: #0000BB;'>symengine</span> environment...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ compiling EBE model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>Calculating residuals/tables</span></div><div class='output co'>#&gt; <span class='message'>done</span></div><div class='input'><span class='va'>f_nlmixr_fomc_focei_tc</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/pkg/nlmixr/man/nlmixr.html'>nlmixr</a></span><span class='op'>(</span><span class='va'>f_mmkin_parent_tc</span><span class='op'>[</span><span class='st'>"FOMC"</span>, <span class='op'>]</span>, est <span class='op'>=</span> <span class='st'>"focei"</span>,
  control <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/pkg/nlmixr/man/foceiControl.html'>foceiControl</a></span><span class='op'>(</span>print <span class='op'>=</span> <span class='fl'>0</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> parameter labels from comments are typically ignored in non-interactive mode</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> Need to run with the source intact to parse comments</span></div><div class='output co'>#&gt; <span class='message'>→ creating full model...</span></div><div class='output co'>#&gt; <span class='message'>→ pruning branches (<span style='color: #262626; background-color: #DADADA;'>`if`</span>/<span style='color: #262626; background-color: #DADADA;'>`else`</span>)...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ loading into <span style='color: #0000BB;'>symengine</span> environment...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ creating full model...</span></div><div class='output co'>#&gt; <span class='message'>→ pruning branches (<span style='color: #262626; background-color: #DADADA;'>`if`</span>/<span style='color: #262626; background-color: #DADADA;'>`else`</span>)...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ loading into <span style='color: #0000BB;'>symengine</span> environment...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ calculate jacobian</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate sensitivities</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate ∂(f)/∂(η)</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate ∂(R²)/∂(η)</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in inner model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in inner model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in EBE model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in EBE model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ compiling inner model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in FD model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in FD model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ compiling EBE model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ compiling events FD model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; done</div><div class='output co'>#&gt; <span class='message'>Calculating residuals/tables</span></div><div class='output co'>#&gt; <span class='message'>done</span></div><div class='output co'>#&gt; <span class='warning'>Warning: initial ETAs were nudged; (can control by foceiControl(etaNudge=., etaNudge2=))</span></div><div class='output co'>#&gt; <span class='warning'>Warning: ETAs were reset to zero during optimization; (Can control by foceiControl(resetEtaP=.))</span></div><div class='output co'>#&gt; <span class='warning'>Warning: last objective function was not at minimum, possible problems in optimization</span></div><div class='output co'>#&gt; <span class='warning'>Warning: parameter estimate near boundary; covariance not calculated:</span>
#&gt; <span class='warning'>   "rsd_high" </span>
#&gt; <span class='warning'> use 'getVarCov' to calculate anyway</span></div><div class='output co'>#&gt; <span class='warning'>Warning: gradient problems with initial estimate; see $scaleInfo</span></div><div class='input'>
<span class='fu'><a href='https://rdrr.io/r/stats/AIC.html'>AIC</a></span><span class='op'>(</span>
  <span class='va'>f_nlmixr_sfo_saem</span><span class='op'>$</span><span class='va'>nm</span>, <span class='va'>f_nlmixr_sfo_focei</span><span class='op'>$</span><span class='va'>nm</span>,
  <span class='va'>f_nlmixr_fomc_saem</span><span class='op'>$</span><span class='va'>nm</span>, <span class='va'>f_nlmixr_fomc_focei</span><span class='op'>$</span><span class='va'>nm</span>,
  <span class='va'>f_nlmixr_dfop_saem</span><span class='op'>$</span><span class='va'>nm</span>, <span class='va'>f_nlmixr_dfop_focei</span><span class='op'>$</span><span class='va'>nm</span>,
  <span class='va'>f_nlmixr_hs_saem</span><span class='op'>$</span><span class='va'>nm</span>, <span class='va'>f_nlmixr_hs_focei</span><span class='op'>$</span><span class='va'>nm</span>,
  <span class='va'>f_nlmixr_fomc_saem_tc</span><span class='op'>$</span><span class='va'>nm</span>, <span class='va'>f_nlmixr_fomc_focei_tc</span><span class='op'>$</span><span class='va'>nm</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='message'>Calculating -2LL by Gaussian quadrature (nnodes=3,nsd=1.6)</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>Calculating -2LL by Gaussian quadrature (nnodes=3,nsd=1.6)</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>Calculating -2LL by Gaussian quadrature (nnodes=3,nsd=1.6)</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>Calculating -2LL by Gaussian quadrature (nnodes=3,nsd=1.6)</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>Calculating -2LL by Gaussian quadrature (nnodes=3,nsd=1.6)</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt;                           df      AIC
#&gt; f_nlmixr_sfo_saem$nm       5 627.9197
#&gt; f_nlmixr_sfo_focei$nm      5 625.0512
#&gt; f_nlmixr_fomc_saem$nm      7 463.7245
#&gt; f_nlmixr_fomc_focei$nm     7 468.0822
#&gt; f_nlmixr_dfop_saem$nm      9 518.5794
#&gt; f_nlmixr_dfop_focei$nm     9 537.6309
#&gt; f_nlmixr_hs_saem$nm        9 535.9011
#&gt; f_nlmixr_hs_focei$nm       9 544.7590
#&gt; f_nlmixr_fomc_saem_tc$nm   8 463.5871
#&gt; f_nlmixr_fomc_focei_tc$nm  8 470.0733</div><div class='input'>
<span class='fu'><a href='https://rdrr.io/r/stats/AIC.html'>AIC</a></span><span class='op'>(</span><span class='fu'><a href='https://rdrr.io/pkg/nlme/man/nlme.html'>nlme</a></span><span class='op'>(</span><span class='va'>f_mmkin_parent</span><span class='op'>[</span><span class='st'>"FOMC"</span>, <span class='op'>]</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; [1] 468.0781</div><div class='input'><span class='fu'><a href='https://rdrr.io/r/stats/AIC.html'>AIC</a></span><span class='op'>(</span><span class='fu'><a href='https://rdrr.io/pkg/nlme/man/nlme.html'>nlme</a></span><span class='op'>(</span><span class='va'>f_mmkin_parent</span><span class='op'>[</span><span class='st'>"HS"</span>, <span class='op'>]</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; [1] 535.609</div><div class='input'>
<span class='co'># The FOCEI fit of FOMC with constant variance or the tc error model is best</span>
<span class='fu'><a href='https://rdrr.io/r/graphics/plot.default.html'>plot</a></span><span class='op'>(</span><span class='va'>f_nlmixr_fomc_saem_tc</span><span class='op'>)</span>
</div><div class='img'><img src='nlmixr.mmkin-1.png' alt='' width='700' height='433' /></div><div class='input'>
<span class='va'>sfo_sfo</span> <span class='op'>&lt;-</span> <span class='fu'><a href='mkinmod.html'>mkinmod</a></span><span class='op'>(</span>parent <span class='op'>=</span> <span class='fu'><a href='mkinmod.html'>mkinsub</a></span><span class='op'>(</span><span class='st'>"SFO"</span>, <span class='st'>"A1"</span><span class='op'>)</span>,
  A1 <span class='op'>=</span> <span class='fu'><a href='mkinmod.html'>mkinsub</a></span><span class='op'>(</span><span class='st'>"SFO"</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='message'>Temporary DLL for differentials generated and loaded</span></div><div class='input'><span class='va'>fomc_sfo</span> <span class='op'>&lt;-</span> <span class='fu'><a href='mkinmod.html'>mkinmod</a></span><span class='op'>(</span>parent <span class='op'>=</span> <span class='fu'><a href='mkinmod.html'>mkinsub</a></span><span class='op'>(</span><span class='st'>"FOMC"</span>, <span class='st'>"A1"</span><span class='op'>)</span>,
  A1 <span class='op'>=</span> <span class='fu'><a href='mkinmod.html'>mkinsub</a></span><span class='op'>(</span><span class='st'>"SFO"</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='message'>Temporary DLL for differentials generated and loaded</span></div><div class='input'><span class='va'>dfop_sfo</span> <span class='op'>&lt;-</span> <span class='fu'><a href='mkinmod.html'>mkinmod</a></span><span class='op'>(</span>parent <span class='op'>=</span> <span class='fu'><a href='mkinmod.html'>mkinsub</a></span><span class='op'>(</span><span class='st'>"DFOP"</span>, <span class='st'>"A1"</span><span class='op'>)</span>,
  A1 <span class='op'>=</span> <span class='fu'><a href='mkinmod.html'>mkinsub</a></span><span class='op'>(</span><span class='st'>"SFO"</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='message'>Temporary DLL for differentials generated and loaded</span></div><div class='input'>
<span class='va'>f_mmkin_const</span> <span class='op'>&lt;-</span> <span class='fu'><a href='mmkin.html'>mmkin</a></span><span class='op'>(</span><span class='fu'><a href='https://rdrr.io/r/base/list.html'>list</a></span><span class='op'>(</span>
    <span class='st'>"SFO-SFO"</span> <span class='op'>=</span> <span class='va'>sfo_sfo</span>, <span class='st'>"FOMC-SFO"</span> <span class='op'>=</span> <span class='va'>fomc_sfo</span>, <span class='st'>"DFOP-SFO"</span> <span class='op'>=</span> <span class='va'>dfop_sfo</span><span class='op'>)</span>,
  <span class='va'>ds</span>, quiet <span class='op'>=</span> <span class='cn'>TRUE</span>, error_model <span class='op'>=</span> <span class='st'>"const"</span><span class='op'>)</span>
<span class='va'>f_mmkin_obs</span> <span class='op'>&lt;-</span> <span class='fu'><a href='mmkin.html'>mmkin</a></span><span class='op'>(</span><span class='fu'><a href='https://rdrr.io/r/base/list.html'>list</a></span><span class='op'>(</span>
    <span class='st'>"SFO-SFO"</span> <span class='op'>=</span> <span class='va'>sfo_sfo</span>, <span class='st'>"FOMC-SFO"</span> <span class='op'>=</span> <span class='va'>fomc_sfo</span>, <span class='st'>"DFOP-SFO"</span> <span class='op'>=</span> <span class='va'>dfop_sfo</span><span class='op'>)</span>,
  <span class='va'>ds</span>, quiet <span class='op'>=</span> <span class='cn'>TRUE</span>, error_model <span class='op'>=</span> <span class='st'>"obs"</span><span class='op'>)</span>
<span class='va'>f_mmkin_tc</span> <span class='op'>&lt;-</span> <span class='fu'><a href='mmkin.html'>mmkin</a></span><span class='op'>(</span><span class='fu'><a href='https://rdrr.io/r/base/list.html'>list</a></span><span class='op'>(</span>
    <span class='st'>"SFO-SFO"</span> <span class='op'>=</span> <span class='va'>sfo_sfo</span>, <span class='st'>"FOMC-SFO"</span> <span class='op'>=</span> <span class='va'>fomc_sfo</span>, <span class='st'>"DFOP-SFO"</span> <span class='op'>=</span> <span class='va'>dfop_sfo</span><span class='op'>)</span>,
  <span class='va'>ds</span>, quiet <span class='op'>=</span> <span class='cn'>TRUE</span>, error_model <span class='op'>=</span> <span class='st'>"tc"</span><span class='op'>)</span>

<span class='co'># A single constant variance is currently only possible with est = 'focei' in nlmixr</span>
<span class='va'>f_nlmixr_sfo_sfo_focei_const</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/pkg/nlmixr/man/nlmixr.html'>nlmixr</a></span><span class='op'>(</span><span class='va'>f_mmkin_const</span><span class='op'>[</span><span class='st'>"SFO-SFO"</span>, <span class='op'>]</span>, est <span class='op'>=</span> <span class='st'>"focei"</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> parameter labels from comments are typically ignored in non-interactive mode</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> Need to run with the source intact to parse comments</span></div><div class='output co'>#&gt; <span class='message'>→ creating full model...</span></div><div class='output co'>#&gt; <span class='message'>→ pruning branches (<span style='color: #262626; background-color: #DADADA;'>`if`</span>/<span style='color: #262626; background-color: #DADADA;'>`else`</span>)...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ loading into <span style='color: #0000BB;'>symengine</span> environment...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ creating full model...</span></div><div class='output co'>#&gt; <span class='message'>→ pruning branches (<span style='color: #262626; background-color: #DADADA;'>`if`</span>/<span style='color: #262626; background-color: #DADADA;'>`else`</span>)...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ loading into <span style='color: #0000BB;'>symengine</span> environment...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ calculate jacobian</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate sensitivities</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate ∂(f)/∂(η)</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate ∂(R²)/∂(η)</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in inner model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in inner model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in EBE model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in EBE model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ compiling inner model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in FD model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in FD model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ compiling EBE model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ compiling events FD model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>Model:</span></div><div class='output co'>#&gt; <span class='message'>cmt(parent);</span>
#&gt; <span class='message'>cmt(A1);</span>
#&gt; <span class='message'>rx_expr_6~ETA[1]+THETA[1];</span>
#&gt; <span class='message'>parent(0)=rx_expr_6;</span>
#&gt; <span class='message'>rx_expr_7~ETA[2]+THETA[2];</span>
#&gt; <span class='message'>rx_expr_10~exp(rx_expr_7);</span>
#&gt; <span class='message'>d/dt(parent)=-rx_expr_10*parent;</span>
#&gt; <span class='message'>rx_expr_8~ETA[3]+THETA[3];</span>
#&gt; <span class='message'>rx_expr_11~exp(rx_expr_8);</span>
#&gt; <span class='message'>d/dt(A1)=-rx_expr_11*A1+rx_expr_10*parent*f_parent_to_A1;</span>
#&gt; <span class='message'>rx_expr_0~CMT==2;</span>
#&gt; <span class='message'>rx_expr_1~CMT==1;</span>
#&gt; <span class='message'>rx_expr_2~1-(rx_expr_0);</span>
#&gt; <span class='message'>rx_yj_~2*(rx_expr_2)*(rx_expr_1)+2*(rx_expr_0);</span>
#&gt; <span class='message'>rx_expr_3~(rx_expr_0);</span>
#&gt; <span class='message'>rx_expr_5~(rx_expr_2);</span>
#&gt; <span class='message'>rx_expr_13~rx_expr_5*(rx_expr_1);</span>
#&gt; <span class='message'>rx_lambda_~rx_expr_13+rx_expr_3;</span>
#&gt; <span class='message'>rx_hi_~rx_expr_13+rx_expr_3;</span>
#&gt; <span class='message'>rx_low_~0;</span>
#&gt; <span class='message'>rx_expr_4~A1*(rx_expr_0);</span>
#&gt; <span class='message'>rx_expr_9~parent*(rx_expr_2);</span>
#&gt; <span class='message'>rx_expr_14~rx_expr_9*(rx_expr_1);</span>
#&gt; <span class='message'>rx_pred_=(rx_expr_4+rx_expr_14)*(rx_expr_0)+(rx_expr_4+rx_expr_14)*(rx_expr_2)*(rx_expr_1);</span>
#&gt; <span class='message'>rx_expr_12~Rx_pow_di(THETA[5],2);</span>
#&gt; <span class='message'>rx_r_=(rx_expr_0)*rx_expr_12+(rx_expr_2)*(rx_expr_1)*rx_expr_12;</span>
#&gt; <span class='message'>parent_0=THETA[1];</span>
#&gt; <span class='message'>log_k_parent=THETA[2];</span>
#&gt; <span class='message'>log_k_A1=THETA[3];</span>
#&gt; <span class='message'>f_parent_qlogis=THETA[4];</span>
#&gt; <span class='message'>sigma=THETA[5];</span>
#&gt; <span class='message'>eta.parent_0=ETA[1];</span>
#&gt; <span class='message'>eta.log_k_parent=ETA[2];</span>
#&gt; <span class='message'>eta.log_k_A1=ETA[3];</span>
#&gt; <span class='message'>eta.f_parent_qlogis=ETA[4];</span>
#&gt; <span class='message'>parent_0_model=rx_expr_6;</span>
#&gt; <span class='message'>k_parent=rx_expr_10;</span>
#&gt; <span class='message'>k_A1=rx_expr_11;</span>
#&gt; <span class='message'>f_parent=1/(1+exp(-(ETA[4]+THETA[4])));</span>
#&gt; <span class='message'>tad=tad();</span>
#&gt; <span class='message'>dosenum=dosenum();</span></div><div class='output co'>#&gt; <span class='message'>Needed Covariates:</span></div><div class='output co'>#&gt; <span class='message'>[1] "f_parent_to_A1" "CMT"           </span></div><div class='output co'>#&gt; <span class='error'>Error in (function (data, inits, PKpars, model = NULL, pred = NULL, err = NULL,     lower = -Inf, upper = Inf, fixed = NULL, skipCov = NULL,     control = foceiControl(), thetaNames = NULL, etaNames = NULL,     etaMat = NULL, ..., env = NULL, keep = NULL, drop = NULL) {    set.seed(control$seed)    .pt &lt;- proc.time()    RxODE::.setWarnIdSort(FALSE)    on.exit(RxODE::.setWarnIdSort(TRUE))    loadNamespace("n1qn1")    if (!RxODE::rxIs(control, "foceiControl")) {        control &lt;- do.call(foceiControl, control)    }    if (is.null(env)) {        .ret &lt;- new.env(parent = emptyenv())    }    else {        .ret &lt;- env    }    .ret$origData &lt;- data    .ret$etaNames &lt;- etaNames    .ret$thetaFixed &lt;- fixed    .ret$control &lt;- control    .ret$control$focei.mu.ref &lt;- integer(0)    if (is(model, "RxODE") || is(model, "character")) {        .ret$ODEmodel &lt;- TRUE        if (class(pred) != "function") {            stop("pred must be a function specifying the prediction variables in this model.")        }    }    else {        .ret$ODEmodel &lt;- TRUE        model &lt;- RxODE::rxGetLin(PKpars)        pred &lt;- eval(parse(text = "function(){return(Central);}"))    }    .square &lt;- function(x) x * x    .ret$diagXformInv &lt;- c(sqrt = ".square", log = "exp", identity = "identity")[control$diagXform]    if (is.null(err)) {        err &lt;- eval(parse(text = paste0("function(){err", paste(inits$ERROR[[1]],             collapse = ""), "}")))    }    .covNames &lt;- .parNames &lt;- c()    .ret$adjLik &lt;- control$adjLik    .mixed &lt;- !is.null(inits$OMGA) &amp;&amp; length(inits$OMGA) &gt; 0    if (!exists("noLik", envir = .ret)) {        .atol &lt;- rep(control$atol, length(RxODE::rxModelVars(model)$state))        .rtol &lt;- rep(control$rtol, length(RxODE::rxModelVars(model)$state))        .ssAtol &lt;- rep(control$ssAtol, length(RxODE::rxModelVars(model)$state))        .ssRtol &lt;- rep(control$ssRtol, length(RxODE::rxModelVars(model)$state))        .ret$model &lt;- RxODE::rxSymPySetupPred(model, pred, PKpars,             err, grad = (control$derivMethod == 2L), pred.minus.dv = TRUE,             sum.prod = control$sumProd, theta.derivs = FALSE,             optExpression = control$optExpression, interaction = (control$interaction ==                 1L), only.numeric = !.mixed, run.internal = TRUE,             addProp = control$addProp)        if (!is.null(.ret$model$inner)) {            .atol &lt;- c(.atol, rep(control$atolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                 length(.atol)))            .rtol &lt;- c(.rtol, rep(control$rtolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                 length(.rtol)))            .ret$control$rxControl$atol &lt;- .atol            .ret$control$rxControl$rtol &lt;- .rtol            .ssAtol &lt;- c(.ssAtol, rep(control$ssAtolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                 length(.ssAtol)))            .ssRtol &lt;- c(.ssRtol, rep(control$ssRtolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                 length(.ssRtol)))            .ret$control$rxControl$ssAtol &lt;- .ssAtol            .ret$control$rxControl$ssRtol &lt;- .ssRtol        }        .covNames &lt;- .parNames &lt;- RxODE::rxParams(.ret$model$pred.only)        .covNames &lt;- .covNames[regexpr(rex::rex(start, or("THETA",             "ETA"), "[", numbers, "]", end), .covNames) == -1]        colnames(data) &lt;- sapply(names(data), function(x) {            if (any(x == .covNames)) {                return(x)            }            else {                return(toupper(x))            }        })        .lhs &lt;- c(names(RxODE::rxInits(.ret$model$pred.only)),             RxODE::rxLhs(.ret$model$pred.only))        if (length(.lhs) &gt; 0) {            .covNames &lt;- .covNames[regexpr(rex::rex(start, or(.lhs),                 end), .covNames) == -1]        }        if (length(.covNames) &gt; 0) {            if (!all(.covNames %in% names(data))) {                message("Model:")                RxODE::rxCat(.ret$model$pred.only)                message("Needed Covariates:")                nlmixrPrint(.covNames)                stop("Not all the covariates are in the dataset.")            }            message("Needed Covariates:")            print(.covNames)        }        .extraPars &lt;- .ret$model$extra.pars    }    else {        if (.ret$noLik) {            .atol &lt;- rep(control$atol, length(RxODE::rxModelVars(model)$state))            .rtol &lt;- rep(control$rtol, length(RxODE::rxModelVars(model)$state))            .ret$model &lt;- RxODE::rxSymPySetupPred(model, pred,                 PKpars, err, grad = FALSE, pred.minus.dv = TRUE,                 sum.prod = control$sumProd, theta.derivs = FALSE,                 optExpression = control$optExpression, run.internal = TRUE,                 only.numeric = TRUE, addProp = control$addProp)            if (!is.null(.ret$model$inner)) {                .atol &lt;- c(.atol, rep(control$atolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                   length(.atol)))                .rtol &lt;- c(.rtol, rep(control$rtolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                   length(.rtol)))                .ret$control$rxControl$atol &lt;- .atol                .ret$control$rxControl$rtol &lt;- .rtol            }            .covNames &lt;- .parNames &lt;- RxODE::rxParams(.ret$model$pred.only)            .covNames &lt;- .covNames[regexpr(rex::rex(start, or("THETA",                 "ETA"), "[", numbers, "]", end), .covNames) ==                 -1]            colnames(data) &lt;- sapply(names(data), function(x) {                if (any(x == .covNames)) {                  return(x)                }                else {                  return(toupper(x))                }            })            .lhs &lt;- c(names(RxODE::rxInits(.ret$model$pred.only)),                 RxODE::rxLhs(.ret$model$pred.only))            if (length(.lhs) &gt; 0) {                .covNames &lt;- .covNames[regexpr(rex::rex(start,                   or(.lhs), end), .covNames) == -1]            }            if (length(.covNames) &gt; 0) {                if (!all(.covNames %in% names(data))) {                  message("Model:")                  RxODE::rxCat(.ret$model$pred.only)                  message("Needed Covariates:")                  nlmixrPrint(.covNames)                  stop("Not all the covariates are in the dataset.")                }                message("Needed Covariates:")                print(.covNames)            }            .extraPars &lt;- .ret$model$extra.pars        }        else {            .extraPars &lt;- NULL        }    }    .ret$skipCov &lt;- skipCov    if (is.null(skipCov)) {        if (is.null(fixed)) {            .tmp &lt;- rep(FALSE, length(inits$THTA))        }        else {            if (length(fixed) &lt; length(inits$THTA)) {                .tmp &lt;- c(fixed, rep(FALSE, length(inits$THTA) -                   length(fixed)))            }            else {                .tmp &lt;- fixed[1:length(inits$THTA)]            }        }        if (exists("uif", envir = .ret)) {            .uifErr &lt;- .ret$uif$ini$err[!is.na(.ret$uif$ini$ntheta)]            .uifErr &lt;- sapply(.uifErr, function(x) {                if (is.na(x)) {                  return(FALSE)                }                return(!any(x == c("pow2", "tbs", "tbsYj")))            })            .tmp &lt;- (.tmp | .uifErr)        }        .ret$skipCov &lt;- c(.tmp, rep(TRUE, length(.extraPars)))        .ret$control$focei.mu.ref &lt;- .ret$uif$focei.mu.ref    }    if (is.null(.extraPars)) {        .nms &lt;- c(sprintf("THETA[%s]", seq_along(inits$THTA)))    }    else {        .nms &lt;- c(sprintf("THETA[%s]", seq_along(inits$THTA)),             sprintf("ERR[%s]", seq_along(.extraPars)))    }    if (!is.null(thetaNames) &amp;&amp; (length(inits$THTA) + length(.extraPars)) ==         length(thetaNames)) {        .nms &lt;- thetaNames    }    .ret$thetaNames &lt;- .nms    .thetaReset$thetaNames &lt;- .nms    if (length(lower) == 1) {        lower &lt;- rep(lower, length(inits$THTA))    }    else if (length(lower) != length(inits$THTA)) {        print(inits$THTA)        print(lower)        stop("Lower must be a single constant for all the THETA lower bounds, or match the dimension of THETA.")    }    if (length(upper) == 1) {        upper &lt;- rep(upper, length(inits$THTA))    }    else if (length(lower) != length(inits$THTA)) {        stop("Upper must be a single constant for all the THETA lower bounds, or match the dimension of THETA.")    }    if (!is.null(.extraPars)) {        .ret$model$extra.pars &lt;- eval(call(control$diagXform,             .ret$model$extra.pars))        if (length(.ret$model$extra.pars) &gt; 0) {            inits$THTA &lt;- c(inits$THTA, .ret$model$extra.pars)            .lowerErr &lt;- rep(control$atol[1] * 10, length(.ret$model$extra.pars))            .upperErr &lt;- rep(Inf, length(.ret$model$extra.pars))            lower &lt;- c(lower, .lowerErr)            upper &lt;- c(upper, .upperErr)        }    }    if (is.null(data$ID))         stop("\"ID\" not found in data")    if (is.null(data$DV))         stop("\"DV\" not found in data")    if (is.null(data$EVID))         data$EVID &lt;- 0    if (is.null(data$AMT))         data$AMT &lt;- 0    for (.v in c("TIME", "AMT", "DV", .covNames)) {        data[[.v]] &lt;- as.double(data[[.v]])    }    .ret$dataSav &lt;- data    .ds &lt;- data[data$EVID != 0 &amp; data$EVID != 2, c("ID", "TIME",         "AMT", "EVID", .covNames)]    .w &lt;- which(tolower(names(data)) == "limit")    .limitName &lt;- NULL    if (length(.w) == 1L) {        .limitName &lt;- names(data)[.w]    }    .censName &lt;- NULL    .w &lt;- which(tolower(names(data)) == "cens")    if (length(.w) == 1L) {        .censName &lt;- names(data[.w])    }    data &lt;- data[data$EVID == 0 | data$EVID == 2, c("ID", "TIME",         "DV", "EVID", .covNames, .limitName, .censName)]    .w &lt;- which(!(names(.ret$dataSav) %in% c(.covNames, keep)))    names(.ret$dataSav)[.w] &lt;- tolower(names(.ret$dataSav[.w]))    if (.mixed) {        .lh &lt;- .parseOM(inits$OMGA)        .nlh &lt;- sapply(.lh, length)        .osplt &lt;- rep(1:length(.lh), .nlh)        .lini &lt;- list(inits$THTA, unlist(.lh))        .nlini &lt;- sapply(.lini, length)        .nsplt &lt;- rep(1:length(.lini), .nlini)        .om0 &lt;- .genOM(.lh)        if (length(etaNames) == dim(.om0)[1]) {            .ret$etaNames &lt;- .ret$etaNames        }        else {            .ret$etaNames &lt;- sprintf("ETA[%d]", seq(1, dim(.om0)[1]))        }        .ret$rxInv &lt;- RxODE::rxSymInvCholCreate(mat = .om0, diag.xform = control$diagXform)        .ret$xType &lt;- .ret$rxInv$xType        .om0a &lt;- .om0        .om0a &lt;- .om0a/control$diagOmegaBoundLower        .om0b &lt;- .om0        .om0b &lt;- .om0b * control$diagOmegaBoundUpper        .om0a &lt;- RxODE::rxSymInvCholCreate(mat = .om0a, diag.xform = control$diagXform)        .om0b &lt;- RxODE::rxSymInvCholCreate(mat = .om0b, diag.xform = control$diagXform)        .omdf &lt;- data.frame(a = .om0a$theta, m = .ret$rxInv$theta,             b = .om0b$theta, diag = .om0a$theta.diag)        .omdf$lower &lt;- with(.omdf, ifelse(a &gt; b, b, a))        .omdf$lower &lt;- with(.omdf, ifelse(lower == m, -Inf, lower))        .omdf$lower &lt;- with(.omdf, ifelse(!diag, -Inf, lower))        .omdf$upper &lt;- with(.omdf, ifelse(a &lt; b, b, a))        .omdf$upper &lt;- with(.omdf, ifelse(upper == m, Inf, upper))        .omdf$upper &lt;- with(.omdf, ifelse(!diag, Inf, upper))        .ret$control$nomega &lt;- length(.omdf$lower)        .ret$control$neta &lt;- sum(.omdf$diag)        .ret$control$ntheta &lt;- length(lower)        .ret$control$nfixed &lt;- sum(fixed)        lower &lt;- c(lower, .omdf$lower)        upper &lt;- c(upper, .omdf$upper)    }    else {        .ret$control$nomega &lt;- 0        .ret$control$neta &lt;- 0        .ret$xType &lt;- -1        .ret$control$ntheta &lt;- length(lower)        .ret$control$nfixed &lt;- sum(fixed)    }    .ret$lower &lt;- lower    .ret$upper &lt;- upper    .ret$thetaIni &lt;- inits$THTA    .scaleC &lt;- double(length(lower))    if (is.null(control$scaleC)) {        .scaleC &lt;- rep(NA_real_, length(lower))    }    else {        .scaleC &lt;- as.double(control$scaleC)        if (length(lower) &gt; length(.scaleC)) {            .scaleC &lt;- c(.scaleC, rep(NA_real_, length(lower) -                 length(.scaleC)))        }        else if (length(lower) &lt; length(.scaleC)) {            .scaleC &lt;- .scaleC[seq(1, length(lower))]            warning("scaleC control option has more options than estimated population parameters, please check.")        }    }    .ret$scaleC &lt;- .scaleC    if (exists("uif", envir = .ret)) {        .ini &lt;- as.data.frame(.ret$uif$ini)[!is.na(.ret$uif$ini$err),             c("est", "err", "ntheta")]        for (.i in seq_along(.ini$err)) {            if (is.na(.ret$scaleC[.ini$ntheta[.i]])) {                if (any(.ini$err[.i] == c("boxCox", "yeoJohnson",                   "pow2", "tbs", "tbsYj"))) {                  .ret$scaleC[.ini$ntheta[.i]] &lt;- 1                }                else if (any(.ini$err[.i] == c("prop", "add",                   "norm", "dnorm", "logn", "dlogn", "lnorm",                   "dlnorm"))) {                  .ret$scaleC[.ini$ntheta[.i]] &lt;- 0.5 * abs(.ini$est[.i])                }            }        }        for (.i in .ini$model$extraProps$powTheta) {            if (is.na(.ret$scaleC[.i]))                 .ret$scaleC[.i] &lt;- 1        }        .ini &lt;- as.data.frame(.ret$uif$ini)        for (.i in .ini$model$extraProps$factorial) {            if (is.na(.ret$scaleC[.i]))                 .ret$scaleC[.i] &lt;- abs(1/digamma(.ini$est[.i] +                   1))        }        for (.i in .ini$model$extraProps$gamma) {            if (is.na(.ret$scaleC[.i]))                 .ret$scaleC[.i] &lt;- abs(1/digamma(.ini$est[.i]))        }        for (.i in .ini$model$extraProps$log) {            if (is.na(.ret$scaleC[.i]))                 .ret$scaleC[.i] &lt;- log(abs(.ini$est[.i])) * abs(.ini$est[.i])        }        for (.i in .ret$logitThetas) {            .b &lt;- .ret$logitThetasLow[.i]            .c &lt;- .ret$logitThetasHi[.i]            .a &lt;- .ini$est[.i]            if (is.na(.ret$scaleC[.i])) {                .ret$scaleC[.i] &lt;- 1 * (-.b + .c) * exp(-.a)/((1 +                   exp(-.a))^2 * (.b + 1 * (-.b + .c)/(1 + exp(-.a))))            }        }    }    names(.ret$thetaIni) &lt;- sprintf("THETA[%d]", seq_along(.ret$thetaIni))    if (is.null(etaMat) &amp; !is.null(control$etaMat)) {        .ret$etaMat &lt;- control$etaMat    }    else {        .ret$etaMat &lt;- etaMat    }    .ret$setupTime &lt;- (proc.time() - .pt)["elapsed"]    if (exists("uif", envir = .ret)) {        .tmp &lt;- .ret$uif$logThetasList        .ret$logThetas &lt;- .tmp[[1]]        .ret$logThetasF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$logitThetasList        .ret$logitThetas &lt;- .tmp[[1]]        .ret$logitThetasF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$logitThetasListLow        .ret$logitThetasLow &lt;- .tmp[[1]]        .ret$logitThetasLowF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$logitThetasListHi        .ret$logitThetasHi &lt;- .tmp[[1]]        .ret$logitThetasHiF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$probitThetasList        .ret$probitThetas &lt;- .tmp[[1]]        .ret$probitThetasF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$probitThetasListLow        .ret$probitThetasLow &lt;- .tmp[[1]]        .ret$probitThetasLowF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$probitThetasListHi        .ret$probitThetasHi &lt;- .tmp[[1]]        .ret$probitThetasHiF &lt;- .tmp[[2]]    }    else {        .ret$logThetasF &lt;- integer(0)        .ret$logitThetasF &lt;- integer(0)        .ret$logitThetasHiF &lt;- numeric(0)        .ret$logitThetasLowF &lt;- numeric(0)        .ret$logitThetas &lt;- integer(0)        .ret$logitThetasHi &lt;- numeric(0)        .ret$logitThetasLow &lt;- numeric(0)        .ret$probitThetasF &lt;- integer(0)        .ret$probitThetasHiF &lt;- numeric(0)        .ret$probitThetasLowF &lt;- numeric(0)        .ret$probitThetas &lt;- integer(0)        .ret$probitThetasHi &lt;- numeric(0)        .ret$probitThetasLow &lt;- numeric(0)    }    if (exists("noLik", envir = .ret)) {        if (!.ret$noLik) {            .ret$.params &lt;- c(sprintf("THETA[%d]", seq_along(.ret$thetaIni)),                 sprintf("ETA[%d]", seq(1, dim(.om0)[1])))            .ret$.thetan &lt;- length(.ret$thetaIni)            .ret$nobs &lt;- sum(data$EVID == 0)        }    }    .ret$control$printTop &lt;- TRUE    .ret$control$nF &lt;- 0    .est0 &lt;- .ret$thetaIni    if (!is.null(.ret$model$pred.nolhs)) {        .ret$control$predNeq &lt;- length(.ret$model$pred.nolhs$state)    }    else {        .ret$control$predNeq &lt;- 0L    }    .fitFun &lt;- function(.ret) {        this.env &lt;- environment()        assign("err", "theta reset", this.env)        while (this.env$err == "theta reset") {            assign("err", "", this.env)            .ret0 &lt;- tryCatch({                foceiFitCpp_(.ret)            }, error = function(e) {                if (regexpr("theta reset", e$message) != -1) {                  assign("zeroOuter", FALSE, this.env)                  assign("zeroGrad", FALSE, this.env)                  if (regexpr("theta reset0", e$message) != -1) {                    assign("zeroGrad", TRUE, this.env)                  }                  else if (regexpr("theta resetZ", e$message) !=                     -1) {                    assign("zeroOuter", TRUE, this.env)                  }                  assign("err", "theta reset", this.env)                }                else {                  assign("err", e$message, this.env)                }            })            if (this.env$err == "theta reset") {                .nm &lt;- names(.ret$thetaIni)                .ret$thetaIni &lt;- setNames(.thetaReset$thetaIni +                   0, .nm)                .ret$rxInv$theta &lt;- .thetaReset$omegaTheta                .ret$control$printTop &lt;- FALSE                .ret$etaMat &lt;- .thetaReset$etaMat                .ret$control$etaMat &lt;- .thetaReset$etaMat                .ret$control$maxInnerIterations &lt;- .thetaReset$maxInnerIterations                .ret$control$nF &lt;- .thetaReset$nF                .ret$control$gillRetC &lt;- .thetaReset$gillRetC                .ret$control$gillRet &lt;- .thetaReset$gillRet                .ret$control$gillRet &lt;- .thetaReset$gillRet                .ret$control$gillDf &lt;- .thetaReset$gillDf                .ret$control$gillDf2 &lt;- .thetaReset$gillDf2                .ret$control$gillErr &lt;- .thetaReset$gillErr                .ret$control$rEps &lt;- .thetaReset$rEps                .ret$control$aEps &lt;- .thetaReset$aEps                .ret$control$rEpsC &lt;- .thetaReset$rEpsC                .ret$control$aEpsC &lt;- .thetaReset$aEpsC                .ret$control$c1 &lt;- .thetaReset$c1                .ret$control$c2 &lt;- .thetaReset$c2                if (this.env$zeroOuter) {                  message("Posthoc reset")                  .ret$control$maxOuterIterations &lt;- 0L                }                else if (this.env$zeroGrad) {                  message("Theta reset (zero gradient values); Switch to bobyqa")                  RxODE::rxReq("minqa")                  .ret$control$outerOptFun &lt;- .bobyqa                  .ret$control$outerOpt &lt;- -1L                }                else {                  message("Theta reset (ETA drift)")                }            }        }        if (this.env$err != "") {            stop(this.env$err)        }        else {            return(.ret0)        }    }    .ret0 &lt;- try(.fitFun(.ret))    .n &lt;- 1    while (inherits(.ret0, "try-error") &amp;&amp; control$maxOuterIterations !=         0 &amp;&amp; .n &lt;= control$nRetries) {        message(sprintf("Restart %s", .n))        .ret$control$nF &lt;- 0        .estNew &lt;- .est0 + 0.2 * .n * abs(.est0) * stats::runif(length(.est0)) -             0.1 * .n        .estNew &lt;- sapply(seq_along(.est0), function(.i) {            if (.ret$thetaFixed[.i]) {                return(.est0[.i])            }            else if (.estNew[.i] &lt; lower[.i]) {                return(lower + (.Machine$double.eps)^(1/7))            }            else if (.estNew[.i] &gt; upper[.i]) {                return(upper - (.Machine$double.eps)^(1/7))            }            else {                return(.estNew[.i])            }        })        .ret$thetaIni &lt;- .estNew        .ret0 &lt;- try(.fitFun(.ret))        .n &lt;- .n + 1    }    if (inherits(.ret0, "try-error"))         stop("Could not fit data.")    .ret &lt;- .ret0    if (exists("parHistData", .ret)) {        .tmp &lt;- .ret$parHistData        .tmp &lt;- .tmp[.tmp$type == "Unscaled", names(.tmp) !=             "type"]        .iter &lt;- .tmp$iter        .tmp &lt;- .tmp[, names(.tmp) != "iter"]        .ret$parHistStacked &lt;- data.frame(stack(.tmp), iter = .iter)        names(.ret$parHistStacked) &lt;- c("val", "par", "iter")        .ret$parHist &lt;- data.frame(iter = .iter, .tmp)    }    if (.mixed) {        .etas &lt;- .ret$ranef        .thetas &lt;- .ret$fixef        .pars &lt;- .Call(`_nlmixr_nlmixrParameters`, .thetas, .etas)        .ret$shrink &lt;- .Call(`_nlmixr_calcShrinkOnly`, .ret$omega,             .pars$eta.lst, length(.etas$ID))        .updateParFixed(.ret)    }    else {        .updateParFixed(.ret)    }    if (!exists("table", .ret)) {        .ret$table &lt;- tableControl()    }    if (control$calcTables) {        .ret &lt;- addTable(.ret, updateObject = "no", keep = keep,             drop = drop, table = .ret$table)    }    .ret})(data = dat, inits = .FoceiInits, PKpars = .pars, model = .mod,     pred = function() {        return(nlmixr_pred)    }, err = uif$error, lower = uif$focei.lower, upper = uif$focei.upper,     fixed = uif$focei.fixed, thetaNames = uif$focei.names, etaNames = uif$eta.names,     control = control, env = env, keep = .keep, drop = .drop): Not all the covariates are in the dataset.</span></div><div class='output co'>#&gt; <span class='message'>Timing stopped at: 5.549 0.41 5.959</span></div><div class='input'><span class='va'>f_nlmixr_fomc_sfo_focei_const</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/pkg/nlmixr/man/nlmixr.html'>nlmixr</a></span><span class='op'>(</span><span class='va'>f_mmkin_const</span><span class='op'>[</span><span class='st'>"FOMC-SFO"</span>, <span class='op'>]</span>, est <span class='op'>=</span> <span class='st'>"focei"</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> parameter labels from comments are typically ignored in non-interactive mode</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> Need to run with the source intact to parse comments</span></div><div class='output co'>#&gt; <span class='message'>→ creating full model...</span></div><div class='output co'>#&gt; <span class='message'>→ pruning branches (<span style='color: #262626; background-color: #DADADA;'>`if`</span>/<span style='color: #262626; background-color: #DADADA;'>`else`</span>)...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ loading into <span style='color: #0000BB;'>symengine</span> environment...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ creating full model...</span></div><div class='output co'>#&gt; <span class='message'>→ pruning branches (<span style='color: #262626; background-color: #DADADA;'>`if`</span>/<span style='color: #262626; background-color: #DADADA;'>`else`</span>)...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ loading into <span style='color: #0000BB;'>symengine</span> environment...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ calculate jacobian</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate sensitivities</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate ∂(f)/∂(η)</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate ∂(R²)/∂(η)</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in inner model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in inner model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in EBE model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in EBE model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ compiling inner model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in FD model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in FD model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ compiling EBE model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ compiling events FD model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>Model:</span></div><div class='output co'>#&gt; <span class='message'>cmt(parent);</span>
#&gt; <span class='message'>cmt(A1);</span>
#&gt; <span class='message'>rx_expr_6~ETA[1]+THETA[1];</span>
#&gt; <span class='message'>parent(0)=rx_expr_6;</span>
#&gt; <span class='message'>rx_expr_7~ETA[4]+THETA[4];</span>
#&gt; <span class='message'>rx_expr_8~ETA[5]+THETA[5];</span>
#&gt; <span class='message'>rx_expr_13~exp(-(rx_expr_8));</span>
#&gt; <span class='message'>rx_expr_15~t*rx_expr_13;</span>
#&gt; <span class='message'>rx_expr_16~1+rx_expr_15;</span>
#&gt; <span class='message'>rx_expr_18~rx_expr_7-(rx_expr_8);</span>
#&gt; <span class='message'>rx_expr_20~exp(rx_expr_18);</span>
#&gt; <span class='message'>d/dt(parent)=-rx_expr_20*parent/(rx_expr_16);</span>
#&gt; <span class='message'>rx_expr_9~ETA[2]+THETA[2];</span>
#&gt; <span class='message'>rx_expr_11~exp(rx_expr_9);</span>
#&gt; <span class='message'>d/dt(A1)=-rx_expr_11*A1+rx_expr_20*parent*f_parent_to_A1/(rx_expr_16);</span>
#&gt; <span class='message'>rx_expr_0~CMT==2;</span>
#&gt; <span class='message'>rx_expr_1~CMT==1;</span>
#&gt; <span class='message'>rx_expr_2~1-(rx_expr_0);</span>
#&gt; <span class='message'>rx_yj_~2*(rx_expr_2)*(rx_expr_1)+2*(rx_expr_0);</span>
#&gt; <span class='message'>rx_expr_3~(rx_expr_0);</span>
#&gt; <span class='message'>rx_expr_5~(rx_expr_2);</span>
#&gt; <span class='message'>rx_expr_14~rx_expr_5*(rx_expr_1);</span>
#&gt; <span class='message'>rx_lambda_~rx_expr_14+rx_expr_3;</span>
#&gt; <span class='message'>rx_hi_~rx_expr_14+rx_expr_3;</span>
#&gt; <span class='message'>rx_low_~0;</span>
#&gt; <span class='message'>rx_expr_4~A1*(rx_expr_0);</span>
#&gt; <span class='message'>rx_expr_10~parent*(rx_expr_2);</span>
#&gt; <span class='message'>rx_expr_17~rx_expr_10*(rx_expr_1);</span>
#&gt; <span class='message'>rx_pred_=(rx_expr_4+rx_expr_17)*(rx_expr_0)+(rx_expr_4+rx_expr_17)*(rx_expr_2)*(rx_expr_1);</span>
#&gt; <span class='message'>rx_expr_12~Rx_pow_di(THETA[6],2);</span>
#&gt; <span class='message'>rx_r_=(rx_expr_0)*rx_expr_12+(rx_expr_2)*(rx_expr_1)*rx_expr_12;</span>
#&gt; <span class='message'>parent_0=THETA[1];</span>
#&gt; <span class='message'>log_k_A1=THETA[2];</span>
#&gt; <span class='message'>f_parent_qlogis=THETA[3];</span>
#&gt; <span class='message'>log_alpha=THETA[4];</span>
#&gt; <span class='message'>log_beta=THETA[5];</span>
#&gt; <span class='message'>sigma=THETA[6];</span>
#&gt; <span class='message'>eta.parent_0=ETA[1];</span>
#&gt; <span class='message'>eta.log_k_A1=ETA[2];</span>
#&gt; <span class='message'>eta.f_parent_qlogis=ETA[3];</span>
#&gt; <span class='message'>eta.log_alpha=ETA[4];</span>
#&gt; <span class='message'>eta.log_beta=ETA[5];</span>
#&gt; <span class='message'>parent_0_model=rx_expr_6;</span>
#&gt; <span class='message'>k_A1=rx_expr_11;</span>
#&gt; <span class='message'>alpha=exp(rx_expr_7);</span>
#&gt; <span class='message'>beta=exp(rx_expr_8);</span>
#&gt; <span class='message'>f_parent=1/(1+exp(-(ETA[3]+THETA[3])));</span>
#&gt; <span class='message'>tad=tad();</span>
#&gt; <span class='message'>dosenum=dosenum();</span></div><div class='output co'>#&gt; <span class='message'>Needed Covariates:</span></div><div class='output co'>#&gt; <span class='message'>[1] "f_parent_to_A1" "CMT"           </span></div><div class='output co'>#&gt; <span class='error'>Error in (function (data, inits, PKpars, model = NULL, pred = NULL, err = NULL,     lower = -Inf, upper = Inf, fixed = NULL, skipCov = NULL,     control = foceiControl(), thetaNames = NULL, etaNames = NULL,     etaMat = NULL, ..., env = NULL, keep = NULL, drop = NULL) {    set.seed(control$seed)    .pt &lt;- proc.time()    RxODE::.setWarnIdSort(FALSE)    on.exit(RxODE::.setWarnIdSort(TRUE))    loadNamespace("n1qn1")    if (!RxODE::rxIs(control, "foceiControl")) {        control &lt;- do.call(foceiControl, control)    }    if (is.null(env)) {        .ret &lt;- new.env(parent = emptyenv())    }    else {        .ret &lt;- env    }    .ret$origData &lt;- data    .ret$etaNames &lt;- etaNames    .ret$thetaFixed &lt;- fixed    .ret$control &lt;- control    .ret$control$focei.mu.ref &lt;- integer(0)    if (is(model, "RxODE") || is(model, "character")) {        .ret$ODEmodel &lt;- TRUE        if (class(pred) != "function") {            stop("pred must be a function specifying the prediction variables in this model.")        }    }    else {        .ret$ODEmodel &lt;- TRUE        model &lt;- RxODE::rxGetLin(PKpars)        pred &lt;- eval(parse(text = "function(){return(Central);}"))    }    .square &lt;- function(x) x * x    .ret$diagXformInv &lt;- c(sqrt = ".square", log = "exp", identity = "identity")[control$diagXform]    if (is.null(err)) {        err &lt;- eval(parse(text = paste0("function(){err", paste(inits$ERROR[[1]],             collapse = ""), "}")))    }    .covNames &lt;- .parNames &lt;- c()    .ret$adjLik &lt;- control$adjLik    .mixed &lt;- !is.null(inits$OMGA) &amp;&amp; length(inits$OMGA) &gt; 0    if (!exists("noLik", envir = .ret)) {        .atol &lt;- rep(control$atol, length(RxODE::rxModelVars(model)$state))        .rtol &lt;- rep(control$rtol, length(RxODE::rxModelVars(model)$state))        .ssAtol &lt;- rep(control$ssAtol, length(RxODE::rxModelVars(model)$state))        .ssRtol &lt;- rep(control$ssRtol, length(RxODE::rxModelVars(model)$state))        .ret$model &lt;- RxODE::rxSymPySetupPred(model, pred, PKpars,             err, grad = (control$derivMethod == 2L), pred.minus.dv = TRUE,             sum.prod = control$sumProd, theta.derivs = FALSE,             optExpression = control$optExpression, interaction = (control$interaction ==                 1L), only.numeric = !.mixed, run.internal = TRUE,             addProp = control$addProp)        if (!is.null(.ret$model$inner)) {            .atol &lt;- c(.atol, rep(control$atolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                 length(.atol)))            .rtol &lt;- c(.rtol, rep(control$rtolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                 length(.rtol)))            .ret$control$rxControl$atol &lt;- .atol            .ret$control$rxControl$rtol &lt;- .rtol            .ssAtol &lt;- c(.ssAtol, rep(control$ssAtolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                 length(.ssAtol)))            .ssRtol &lt;- c(.ssRtol, rep(control$ssRtolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                 length(.ssRtol)))            .ret$control$rxControl$ssAtol &lt;- .ssAtol            .ret$control$rxControl$ssRtol &lt;- .ssRtol        }        .covNames &lt;- .parNames &lt;- RxODE::rxParams(.ret$model$pred.only)        .covNames &lt;- .covNames[regexpr(rex::rex(start, or("THETA",             "ETA"), "[", numbers, "]", end), .covNames) == -1]        colnames(data) &lt;- sapply(names(data), function(x) {            if (any(x == .covNames)) {                return(x)            }            else {                return(toupper(x))            }        })        .lhs &lt;- c(names(RxODE::rxInits(.ret$model$pred.only)),             RxODE::rxLhs(.ret$model$pred.only))        if (length(.lhs) &gt; 0) {            .covNames &lt;- .covNames[regexpr(rex::rex(start, or(.lhs),                 end), .covNames) == -1]        }        if (length(.covNames) &gt; 0) {            if (!all(.covNames %in% names(data))) {                message("Model:")                RxODE::rxCat(.ret$model$pred.only)                message("Needed Covariates:")                nlmixrPrint(.covNames)                stop("Not all the covariates are in the dataset.")            }            message("Needed Covariates:")            print(.covNames)        }        .extraPars &lt;- .ret$model$extra.pars    }    else {        if (.ret$noLik) {            .atol &lt;- rep(control$atol, length(RxODE::rxModelVars(model)$state))            .rtol &lt;- rep(control$rtol, length(RxODE::rxModelVars(model)$state))            .ret$model &lt;- RxODE::rxSymPySetupPred(model, pred,                 PKpars, err, grad = FALSE, pred.minus.dv = TRUE,                 sum.prod = control$sumProd, theta.derivs = FALSE,                 optExpression = control$optExpression, run.internal = TRUE,                 only.numeric = TRUE, addProp = control$addProp)            if (!is.null(.ret$model$inner)) {                .atol &lt;- c(.atol, rep(control$atolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                   length(.atol)))                .rtol &lt;- c(.rtol, rep(control$rtolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                   length(.rtol)))                .ret$control$rxControl$atol &lt;- .atol                .ret$control$rxControl$rtol &lt;- .rtol            }            .covNames &lt;- .parNames &lt;- RxODE::rxParams(.ret$model$pred.only)            .covNames &lt;- .covNames[regexpr(rex::rex(start, or("THETA",                 "ETA"), "[", numbers, "]", end), .covNames) ==                 -1]            colnames(data) &lt;- sapply(names(data), function(x) {                if (any(x == .covNames)) {                  return(x)                }                else {                  return(toupper(x))                }            })            .lhs &lt;- c(names(RxODE::rxInits(.ret$model$pred.only)),                 RxODE::rxLhs(.ret$model$pred.only))            if (length(.lhs) &gt; 0) {                .covNames &lt;- .covNames[regexpr(rex::rex(start,                   or(.lhs), end), .covNames) == -1]            }            if (length(.covNames) &gt; 0) {                if (!all(.covNames %in% names(data))) {                  message("Model:")                  RxODE::rxCat(.ret$model$pred.only)                  message("Needed Covariates:")                  nlmixrPrint(.covNames)                  stop("Not all the covariates are in the dataset.")                }                message("Needed Covariates:")                print(.covNames)            }            .extraPars &lt;- .ret$model$extra.pars        }        else {            .extraPars &lt;- NULL        }    }    .ret$skipCov &lt;- skipCov    if (is.null(skipCov)) {        if (is.null(fixed)) {            .tmp &lt;- rep(FALSE, length(inits$THTA))        }        else {            if (length(fixed) &lt; length(inits$THTA)) {                .tmp &lt;- c(fixed, rep(FALSE, length(inits$THTA) -                   length(fixed)))            }            else {                .tmp &lt;- fixed[1:length(inits$THTA)]            }        }        if (exists("uif", envir = .ret)) {            .uifErr &lt;- .ret$uif$ini$err[!is.na(.ret$uif$ini$ntheta)]            .uifErr &lt;- sapply(.uifErr, function(x) {                if (is.na(x)) {                  return(FALSE)                }                return(!any(x == c("pow2", "tbs", "tbsYj")))            })            .tmp &lt;- (.tmp | .uifErr)        }        .ret$skipCov &lt;- c(.tmp, rep(TRUE, length(.extraPars)))        .ret$control$focei.mu.ref &lt;- .ret$uif$focei.mu.ref    }    if (is.null(.extraPars)) {        .nms &lt;- c(sprintf("THETA[%s]", seq_along(inits$THTA)))    }    else {        .nms &lt;- c(sprintf("THETA[%s]", seq_along(inits$THTA)),             sprintf("ERR[%s]", seq_along(.extraPars)))    }    if (!is.null(thetaNames) &amp;&amp; (length(inits$THTA) + length(.extraPars)) ==         length(thetaNames)) {        .nms &lt;- thetaNames    }    .ret$thetaNames &lt;- .nms    .thetaReset$thetaNames &lt;- .nms    if (length(lower) == 1) {        lower &lt;- rep(lower, length(inits$THTA))    }    else if (length(lower) != length(inits$THTA)) {        print(inits$THTA)        print(lower)        stop("Lower must be a single constant for all the THETA lower bounds, or match the dimension of THETA.")    }    if (length(upper) == 1) {        upper &lt;- rep(upper, length(inits$THTA))    }    else if (length(lower) != length(inits$THTA)) {        stop("Upper must be a single constant for all the THETA lower bounds, or match the dimension of THETA.")    }    if (!is.null(.extraPars)) {        .ret$model$extra.pars &lt;- eval(call(control$diagXform,             .ret$model$extra.pars))        if (length(.ret$model$extra.pars) &gt; 0) {            inits$THTA &lt;- c(inits$THTA, .ret$model$extra.pars)            .lowerErr &lt;- rep(control$atol[1] * 10, length(.ret$model$extra.pars))            .upperErr &lt;- rep(Inf, length(.ret$model$extra.pars))            lower &lt;- c(lower, .lowerErr)            upper &lt;- c(upper, .upperErr)        }    }    if (is.null(data$ID))         stop("\"ID\" not found in data")    if (is.null(data$DV))         stop("\"DV\" not found in data")    if (is.null(data$EVID))         data$EVID &lt;- 0    if (is.null(data$AMT))         data$AMT &lt;- 0    for (.v in c("TIME", "AMT", "DV", .covNames)) {        data[[.v]] &lt;- as.double(data[[.v]])    }    .ret$dataSav &lt;- data    .ds &lt;- data[data$EVID != 0 &amp; data$EVID != 2, c("ID", "TIME",         "AMT", "EVID", .covNames)]    .w &lt;- which(tolower(names(data)) == "limit")    .limitName &lt;- NULL    if (length(.w) == 1L) {        .limitName &lt;- names(data)[.w]    }    .censName &lt;- NULL    .w &lt;- which(tolower(names(data)) == "cens")    if (length(.w) == 1L) {        .censName &lt;- names(data[.w])    }    data &lt;- data[data$EVID == 0 | data$EVID == 2, c("ID", "TIME",         "DV", "EVID", .covNames, .limitName, .censName)]    .w &lt;- which(!(names(.ret$dataSav) %in% c(.covNames, keep)))    names(.ret$dataSav)[.w] &lt;- tolower(names(.ret$dataSav[.w]))    if (.mixed) {        .lh &lt;- .parseOM(inits$OMGA)        .nlh &lt;- sapply(.lh, length)        .osplt &lt;- rep(1:length(.lh), .nlh)        .lini &lt;- list(inits$THTA, unlist(.lh))        .nlini &lt;- sapply(.lini, length)        .nsplt &lt;- rep(1:length(.lini), .nlini)        .om0 &lt;- .genOM(.lh)        if (length(etaNames) == dim(.om0)[1]) {            .ret$etaNames &lt;- .ret$etaNames        }        else {            .ret$etaNames &lt;- sprintf("ETA[%d]", seq(1, dim(.om0)[1]))        }        .ret$rxInv &lt;- RxODE::rxSymInvCholCreate(mat = .om0, diag.xform = control$diagXform)        .ret$xType &lt;- .ret$rxInv$xType        .om0a &lt;- .om0        .om0a &lt;- .om0a/control$diagOmegaBoundLower        .om0b &lt;- .om0        .om0b &lt;- .om0b * control$diagOmegaBoundUpper        .om0a &lt;- RxODE::rxSymInvCholCreate(mat = .om0a, diag.xform = control$diagXform)        .om0b &lt;- RxODE::rxSymInvCholCreate(mat = .om0b, diag.xform = control$diagXform)        .omdf &lt;- data.frame(a = .om0a$theta, m = .ret$rxInv$theta,             b = .om0b$theta, diag = .om0a$theta.diag)        .omdf$lower &lt;- with(.omdf, ifelse(a &gt; b, b, a))        .omdf$lower &lt;- with(.omdf, ifelse(lower == m, -Inf, lower))        .omdf$lower &lt;- with(.omdf, ifelse(!diag, -Inf, lower))        .omdf$upper &lt;- with(.omdf, ifelse(a &lt; b, b, a))        .omdf$upper &lt;- with(.omdf, ifelse(upper == m, Inf, upper))        .omdf$upper &lt;- with(.omdf, ifelse(!diag, Inf, upper))        .ret$control$nomega &lt;- length(.omdf$lower)        .ret$control$neta &lt;- sum(.omdf$diag)        .ret$control$ntheta &lt;- length(lower)        .ret$control$nfixed &lt;- sum(fixed)        lower &lt;- c(lower, .omdf$lower)        upper &lt;- c(upper, .omdf$upper)    }    else {        .ret$control$nomega &lt;- 0        .ret$control$neta &lt;- 0        .ret$xType &lt;- -1        .ret$control$ntheta &lt;- length(lower)        .ret$control$nfixed &lt;- sum(fixed)    }    .ret$lower &lt;- lower    .ret$upper &lt;- upper    .ret$thetaIni &lt;- inits$THTA    .scaleC &lt;- double(length(lower))    if (is.null(control$scaleC)) {        .scaleC &lt;- rep(NA_real_, length(lower))    }    else {        .scaleC &lt;- as.double(control$scaleC)        if (length(lower) &gt; length(.scaleC)) {            .scaleC &lt;- c(.scaleC, rep(NA_real_, length(lower) -                 length(.scaleC)))        }        else if (length(lower) &lt; length(.scaleC)) {            .scaleC &lt;- .scaleC[seq(1, length(lower))]            warning("scaleC control option has more options than estimated population parameters, please check.")        }    }    .ret$scaleC &lt;- .scaleC    if (exists("uif", envir = .ret)) {        .ini &lt;- as.data.frame(.ret$uif$ini)[!is.na(.ret$uif$ini$err),             c("est", "err", "ntheta")]        for (.i in seq_along(.ini$err)) {            if (is.na(.ret$scaleC[.ini$ntheta[.i]])) {                if (any(.ini$err[.i] == c("boxCox", "yeoJohnson",                   "pow2", "tbs", "tbsYj"))) {                  .ret$scaleC[.ini$ntheta[.i]] &lt;- 1                }                else if (any(.ini$err[.i] == c("prop", "add",                   "norm", "dnorm", "logn", "dlogn", "lnorm",                   "dlnorm"))) {                  .ret$scaleC[.ini$ntheta[.i]] &lt;- 0.5 * abs(.ini$est[.i])                }            }        }        for (.i in .ini$model$extraProps$powTheta) {            if (is.na(.ret$scaleC[.i]))                 .ret$scaleC[.i] &lt;- 1        }        .ini &lt;- as.data.frame(.ret$uif$ini)        for (.i in .ini$model$extraProps$factorial) {            if (is.na(.ret$scaleC[.i]))                 .ret$scaleC[.i] &lt;- abs(1/digamma(.ini$est[.i] +                   1))        }        for (.i in .ini$model$extraProps$gamma) {            if (is.na(.ret$scaleC[.i]))                 .ret$scaleC[.i] &lt;- abs(1/digamma(.ini$est[.i]))        }        for (.i in .ini$model$extraProps$log) {            if (is.na(.ret$scaleC[.i]))                 .ret$scaleC[.i] &lt;- log(abs(.ini$est[.i])) * abs(.ini$est[.i])        }        for (.i in .ret$logitThetas) {            .b &lt;- .ret$logitThetasLow[.i]            .c &lt;- .ret$logitThetasHi[.i]            .a &lt;- .ini$est[.i]            if (is.na(.ret$scaleC[.i])) {                .ret$scaleC[.i] &lt;- 1 * (-.b + .c) * exp(-.a)/((1 +                   exp(-.a))^2 * (.b + 1 * (-.b + .c)/(1 + exp(-.a))))            }        }    }    names(.ret$thetaIni) &lt;- sprintf("THETA[%d]", seq_along(.ret$thetaIni))    if (is.null(etaMat) &amp; !is.null(control$etaMat)) {        .ret$etaMat &lt;- control$etaMat    }    else {        .ret$etaMat &lt;- etaMat    }    .ret$setupTime &lt;- (proc.time() - .pt)["elapsed"]    if (exists("uif", envir = .ret)) {        .tmp &lt;- .ret$uif$logThetasList        .ret$logThetas &lt;- .tmp[[1]]        .ret$logThetasF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$logitThetasList        .ret$logitThetas &lt;- .tmp[[1]]        .ret$logitThetasF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$logitThetasListLow        .ret$logitThetasLow &lt;- .tmp[[1]]        .ret$logitThetasLowF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$logitThetasListHi        .ret$logitThetasHi &lt;- .tmp[[1]]        .ret$logitThetasHiF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$probitThetasList        .ret$probitThetas &lt;- .tmp[[1]]        .ret$probitThetasF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$probitThetasListLow        .ret$probitThetasLow &lt;- .tmp[[1]]        .ret$probitThetasLowF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$probitThetasListHi        .ret$probitThetasHi &lt;- .tmp[[1]]        .ret$probitThetasHiF &lt;- .tmp[[2]]    }    else {        .ret$logThetasF &lt;- integer(0)        .ret$logitThetasF &lt;- integer(0)        .ret$logitThetasHiF &lt;- numeric(0)        .ret$logitThetasLowF &lt;- numeric(0)        .ret$logitThetas &lt;- integer(0)        .ret$logitThetasHi &lt;- numeric(0)        .ret$logitThetasLow &lt;- numeric(0)        .ret$probitThetasF &lt;- integer(0)        .ret$probitThetasHiF &lt;- numeric(0)        .ret$probitThetasLowF &lt;- numeric(0)        .ret$probitThetas &lt;- integer(0)        .ret$probitThetasHi &lt;- numeric(0)        .ret$probitThetasLow &lt;- numeric(0)    }    if (exists("noLik", envir = .ret)) {        if (!.ret$noLik) {            .ret$.params &lt;- c(sprintf("THETA[%d]", seq_along(.ret$thetaIni)),                 sprintf("ETA[%d]", seq(1, dim(.om0)[1])))            .ret$.thetan &lt;- length(.ret$thetaIni)            .ret$nobs &lt;- sum(data$EVID == 0)        }    }    .ret$control$printTop &lt;- TRUE    .ret$control$nF &lt;- 0    .est0 &lt;- .ret$thetaIni    if (!is.null(.ret$model$pred.nolhs)) {        .ret$control$predNeq &lt;- length(.ret$model$pred.nolhs$state)    }    else {        .ret$control$predNeq &lt;- 0L    }    .fitFun &lt;- function(.ret) {        this.env &lt;- environment()        assign("err", "theta reset", this.env)        while (this.env$err == "theta reset") {            assign("err", "", this.env)            .ret0 &lt;- tryCatch({                foceiFitCpp_(.ret)            }, error = function(e) {                if (regexpr("theta reset", e$message) != -1) {                  assign("zeroOuter", FALSE, this.env)                  assign("zeroGrad", FALSE, this.env)                  if (regexpr("theta reset0", e$message) != -1) {                    assign("zeroGrad", TRUE, this.env)                  }                  else if (regexpr("theta resetZ", e$message) !=                     -1) {                    assign("zeroOuter", TRUE, this.env)                  }                  assign("err", "theta reset", this.env)                }                else {                  assign("err", e$message, this.env)                }            })            if (this.env$err == "theta reset") {                .nm &lt;- names(.ret$thetaIni)                .ret$thetaIni &lt;- setNames(.thetaReset$thetaIni +                   0, .nm)                .ret$rxInv$theta &lt;- .thetaReset$omegaTheta                .ret$control$printTop &lt;- FALSE                .ret$etaMat &lt;- .thetaReset$etaMat                .ret$control$etaMat &lt;- .thetaReset$etaMat                .ret$control$maxInnerIterations &lt;- .thetaReset$maxInnerIterations                .ret$control$nF &lt;- .thetaReset$nF                .ret$control$gillRetC &lt;- .thetaReset$gillRetC                .ret$control$gillRet &lt;- .thetaReset$gillRet                .ret$control$gillRet &lt;- .thetaReset$gillRet                .ret$control$gillDf &lt;- .thetaReset$gillDf                .ret$control$gillDf2 &lt;- .thetaReset$gillDf2                .ret$control$gillErr &lt;- .thetaReset$gillErr                .ret$control$rEps &lt;- .thetaReset$rEps                .ret$control$aEps &lt;- .thetaReset$aEps                .ret$control$rEpsC &lt;- .thetaReset$rEpsC                .ret$control$aEpsC &lt;- .thetaReset$aEpsC                .ret$control$c1 &lt;- .thetaReset$c1                .ret$control$c2 &lt;- .thetaReset$c2                if (this.env$zeroOuter) {                  message("Posthoc reset")                  .ret$control$maxOuterIterations &lt;- 0L                }                else if (this.env$zeroGrad) {                  message("Theta reset (zero gradient values); Switch to bobyqa")                  RxODE::rxReq("minqa")                  .ret$control$outerOptFun &lt;- .bobyqa                  .ret$control$outerOpt &lt;- -1L                }                else {                  message("Theta reset (ETA drift)")                }            }        }        if (this.env$err != "") {            stop(this.env$err)        }        else {            return(.ret0)        }    }    .ret0 &lt;- try(.fitFun(.ret))    .n &lt;- 1    while (inherits(.ret0, "try-error") &amp;&amp; control$maxOuterIterations !=         0 &amp;&amp; .n &lt;= control$nRetries) {        message(sprintf("Restart %s", .n))        .ret$control$nF &lt;- 0        .estNew &lt;- .est0 + 0.2 * .n * abs(.est0) * stats::runif(length(.est0)) -             0.1 * .n        .estNew &lt;- sapply(seq_along(.est0), function(.i) {            if (.ret$thetaFixed[.i]) {                return(.est0[.i])            }            else if (.estNew[.i] &lt; lower[.i]) {                return(lower + (.Machine$double.eps)^(1/7))            }            else if (.estNew[.i] &gt; upper[.i]) {                return(upper - (.Machine$double.eps)^(1/7))            }            else {                return(.estNew[.i])            }        })        .ret$thetaIni &lt;- .estNew        .ret0 &lt;- try(.fitFun(.ret))        .n &lt;- .n + 1    }    if (inherits(.ret0, "try-error"))         stop("Could not fit data.")    .ret &lt;- .ret0    if (exists("parHistData", .ret)) {        .tmp &lt;- .ret$parHistData        .tmp &lt;- .tmp[.tmp$type == "Unscaled", names(.tmp) !=             "type"]        .iter &lt;- .tmp$iter        .tmp &lt;- .tmp[, names(.tmp) != "iter"]        .ret$parHistStacked &lt;- data.frame(stack(.tmp), iter = .iter)        names(.ret$parHistStacked) &lt;- c("val", "par", "iter")        .ret$parHist &lt;- data.frame(iter = .iter, .tmp)    }    if (.mixed) {        .etas &lt;- .ret$ranef        .thetas &lt;- .ret$fixef        .pars &lt;- .Call(`_nlmixr_nlmixrParameters`, .thetas, .etas)        .ret$shrink &lt;- .Call(`_nlmixr_calcShrinkOnly`, .ret$omega,             .pars$eta.lst, length(.etas$ID))        .updateParFixed(.ret)    }    else {        .updateParFixed(.ret)    }    if (!exists("table", .ret)) {        .ret$table &lt;- tableControl()    }    if (control$calcTables) {        .ret &lt;- addTable(.ret, updateObject = "no", keep = keep,             drop = drop, table = .ret$table)    }    .ret})(data = dat, inits = .FoceiInits, PKpars = .pars, model = .mod,     pred = function() {        return(nlmixr_pred)    }, err = uif$error, lower = uif$focei.lower, upper = uif$focei.upper,     fixed = uif$focei.fixed, thetaNames = uif$focei.names, etaNames = uif$eta.names,     control = control, env = env, keep = .keep, drop = .drop): Not all the covariates are in the dataset.</span></div><div class='output co'>#&gt; <span class='message'>Timing stopped at: 6.93 0.367 7.293</span></div><div class='input'><span class='va'>f_nlmixr_dfop_sfo_focei_const</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/pkg/nlmixr/man/nlmixr.html'>nlmixr</a></span><span class='op'>(</span><span class='va'>f_mmkin_const</span><span class='op'>[</span><span class='st'>"DFOP-SFO"</span>, <span class='op'>]</span>, est <span class='op'>=</span> <span class='st'>"focei"</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> parameter labels from comments are typically ignored in non-interactive mode</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> Need to run with the source intact to parse comments</span></div><div class='output co'>#&gt; <span class='message'>→ creating full model...</span></div><div class='output co'>#&gt; <span class='message'>→ pruning branches (<span style='color: #262626; background-color: #DADADA;'>`if`</span>/<span style='color: #262626; background-color: #DADADA;'>`else`</span>)...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ loading into <span style='color: #0000BB;'>symengine</span> environment...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ creating full model...</span></div><div class='output co'>#&gt; <span class='message'>→ pruning branches (<span style='color: #262626; background-color: #DADADA;'>`if`</span>/<span style='color: #262626; background-color: #DADADA;'>`else`</span>)...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ loading into <span style='color: #0000BB;'>symengine</span> environment...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ calculate jacobian</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate sensitivities</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate ∂(f)/∂(η)</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate ∂(R²)/∂(η)</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in inner model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in inner model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in EBE model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in EBE model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ compiling inner model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in FD model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in FD model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ compiling EBE model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ compiling events FD model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>Model:</span></div><div class='output co'>#&gt; <span class='message'>cmt(parent);</span>
#&gt; <span class='message'>cmt(A1);</span>
#&gt; <span class='message'>rx_expr_6~ETA[1]+THETA[1];</span>
#&gt; <span class='message'>parent(0)=rx_expr_6;</span>
#&gt; <span class='message'>rx_expr_7~ETA[4]+THETA[4];</span>
#&gt; <span class='message'>rx_expr_8~ETA[6]+THETA[6];</span>
#&gt; <span class='message'>rx_expr_9~ETA[5]+THETA[5];</span>
#&gt; <span class='message'>rx_expr_12~exp(rx_expr_7);</span>
#&gt; <span class='message'>rx_expr_13~exp(rx_expr_9);</span>
#&gt; <span class='message'>rx_expr_15~t*rx_expr_12;</span>
#&gt; <span class='message'>rx_expr_16~t*rx_expr_13;</span>
#&gt; <span class='message'>rx_expr_18~exp(-(rx_expr_8));</span>
#&gt; <span class='message'>rx_expr_20~1+rx_expr_18;</span>
#&gt; <span class='message'>rx_expr_25~1/(rx_expr_20);</span>
#&gt; <span class='message'>rx_expr_27~(rx_expr_25);</span>
#&gt; <span class='message'>rx_expr_28~1-rx_expr_27;</span>
#&gt; <span class='message'>d/dt(parent)=-parent*(exp(rx_expr_7-rx_expr_15)/(rx_expr_20)+exp(rx_expr_9-rx_expr_16)*(rx_expr_28))/(exp(-t*rx_expr_12)/(rx_expr_20)+exp(-t*rx_expr_13)*(rx_expr_28));</span>
#&gt; <span class='message'>rx_expr_10~ETA[2]+THETA[2];</span>
#&gt; <span class='message'>rx_expr_14~exp(rx_expr_10);</span>
#&gt; <span class='message'>d/dt(A1)=-rx_expr_14*A1+parent*f_parent_to_A1*(exp(rx_expr_7-rx_expr_15)/(rx_expr_20)+exp(rx_expr_9-rx_expr_16)*(rx_expr_28))/(exp(-t*rx_expr_12)/(rx_expr_20)+exp(-t*rx_expr_13)*(rx_expr_28));</span>
#&gt; <span class='message'>rx_expr_0~CMT==2;</span>
#&gt; <span class='message'>rx_expr_1~CMT==1;</span>
#&gt; <span class='message'>rx_expr_2~1-(rx_expr_0);</span>
#&gt; <span class='message'>rx_yj_~2*(rx_expr_2)*(rx_expr_1)+2*(rx_expr_0);</span>
#&gt; <span class='message'>rx_expr_3~(rx_expr_0);</span>
#&gt; <span class='message'>rx_expr_5~(rx_expr_2);</span>
#&gt; <span class='message'>rx_expr_19~rx_expr_5*(rx_expr_1);</span>
#&gt; <span class='message'>rx_lambda_~rx_expr_19+rx_expr_3;</span>
#&gt; <span class='message'>rx_hi_~rx_expr_19+rx_expr_3;</span>
#&gt; <span class='message'>rx_low_~0;</span>
#&gt; <span class='message'>rx_expr_4~A1*(rx_expr_0);</span>
#&gt; <span class='message'>rx_expr_11~parent*(rx_expr_2);</span>
#&gt; <span class='message'>rx_expr_23~rx_expr_11*(rx_expr_1);</span>
#&gt; <span class='message'>rx_pred_=(rx_expr_4+rx_expr_23)*(rx_expr_0)+(rx_expr_4+rx_expr_23)*(rx_expr_2)*(rx_expr_1);</span>
#&gt; <span class='message'>rx_expr_17~Rx_pow_di(THETA[7],2);</span>
#&gt; <span class='message'>rx_r_=(rx_expr_0)*rx_expr_17+(rx_expr_2)*(rx_expr_1)*rx_expr_17;</span>
#&gt; <span class='message'>parent_0=THETA[1];</span>
#&gt; <span class='message'>log_k_A1=THETA[2];</span>
#&gt; <span class='message'>f_parent_qlogis=THETA[3];</span>
#&gt; <span class='message'>log_k1=THETA[4];</span>
#&gt; <span class='message'>log_k2=THETA[5];</span>
#&gt; <span class='message'>g_qlogis=THETA[6];</span>
#&gt; <span class='message'>sigma=THETA[7];</span>
#&gt; <span class='message'>eta.parent_0=ETA[1];</span>
#&gt; <span class='message'>eta.log_k_A1=ETA[2];</span>
#&gt; <span class='message'>eta.f_parent_qlogis=ETA[3];</span>
#&gt; <span class='message'>eta.log_k1=ETA[4];</span>
#&gt; <span class='message'>eta.log_k2=ETA[5];</span>
#&gt; <span class='message'>eta.g_qlogis=ETA[6];</span>
#&gt; <span class='message'>parent_0_model=rx_expr_6;</span>
#&gt; <span class='message'>k_A1=rx_expr_14;</span>
#&gt; <span class='message'>k1=rx_expr_12;</span>
#&gt; <span class='message'>k2=rx_expr_13;</span>
#&gt; <span class='message'>f_parent=1/(1+exp(-(ETA[3]+THETA[3])));</span>
#&gt; <span class='message'>g=1/(rx_expr_20);</span>
#&gt; <span class='message'>tad=tad();</span>
#&gt; <span class='message'>dosenum=dosenum();</span></div><div class='output co'>#&gt; <span class='message'>Needed Covariates:</span></div><div class='output co'>#&gt; <span class='message'>[1] "f_parent_to_A1" "CMT"           </span></div><div class='output co'>#&gt; <span class='error'>Error in (function (data, inits, PKpars, model = NULL, pred = NULL, err = NULL,     lower = -Inf, upper = Inf, fixed = NULL, skipCov = NULL,     control = foceiControl(), thetaNames = NULL, etaNames = NULL,     etaMat = NULL, ..., env = NULL, keep = NULL, drop = NULL) {    set.seed(control$seed)    .pt &lt;- proc.time()    RxODE::.setWarnIdSort(FALSE)    on.exit(RxODE::.setWarnIdSort(TRUE))    loadNamespace("n1qn1")    if (!RxODE::rxIs(control, "foceiControl")) {        control &lt;- do.call(foceiControl, control)    }    if (is.null(env)) {        .ret &lt;- new.env(parent = emptyenv())    }    else {        .ret &lt;- env    }    .ret$origData &lt;- data    .ret$etaNames &lt;- etaNames    .ret$thetaFixed &lt;- fixed    .ret$control &lt;- control    .ret$control$focei.mu.ref &lt;- integer(0)    if (is(model, "RxODE") || is(model, "character")) {        .ret$ODEmodel &lt;- TRUE        if (class(pred) != "function") {            stop("pred must be a function specifying the prediction variables in this model.")        }    }    else {        .ret$ODEmodel &lt;- TRUE        model &lt;- RxODE::rxGetLin(PKpars)        pred &lt;- eval(parse(text = "function(){return(Central);}"))    }    .square &lt;- function(x) x * x    .ret$diagXformInv &lt;- c(sqrt = ".square", log = "exp", identity = "identity")[control$diagXform]    if (is.null(err)) {        err &lt;- eval(parse(text = paste0("function(){err", paste(inits$ERROR[[1]],             collapse = ""), "}")))    }    .covNames &lt;- .parNames &lt;- c()    .ret$adjLik &lt;- control$adjLik    .mixed &lt;- !is.null(inits$OMGA) &amp;&amp; length(inits$OMGA) &gt; 0    if (!exists("noLik", envir = .ret)) {        .atol &lt;- rep(control$atol, length(RxODE::rxModelVars(model)$state))        .rtol &lt;- rep(control$rtol, length(RxODE::rxModelVars(model)$state))        .ssAtol &lt;- rep(control$ssAtol, length(RxODE::rxModelVars(model)$state))        .ssRtol &lt;- rep(control$ssRtol, length(RxODE::rxModelVars(model)$state))        .ret$model &lt;- RxODE::rxSymPySetupPred(model, pred, PKpars,             err, grad = (control$derivMethod == 2L), pred.minus.dv = TRUE,             sum.prod = control$sumProd, theta.derivs = FALSE,             optExpression = control$optExpression, interaction = (control$interaction ==                 1L), only.numeric = !.mixed, run.internal = TRUE,             addProp = control$addProp)        if (!is.null(.ret$model$inner)) {            .atol &lt;- c(.atol, rep(control$atolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                 length(.atol)))            .rtol &lt;- c(.rtol, rep(control$rtolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                 length(.rtol)))            .ret$control$rxControl$atol &lt;- .atol            .ret$control$rxControl$rtol &lt;- .rtol            .ssAtol &lt;- c(.ssAtol, rep(control$ssAtolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                 length(.ssAtol)))            .ssRtol &lt;- c(.ssRtol, rep(control$ssRtolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                 length(.ssRtol)))            .ret$control$rxControl$ssAtol &lt;- .ssAtol            .ret$control$rxControl$ssRtol &lt;- .ssRtol        }        .covNames &lt;- .parNames &lt;- RxODE::rxParams(.ret$model$pred.only)        .covNames &lt;- .covNames[regexpr(rex::rex(start, or("THETA",             "ETA"), "[", numbers, "]", end), .covNames) == -1]        colnames(data) &lt;- sapply(names(data), function(x) {            if (any(x == .covNames)) {                return(x)            }            else {                return(toupper(x))            }        })        .lhs &lt;- c(names(RxODE::rxInits(.ret$model$pred.only)),             RxODE::rxLhs(.ret$model$pred.only))        if (length(.lhs) &gt; 0) {            .covNames &lt;- .covNames[regexpr(rex::rex(start, or(.lhs),                 end), .covNames) == -1]        }        if (length(.covNames) &gt; 0) {            if (!all(.covNames %in% names(data))) {                message("Model:")                RxODE::rxCat(.ret$model$pred.only)                message("Needed Covariates:")                nlmixrPrint(.covNames)                stop("Not all the covariates are in the dataset.")            }            message("Needed Covariates:")            print(.covNames)        }        .extraPars &lt;- .ret$model$extra.pars    }    else {        if (.ret$noLik) {            .atol &lt;- rep(control$atol, length(RxODE::rxModelVars(model)$state))            .rtol &lt;- rep(control$rtol, length(RxODE::rxModelVars(model)$state))            .ret$model &lt;- RxODE::rxSymPySetupPred(model, pred,                 PKpars, err, grad = FALSE, pred.minus.dv = TRUE,                 sum.prod = control$sumProd, theta.derivs = FALSE,                 optExpression = control$optExpression, run.internal = TRUE,                 only.numeric = TRUE, addProp = control$addProp)            if (!is.null(.ret$model$inner)) {                .atol &lt;- c(.atol, rep(control$atolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                   length(.atol)))                .rtol &lt;- c(.rtol, rep(control$rtolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                   length(.rtol)))                .ret$control$rxControl$atol &lt;- .atol                .ret$control$rxControl$rtol &lt;- .rtol            }            .covNames &lt;- .parNames &lt;- RxODE::rxParams(.ret$model$pred.only)            .covNames &lt;- .covNames[regexpr(rex::rex(start, or("THETA",                 "ETA"), "[", numbers, "]", end), .covNames) ==                 -1]            colnames(data) &lt;- sapply(names(data), function(x) {                if (any(x == .covNames)) {                  return(x)                }                else {                  return(toupper(x))                }            })            .lhs &lt;- c(names(RxODE::rxInits(.ret$model$pred.only)),                 RxODE::rxLhs(.ret$model$pred.only))            if (length(.lhs) &gt; 0) {                .covNames &lt;- .covNames[regexpr(rex::rex(start,                   or(.lhs), end), .covNames) == -1]            }            if (length(.covNames) &gt; 0) {                if (!all(.covNames %in% names(data))) {                  message("Model:")                  RxODE::rxCat(.ret$model$pred.only)                  message("Needed Covariates:")                  nlmixrPrint(.covNames)                  stop("Not all the covariates are in the dataset.")                }                message("Needed Covariates:")                print(.covNames)            }            .extraPars &lt;- .ret$model$extra.pars        }        else {            .extraPars &lt;- NULL        }    }    .ret$skipCov &lt;- skipCov    if (is.null(skipCov)) {        if (is.null(fixed)) {            .tmp &lt;- rep(FALSE, length(inits$THTA))        }        else {            if (length(fixed) &lt; length(inits$THTA)) {                .tmp &lt;- c(fixed, rep(FALSE, length(inits$THTA) -                   length(fixed)))            }            else {                .tmp &lt;- fixed[1:length(inits$THTA)]            }        }        if (exists("uif", envir = .ret)) {            .uifErr &lt;- .ret$uif$ini$err[!is.na(.ret$uif$ini$ntheta)]            .uifErr &lt;- sapply(.uifErr, function(x) {                if (is.na(x)) {                  return(FALSE)                }                return(!any(x == c("pow2", "tbs", "tbsYj")))            })            .tmp &lt;- (.tmp | .uifErr)        }        .ret$skipCov &lt;- c(.tmp, rep(TRUE, length(.extraPars)))        .ret$control$focei.mu.ref &lt;- .ret$uif$focei.mu.ref    }    if (is.null(.extraPars)) {        .nms &lt;- c(sprintf("THETA[%s]", seq_along(inits$THTA)))    }    else {        .nms &lt;- c(sprintf("THETA[%s]", seq_along(inits$THTA)),             sprintf("ERR[%s]", seq_along(.extraPars)))    }    if (!is.null(thetaNames) &amp;&amp; (length(inits$THTA) + length(.extraPars)) ==         length(thetaNames)) {        .nms &lt;- thetaNames    }    .ret$thetaNames &lt;- .nms    .thetaReset$thetaNames &lt;- .nms    if (length(lower) == 1) {        lower &lt;- rep(lower, length(inits$THTA))    }    else if (length(lower) != length(inits$THTA)) {        print(inits$THTA)        print(lower)        stop("Lower must be a single constant for all the THETA lower bounds, or match the dimension of THETA.")    }    if (length(upper) == 1) {        upper &lt;- rep(upper, length(inits$THTA))    }    else if (length(lower) != length(inits$THTA)) {        stop("Upper must be a single constant for all the THETA lower bounds, or match the dimension of THETA.")    }    if (!is.null(.extraPars)) {        .ret$model$extra.pars &lt;- eval(call(control$diagXform,             .ret$model$extra.pars))        if (length(.ret$model$extra.pars) &gt; 0) {            inits$THTA &lt;- c(inits$THTA, .ret$model$extra.pars)            .lowerErr &lt;- rep(control$atol[1] * 10, length(.ret$model$extra.pars))            .upperErr &lt;- rep(Inf, length(.ret$model$extra.pars))            lower &lt;- c(lower, .lowerErr)            upper &lt;- c(upper, .upperErr)        }    }    if (is.null(data$ID))         stop("\"ID\" not found in data")    if (is.null(data$DV))         stop("\"DV\" not found in data")    if (is.null(data$EVID))         data$EVID &lt;- 0    if (is.null(data$AMT))         data$AMT &lt;- 0    for (.v in c("TIME", "AMT", "DV", .covNames)) {        data[[.v]] &lt;- as.double(data[[.v]])    }    .ret$dataSav &lt;- data    .ds &lt;- data[data$EVID != 0 &amp; data$EVID != 2, c("ID", "TIME",         "AMT", "EVID", .covNames)]    .w &lt;- which(tolower(names(data)) == "limit")    .limitName &lt;- NULL    if (length(.w) == 1L) {        .limitName &lt;- names(data)[.w]    }    .censName &lt;- NULL    .w &lt;- which(tolower(names(data)) == "cens")    if (length(.w) == 1L) {        .censName &lt;- names(data[.w])    }    data &lt;- data[data$EVID == 0 | data$EVID == 2, c("ID", "TIME",         "DV", "EVID", .covNames, .limitName, .censName)]    .w &lt;- which(!(names(.ret$dataSav) %in% c(.covNames, keep)))    names(.ret$dataSav)[.w] &lt;- tolower(names(.ret$dataSav[.w]))    if (.mixed) {        .lh &lt;- .parseOM(inits$OMGA)        .nlh &lt;- sapply(.lh, length)        .osplt &lt;- rep(1:length(.lh), .nlh)        .lini &lt;- list(inits$THTA, unlist(.lh))        .nlini &lt;- sapply(.lini, length)        .nsplt &lt;- rep(1:length(.lini), .nlini)        .om0 &lt;- .genOM(.lh)        if (length(etaNames) == dim(.om0)[1]) {            .ret$etaNames &lt;- .ret$etaNames        }        else {            .ret$etaNames &lt;- sprintf("ETA[%d]", seq(1, dim(.om0)[1]))        }        .ret$rxInv &lt;- RxODE::rxSymInvCholCreate(mat = .om0, diag.xform = control$diagXform)        .ret$xType &lt;- .ret$rxInv$xType        .om0a &lt;- .om0        .om0a &lt;- .om0a/control$diagOmegaBoundLower        .om0b &lt;- .om0        .om0b &lt;- .om0b * control$diagOmegaBoundUpper        .om0a &lt;- RxODE::rxSymInvCholCreate(mat = .om0a, diag.xform = control$diagXform)        .om0b &lt;- RxODE::rxSymInvCholCreate(mat = .om0b, diag.xform = control$diagXform)        .omdf &lt;- data.frame(a = .om0a$theta, m = .ret$rxInv$theta,             b = .om0b$theta, diag = .om0a$theta.diag)        .omdf$lower &lt;- with(.omdf, ifelse(a &gt; b, b, a))        .omdf$lower &lt;- with(.omdf, ifelse(lower == m, -Inf, lower))        .omdf$lower &lt;- with(.omdf, ifelse(!diag, -Inf, lower))        .omdf$upper &lt;- with(.omdf, ifelse(a &lt; b, b, a))        .omdf$upper &lt;- with(.omdf, ifelse(upper == m, Inf, upper))        .omdf$upper &lt;- with(.omdf, ifelse(!diag, Inf, upper))        .ret$control$nomega &lt;- length(.omdf$lower)        .ret$control$neta &lt;- sum(.omdf$diag)        .ret$control$ntheta &lt;- length(lower)        .ret$control$nfixed &lt;- sum(fixed)        lower &lt;- c(lower, .omdf$lower)        upper &lt;- c(upper, .omdf$upper)    }    else {        .ret$control$nomega &lt;- 0        .ret$control$neta &lt;- 0        .ret$xType &lt;- -1        .ret$control$ntheta &lt;- length(lower)        .ret$control$nfixed &lt;- sum(fixed)    }    .ret$lower &lt;- lower    .ret$upper &lt;- upper    .ret$thetaIni &lt;- inits$THTA    .scaleC &lt;- double(length(lower))    if (is.null(control$scaleC)) {        .scaleC &lt;- rep(NA_real_, length(lower))    }    else {        .scaleC &lt;- as.double(control$scaleC)        if (length(lower) &gt; length(.scaleC)) {            .scaleC &lt;- c(.scaleC, rep(NA_real_, length(lower) -                 length(.scaleC)))        }        else if (length(lower) &lt; length(.scaleC)) {            .scaleC &lt;- .scaleC[seq(1, length(lower))]            warning("scaleC control option has more options than estimated population parameters, please check.")        }    }    .ret$scaleC &lt;- .scaleC    if (exists("uif", envir = .ret)) {        .ini &lt;- as.data.frame(.ret$uif$ini)[!is.na(.ret$uif$ini$err),             c("est", "err", "ntheta")]        for (.i in seq_along(.ini$err)) {            if (is.na(.ret$scaleC[.ini$ntheta[.i]])) {                if (any(.ini$err[.i] == c("boxCox", "yeoJohnson",                   "pow2", "tbs", "tbsYj"))) {                  .ret$scaleC[.ini$ntheta[.i]] &lt;- 1                }                else if (any(.ini$err[.i] == c("prop", "add",                   "norm", "dnorm", "logn", "dlogn", "lnorm",                   "dlnorm"))) {                  .ret$scaleC[.ini$ntheta[.i]] &lt;- 0.5 * abs(.ini$est[.i])                }            }        }        for (.i in .ini$model$extraProps$powTheta) {            if (is.na(.ret$scaleC[.i]))                 .ret$scaleC[.i] &lt;- 1        }        .ini &lt;- as.data.frame(.ret$uif$ini)        for (.i in .ini$model$extraProps$factorial) {            if (is.na(.ret$scaleC[.i]))                 .ret$scaleC[.i] &lt;- abs(1/digamma(.ini$est[.i] +                   1))        }        for (.i in .ini$model$extraProps$gamma) {            if (is.na(.ret$scaleC[.i]))                 .ret$scaleC[.i] &lt;- abs(1/digamma(.ini$est[.i]))        }        for (.i in .ini$model$extraProps$log) {            if (is.na(.ret$scaleC[.i]))                 .ret$scaleC[.i] &lt;- log(abs(.ini$est[.i])) * abs(.ini$est[.i])        }        for (.i in .ret$logitThetas) {            .b &lt;- .ret$logitThetasLow[.i]            .c &lt;- .ret$logitThetasHi[.i]            .a &lt;- .ini$est[.i]            if (is.na(.ret$scaleC[.i])) {                .ret$scaleC[.i] &lt;- 1 * (-.b + .c) * exp(-.a)/((1 +                   exp(-.a))^2 * (.b + 1 * (-.b + .c)/(1 + exp(-.a))))            }        }    }    names(.ret$thetaIni) &lt;- sprintf("THETA[%d]", seq_along(.ret$thetaIni))    if (is.null(etaMat) &amp; !is.null(control$etaMat)) {        .ret$etaMat &lt;- control$etaMat    }    else {        .ret$etaMat &lt;- etaMat    }    .ret$setupTime &lt;- (proc.time() - .pt)["elapsed"]    if (exists("uif", envir = .ret)) {        .tmp &lt;- .ret$uif$logThetasList        .ret$logThetas &lt;- .tmp[[1]]        .ret$logThetasF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$logitThetasList        .ret$logitThetas &lt;- .tmp[[1]]        .ret$logitThetasF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$logitThetasListLow        .ret$logitThetasLow &lt;- .tmp[[1]]        .ret$logitThetasLowF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$logitThetasListHi        .ret$logitThetasHi &lt;- .tmp[[1]]        .ret$logitThetasHiF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$probitThetasList        .ret$probitThetas &lt;- .tmp[[1]]        .ret$probitThetasF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$probitThetasListLow        .ret$probitThetasLow &lt;- .tmp[[1]]        .ret$probitThetasLowF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$probitThetasListHi        .ret$probitThetasHi &lt;- .tmp[[1]]        .ret$probitThetasHiF &lt;- .tmp[[2]]    }    else {        .ret$logThetasF &lt;- integer(0)        .ret$logitThetasF &lt;- integer(0)        .ret$logitThetasHiF &lt;- numeric(0)        .ret$logitThetasLowF &lt;- numeric(0)        .ret$logitThetas &lt;- integer(0)        .ret$logitThetasHi &lt;- numeric(0)        .ret$logitThetasLow &lt;- numeric(0)        .ret$probitThetasF &lt;- integer(0)        .ret$probitThetasHiF &lt;- numeric(0)        .ret$probitThetasLowF &lt;- numeric(0)        .ret$probitThetas &lt;- integer(0)        .ret$probitThetasHi &lt;- numeric(0)        .ret$probitThetasLow &lt;- numeric(0)    }    if (exists("noLik", envir = .ret)) {        if (!.ret$noLik) {            .ret$.params &lt;- c(sprintf("THETA[%d]", seq_along(.ret$thetaIni)),                 sprintf("ETA[%d]", seq(1, dim(.om0)[1])))            .ret$.thetan &lt;- length(.ret$thetaIni)            .ret$nobs &lt;- sum(data$EVID == 0)        }    }    .ret$control$printTop &lt;- TRUE    .ret$control$nF &lt;- 0    .est0 &lt;- .ret$thetaIni    if (!is.null(.ret$model$pred.nolhs)) {        .ret$control$predNeq &lt;- length(.ret$model$pred.nolhs$state)    }    else {        .ret$control$predNeq &lt;- 0L    }    .fitFun &lt;- function(.ret) {        this.env &lt;- environment()        assign("err", "theta reset", this.env)        while (this.env$err == "theta reset") {            assign("err", "", this.env)            .ret0 &lt;- tryCatch({                foceiFitCpp_(.ret)            }, error = function(e) {                if (regexpr("theta reset", e$message) != -1) {                  assign("zeroOuter", FALSE, this.env)                  assign("zeroGrad", FALSE, this.env)                  if (regexpr("theta reset0", e$message) != -1) {                    assign("zeroGrad", TRUE, this.env)                  }                  else if (regexpr("theta resetZ", e$message) !=                     -1) {                    assign("zeroOuter", TRUE, this.env)                  }                  assign("err", "theta reset", this.env)                }                else {                  assign("err", e$message, this.env)                }            })            if (this.env$err == "theta reset") {                .nm &lt;- names(.ret$thetaIni)                .ret$thetaIni &lt;- setNames(.thetaReset$thetaIni +                   0, .nm)                .ret$rxInv$theta &lt;- .thetaReset$omegaTheta                .ret$control$printTop &lt;- FALSE                .ret$etaMat &lt;- .thetaReset$etaMat                .ret$control$etaMat &lt;- .thetaReset$etaMat                .ret$control$maxInnerIterations &lt;- .thetaReset$maxInnerIterations                .ret$control$nF &lt;- .thetaReset$nF                .ret$control$gillRetC &lt;- .thetaReset$gillRetC                .ret$control$gillRet &lt;- .thetaReset$gillRet                .ret$control$gillRet &lt;- .thetaReset$gillRet                .ret$control$gillDf &lt;- .thetaReset$gillDf                .ret$control$gillDf2 &lt;- .thetaReset$gillDf2                .ret$control$gillErr &lt;- .thetaReset$gillErr                .ret$control$rEps &lt;- .thetaReset$rEps                .ret$control$aEps &lt;- .thetaReset$aEps                .ret$control$rEpsC &lt;- .thetaReset$rEpsC                .ret$control$aEpsC &lt;- .thetaReset$aEpsC                .ret$control$c1 &lt;- .thetaReset$c1                .ret$control$c2 &lt;- .thetaReset$c2                if (this.env$zeroOuter) {                  message("Posthoc reset")                  .ret$control$maxOuterIterations &lt;- 0L                }                else if (this.env$zeroGrad) {                  message("Theta reset (zero gradient values); Switch to bobyqa")                  RxODE::rxReq("minqa")                  .ret$control$outerOptFun &lt;- .bobyqa                  .ret$control$outerOpt &lt;- -1L                }                else {                  message("Theta reset (ETA drift)")                }            }        }        if (this.env$err != "") {            stop(this.env$err)        }        else {            return(.ret0)        }    }    .ret0 &lt;- try(.fitFun(.ret))    .n &lt;- 1    while (inherits(.ret0, "try-error") &amp;&amp; control$maxOuterIterations !=         0 &amp;&amp; .n &lt;= control$nRetries) {        message(sprintf("Restart %s", .n))        .ret$control$nF &lt;- 0        .estNew &lt;- .est0 + 0.2 * .n * abs(.est0) * stats::runif(length(.est0)) -             0.1 * .n        .estNew &lt;- sapply(seq_along(.est0), function(.i) {            if (.ret$thetaFixed[.i]) {                return(.est0[.i])            }            else if (.estNew[.i] &lt; lower[.i]) {                return(lower + (.Machine$double.eps)^(1/7))            }            else if (.estNew[.i] &gt; upper[.i]) {                return(upper - (.Machine$double.eps)^(1/7))            }            else {                return(.estNew[.i])            }        })        .ret$thetaIni &lt;- .estNew        .ret0 &lt;- try(.fitFun(.ret))        .n &lt;- .n + 1    }    if (inherits(.ret0, "try-error"))         stop("Could not fit data.")    .ret &lt;- .ret0    if (exists("parHistData", .ret)) {        .tmp &lt;- .ret$parHistData        .tmp &lt;- .tmp[.tmp$type == "Unscaled", names(.tmp) !=             "type"]        .iter &lt;- .tmp$iter        .tmp &lt;- .tmp[, names(.tmp) != "iter"]        .ret$parHistStacked &lt;- data.frame(stack(.tmp), iter = .iter)        names(.ret$parHistStacked) &lt;- c("val", "par", "iter")        .ret$parHist &lt;- data.frame(iter = .iter, .tmp)    }    if (.mixed) {        .etas &lt;- .ret$ranef        .thetas &lt;- .ret$fixef        .pars &lt;- .Call(`_nlmixr_nlmixrParameters`, .thetas, .etas)        .ret$shrink &lt;- .Call(`_nlmixr_calcShrinkOnly`, .ret$omega,             .pars$eta.lst, length(.etas$ID))        .updateParFixed(.ret)    }    else {        .updateParFixed(.ret)    }    if (!exists("table", .ret)) {        .ret$table &lt;- tableControl()    }    if (control$calcTables) {        .ret &lt;- addTable(.ret, updateObject = "no", keep = keep,             drop = drop, table = .ret$table)    }    .ret})(data = dat, inits = .FoceiInits, PKpars = .pars, model = .mod,     pred = function() {        return(nlmixr_pred)    }, err = uif$error, lower = uif$focei.lower, upper = uif$focei.upper,     fixed = uif$focei.fixed, thetaNames = uif$focei.names, etaNames = uif$eta.names,     control = control, env = env, keep = .keep, drop = .drop): Not all the covariates are in the dataset.</span></div><div class='output co'>#&gt; <span class='message'>Timing stopped at: 15.39 1.223 16.61</span></div><div class='input'>
<span class='co'># Variance by variable is supported by 'saem' and 'focei'</span>
<span class='va'>f_nlmixr_fomc_sfo_saem_obs</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/pkg/nlmixr/man/nlmixr.html'>nlmixr</a></span><span class='op'>(</span><span class='va'>f_mmkin_obs</span><span class='op'>[</span><span class='st'>"FOMC-SFO"</span>, <span class='op'>]</span>, est <span class='op'>=</span> <span class='st'>"saem"</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> parameter labels from comments are typically ignored in non-interactive mode</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> Need to run with the source intact to parse comments</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'>→ generate SAEM model</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='error'>Error in configsaem(model = model, data = dat, inits = inits, mcmc = .mcmc,     ODEopt = .ODEopt, seed = .seed, distribution = .dist, DEBUG = .DEBUG,     addProp = .addProp, tol = .tol, itmax = .itmax, type = .type,     powRange = .powRange, lambdaRange = .lambdaRange): covariate(s) not found: f_parent_to_A1</span></div><div class='output co'>#&gt; <span class='message'>Timing stopped at: 1.288 0.09 1.379</span></div><div class='input'><span class='va'>f_nlmixr_fomc_sfo_focei_obs</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/pkg/nlmixr/man/nlmixr.html'>nlmixr</a></span><span class='op'>(</span><span class='va'>f_mmkin_obs</span><span class='op'>[</span><span class='st'>"FOMC-SFO"</span>, <span class='op'>]</span>, est <span class='op'>=</span> <span class='st'>"focei"</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> parameter labels from comments are typically ignored in non-interactive mode</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> Need to run with the source intact to parse comments</span></div><div class='output co'>#&gt; <span class='message'>→ creating full model...</span></div><div class='output co'>#&gt; <span class='message'>→ pruning branches (<span style='color: #262626; background-color: #DADADA;'>`if`</span>/<span style='color: #262626; background-color: #DADADA;'>`else`</span>)...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ loading into <span style='color: #0000BB;'>symengine</span> environment...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ creating full model...</span></div><div class='output co'>#&gt; <span class='message'>→ pruning branches (<span style='color: #262626; background-color: #DADADA;'>`if`</span>/<span style='color: #262626; background-color: #DADADA;'>`else`</span>)...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ loading into <span style='color: #0000BB;'>symengine</span> environment...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ calculate jacobian</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate sensitivities</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate ∂(f)/∂(η)</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate ∂(R²)/∂(η)</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in inner model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in inner model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in EBE model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in EBE model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ compiling inner model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in FD model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in FD model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ compiling EBE model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ compiling events FD model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>Model:</span></div><div class='output co'>#&gt; <span class='message'>cmt(parent);</span>
#&gt; <span class='message'>cmt(A1);</span>
#&gt; <span class='message'>rx_expr_6~ETA[1]+THETA[1];</span>
#&gt; <span class='message'>parent(0)=rx_expr_6;</span>
#&gt; <span class='message'>rx_expr_7~ETA[4]+THETA[4];</span>
#&gt; <span class='message'>rx_expr_8~ETA[5]+THETA[5];</span>
#&gt; <span class='message'>rx_expr_12~exp(-(rx_expr_8));</span>
#&gt; <span class='message'>rx_expr_14~t*rx_expr_12;</span>
#&gt; <span class='message'>rx_expr_15~1+rx_expr_14;</span>
#&gt; <span class='message'>rx_expr_17~rx_expr_7-(rx_expr_8);</span>
#&gt; <span class='message'>rx_expr_19~exp(rx_expr_17);</span>
#&gt; <span class='message'>d/dt(parent)=-rx_expr_19*parent/(rx_expr_15);</span>
#&gt; <span class='message'>rx_expr_9~ETA[2]+THETA[2];</span>
#&gt; <span class='message'>rx_expr_11~exp(rx_expr_9);</span>
#&gt; <span class='message'>d/dt(A1)=-rx_expr_11*A1+rx_expr_19*parent*f_parent_to_A1/(rx_expr_15);</span>
#&gt; <span class='message'>rx_expr_0~CMT==2;</span>
#&gt; <span class='message'>rx_expr_1~CMT==1;</span>
#&gt; <span class='message'>rx_expr_2~1-(rx_expr_0);</span>
#&gt; <span class='message'>rx_yj_~2*(rx_expr_2)*(rx_expr_1)+2*(rx_expr_0);</span>
#&gt; <span class='message'>rx_expr_3~(rx_expr_0);</span>
#&gt; <span class='message'>rx_expr_5~(rx_expr_2);</span>
#&gt; <span class='message'>rx_expr_13~rx_expr_5*(rx_expr_1);</span>
#&gt; <span class='message'>rx_lambda_~rx_expr_13+rx_expr_3;</span>
#&gt; <span class='message'>rx_hi_~rx_expr_13+rx_expr_3;</span>
#&gt; <span class='message'>rx_low_~0;</span>
#&gt; <span class='message'>rx_expr_4~A1*(rx_expr_0);</span>
#&gt; <span class='message'>rx_expr_10~parent*(rx_expr_2);</span>
#&gt; <span class='message'>rx_expr_16~rx_expr_10*(rx_expr_1);</span>
#&gt; <span class='message'>rx_pred_=(rx_expr_4+rx_expr_16)*(rx_expr_0)+(rx_expr_4+rx_expr_16)*(rx_expr_2)*(rx_expr_1);</span>
#&gt; <span class='message'>rx_r_=(rx_expr_0)*Rx_pow_di(THETA[7],2)+(rx_expr_2)*(rx_expr_1)*Rx_pow_di(THETA[6],2);</span>
#&gt; <span class='message'>parent_0=THETA[1];</span>
#&gt; <span class='message'>log_k_A1=THETA[2];</span>
#&gt; <span class='message'>f_parent_qlogis=THETA[3];</span>
#&gt; <span class='message'>log_alpha=THETA[4];</span>
#&gt; <span class='message'>log_beta=THETA[5];</span>
#&gt; <span class='message'>sigma_parent=THETA[6];</span>
#&gt; <span class='message'>sigma_A1=THETA[7];</span>
#&gt; <span class='message'>eta.parent_0=ETA[1];</span>
#&gt; <span class='message'>eta.log_k_A1=ETA[2];</span>
#&gt; <span class='message'>eta.f_parent_qlogis=ETA[3];</span>
#&gt; <span class='message'>eta.log_alpha=ETA[4];</span>
#&gt; <span class='message'>eta.log_beta=ETA[5];</span>
#&gt; <span class='message'>parent_0_model=rx_expr_6;</span>
#&gt; <span class='message'>k_A1=rx_expr_11;</span>
#&gt; <span class='message'>alpha=exp(rx_expr_7);</span>
#&gt; <span class='message'>beta=exp(rx_expr_8);</span>
#&gt; <span class='message'>f_parent=1/(1+exp(-(ETA[3]+THETA[3])));</span>
#&gt; <span class='message'>tad=tad();</span>
#&gt; <span class='message'>dosenum=dosenum();</span></div><div class='output co'>#&gt; <span class='message'>Needed Covariates:</span></div><div class='output co'>#&gt; <span class='message'>[1] "f_parent_to_A1" "CMT"           </span></div><div class='output co'>#&gt; <span class='error'>Error in (function (data, inits, PKpars, model = NULL, pred = NULL, err = NULL,     lower = -Inf, upper = Inf, fixed = NULL, skipCov = NULL,     control = foceiControl(), thetaNames = NULL, etaNames = NULL,     etaMat = NULL, ..., env = NULL, keep = NULL, drop = NULL) {    set.seed(control$seed)    .pt &lt;- proc.time()    RxODE::.setWarnIdSort(FALSE)    on.exit(RxODE::.setWarnIdSort(TRUE))    loadNamespace("n1qn1")    if (!RxODE::rxIs(control, "foceiControl")) {        control &lt;- do.call(foceiControl, control)    }    if (is.null(env)) {        .ret &lt;- new.env(parent = emptyenv())    }    else {        .ret &lt;- env    }    .ret$origData &lt;- data    .ret$etaNames &lt;- etaNames    .ret$thetaFixed &lt;- fixed    .ret$control &lt;- control    .ret$control$focei.mu.ref &lt;- integer(0)    if (is(model, "RxODE") || is(model, "character")) {        .ret$ODEmodel &lt;- TRUE        if (class(pred) != "function") {            stop("pred must be a function specifying the prediction variables in this model.")        }    }    else {        .ret$ODEmodel &lt;- TRUE        model &lt;- RxODE::rxGetLin(PKpars)        pred &lt;- eval(parse(text = "function(){return(Central);}"))    }    .square &lt;- function(x) x * x    .ret$diagXformInv &lt;- c(sqrt = ".square", log = "exp", identity = "identity")[control$diagXform]    if (is.null(err)) {        err &lt;- eval(parse(text = paste0("function(){err", paste(inits$ERROR[[1]],             collapse = ""), "}")))    }    .covNames &lt;- .parNames &lt;- c()    .ret$adjLik &lt;- control$adjLik    .mixed &lt;- !is.null(inits$OMGA) &amp;&amp; length(inits$OMGA) &gt; 0    if (!exists("noLik", envir = .ret)) {        .atol &lt;- rep(control$atol, length(RxODE::rxModelVars(model)$state))        .rtol &lt;- rep(control$rtol, length(RxODE::rxModelVars(model)$state))        .ssAtol &lt;- rep(control$ssAtol, length(RxODE::rxModelVars(model)$state))        .ssRtol &lt;- rep(control$ssRtol, length(RxODE::rxModelVars(model)$state))        .ret$model &lt;- RxODE::rxSymPySetupPred(model, pred, PKpars,             err, grad = (control$derivMethod == 2L), pred.minus.dv = TRUE,             sum.prod = control$sumProd, theta.derivs = FALSE,             optExpression = control$optExpression, interaction = (control$interaction ==                 1L), only.numeric = !.mixed, run.internal = TRUE,             addProp = control$addProp)        if (!is.null(.ret$model$inner)) {            .atol &lt;- c(.atol, rep(control$atolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                 length(.atol)))            .rtol &lt;- c(.rtol, rep(control$rtolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                 length(.rtol)))            .ret$control$rxControl$atol &lt;- .atol            .ret$control$rxControl$rtol &lt;- .rtol            .ssAtol &lt;- c(.ssAtol, rep(control$ssAtolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                 length(.ssAtol)))            .ssRtol &lt;- c(.ssRtol, rep(control$ssRtolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                 length(.ssRtol)))            .ret$control$rxControl$ssAtol &lt;- .ssAtol            .ret$control$rxControl$ssRtol &lt;- .ssRtol        }        .covNames &lt;- .parNames &lt;- RxODE::rxParams(.ret$model$pred.only)        .covNames &lt;- .covNames[regexpr(rex::rex(start, or("THETA",             "ETA"), "[", numbers, "]", end), .covNames) == -1]        colnames(data) &lt;- sapply(names(data), function(x) {            if (any(x == .covNames)) {                return(x)            }            else {                return(toupper(x))            }        })        .lhs &lt;- c(names(RxODE::rxInits(.ret$model$pred.only)),             RxODE::rxLhs(.ret$model$pred.only))        if (length(.lhs) &gt; 0) {            .covNames &lt;- .covNames[regexpr(rex::rex(start, or(.lhs),                 end), .covNames) == -1]        }        if (length(.covNames) &gt; 0) {            if (!all(.covNames %in% names(data))) {                message("Model:")                RxODE::rxCat(.ret$model$pred.only)                message("Needed Covariates:")                nlmixrPrint(.covNames)                stop("Not all the covariates are in the dataset.")            }            message("Needed Covariates:")            print(.covNames)        }        .extraPars &lt;- .ret$model$extra.pars    }    else {        if (.ret$noLik) {            .atol &lt;- rep(control$atol, length(RxODE::rxModelVars(model)$state))            .rtol &lt;- rep(control$rtol, length(RxODE::rxModelVars(model)$state))            .ret$model &lt;- RxODE::rxSymPySetupPred(model, pred,                 PKpars, err, grad = FALSE, pred.minus.dv = TRUE,                 sum.prod = control$sumProd, theta.derivs = FALSE,                 optExpression = control$optExpression, run.internal = TRUE,                 only.numeric = TRUE, addProp = control$addProp)            if (!is.null(.ret$model$inner)) {                .atol &lt;- c(.atol, rep(control$atolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                   length(.atol)))                .rtol &lt;- c(.rtol, rep(control$rtolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                   length(.rtol)))                .ret$control$rxControl$atol &lt;- .atol                .ret$control$rxControl$rtol &lt;- .rtol            }            .covNames &lt;- .parNames &lt;- RxODE::rxParams(.ret$model$pred.only)            .covNames &lt;- .covNames[regexpr(rex::rex(start, or("THETA",                 "ETA"), "[", numbers, "]", end), .covNames) ==                 -1]            colnames(data) &lt;- sapply(names(data), function(x) {                if (any(x == .covNames)) {                  return(x)                }                else {                  return(toupper(x))                }            })            .lhs &lt;- c(names(RxODE::rxInits(.ret$model$pred.only)),                 RxODE::rxLhs(.ret$model$pred.only))            if (length(.lhs) &gt; 0) {                .covNames &lt;- .covNames[regexpr(rex::rex(start,                   or(.lhs), end), .covNames) == -1]            }            if (length(.covNames) &gt; 0) {                if (!all(.covNames %in% names(data))) {                  message("Model:")                  RxODE::rxCat(.ret$model$pred.only)                  message("Needed Covariates:")                  nlmixrPrint(.covNames)                  stop("Not all the covariates are in the dataset.")                }                message("Needed Covariates:")                print(.covNames)            }            .extraPars &lt;- .ret$model$extra.pars        }        else {            .extraPars &lt;- NULL        }    }    .ret$skipCov &lt;- skipCov    if (is.null(skipCov)) {        if (is.null(fixed)) {            .tmp &lt;- rep(FALSE, length(inits$THTA))        }        else {            if (length(fixed) &lt; length(inits$THTA)) {                .tmp &lt;- c(fixed, rep(FALSE, length(inits$THTA) -                   length(fixed)))            }            else {                .tmp &lt;- fixed[1:length(inits$THTA)]            }        }        if (exists("uif", envir = .ret)) {            .uifErr &lt;- .ret$uif$ini$err[!is.na(.ret$uif$ini$ntheta)]            .uifErr &lt;- sapply(.uifErr, function(x) {                if (is.na(x)) {                  return(FALSE)                }                return(!any(x == c("pow2", "tbs", "tbsYj")))            })            .tmp &lt;- (.tmp | .uifErr)        }        .ret$skipCov &lt;- c(.tmp, rep(TRUE, length(.extraPars)))        .ret$control$focei.mu.ref &lt;- .ret$uif$focei.mu.ref    }    if (is.null(.extraPars)) {        .nms &lt;- c(sprintf("THETA[%s]", seq_along(inits$THTA)))    }    else {        .nms &lt;- c(sprintf("THETA[%s]", seq_along(inits$THTA)),             sprintf("ERR[%s]", seq_along(.extraPars)))    }    if (!is.null(thetaNames) &amp;&amp; (length(inits$THTA) + length(.extraPars)) ==         length(thetaNames)) {        .nms &lt;- thetaNames    }    .ret$thetaNames &lt;- .nms    .thetaReset$thetaNames &lt;- .nms    if (length(lower) == 1) {        lower &lt;- rep(lower, length(inits$THTA))    }    else if (length(lower) != length(inits$THTA)) {        print(inits$THTA)        print(lower)        stop("Lower must be a single constant for all the THETA lower bounds, or match the dimension of THETA.")    }    if (length(upper) == 1) {        upper &lt;- rep(upper, length(inits$THTA))    }    else if (length(lower) != length(inits$THTA)) {        stop("Upper must be a single constant for all the THETA lower bounds, or match the dimension of THETA.")    }    if (!is.null(.extraPars)) {        .ret$model$extra.pars &lt;- eval(call(control$diagXform,             .ret$model$extra.pars))        if (length(.ret$model$extra.pars) &gt; 0) {            inits$THTA &lt;- c(inits$THTA, .ret$model$extra.pars)            .lowerErr &lt;- rep(control$atol[1] * 10, length(.ret$model$extra.pars))            .upperErr &lt;- rep(Inf, length(.ret$model$extra.pars))            lower &lt;- c(lower, .lowerErr)            upper &lt;- c(upper, .upperErr)        }    }    if (is.null(data$ID))         stop("\"ID\" not found in data")    if (is.null(data$DV))         stop("\"DV\" not found in data")    if (is.null(data$EVID))         data$EVID &lt;- 0    if (is.null(data$AMT))         data$AMT &lt;- 0    for (.v in c("TIME", "AMT", "DV", .covNames)) {        data[[.v]] &lt;- as.double(data[[.v]])    }    .ret$dataSav &lt;- data    .ds &lt;- data[data$EVID != 0 &amp; data$EVID != 2, c("ID", "TIME",         "AMT", "EVID", .covNames)]    .w &lt;- which(tolower(names(data)) == "limit")    .limitName &lt;- NULL    if (length(.w) == 1L) {        .limitName &lt;- names(data)[.w]    }    .censName &lt;- NULL    .w &lt;- which(tolower(names(data)) == "cens")    if (length(.w) == 1L) {        .censName &lt;- names(data[.w])    }    data &lt;- data[data$EVID == 0 | data$EVID == 2, c("ID", "TIME",         "DV", "EVID", .covNames, .limitName, .censName)]    .w &lt;- which(!(names(.ret$dataSav) %in% c(.covNames, keep)))    names(.ret$dataSav)[.w] &lt;- tolower(names(.ret$dataSav[.w]))    if (.mixed) {        .lh &lt;- .parseOM(inits$OMGA)        .nlh &lt;- sapply(.lh, length)        .osplt &lt;- rep(1:length(.lh), .nlh)        .lini &lt;- list(inits$THTA, unlist(.lh))        .nlini &lt;- sapply(.lini, length)        .nsplt &lt;- rep(1:length(.lini), .nlini)        .om0 &lt;- .genOM(.lh)        if (length(etaNames) == dim(.om0)[1]) {            .ret$etaNames &lt;- .ret$etaNames        }        else {            .ret$etaNames &lt;- sprintf("ETA[%d]", seq(1, dim(.om0)[1]))        }        .ret$rxInv &lt;- RxODE::rxSymInvCholCreate(mat = .om0, diag.xform = control$diagXform)        .ret$xType &lt;- .ret$rxInv$xType        .om0a &lt;- .om0        .om0a &lt;- .om0a/control$diagOmegaBoundLower        .om0b &lt;- .om0        .om0b &lt;- .om0b * control$diagOmegaBoundUpper        .om0a &lt;- RxODE::rxSymInvCholCreate(mat = .om0a, diag.xform = control$diagXform)        .om0b &lt;- RxODE::rxSymInvCholCreate(mat = .om0b, diag.xform = control$diagXform)        .omdf &lt;- data.frame(a = .om0a$theta, m = .ret$rxInv$theta,             b = .om0b$theta, diag = .om0a$theta.diag)        .omdf$lower &lt;- with(.omdf, ifelse(a &gt; b, b, a))        .omdf$lower &lt;- with(.omdf, ifelse(lower == m, -Inf, lower))        .omdf$lower &lt;- with(.omdf, ifelse(!diag, -Inf, lower))        .omdf$upper &lt;- with(.omdf, ifelse(a &lt; b, b, a))        .omdf$upper &lt;- with(.omdf, ifelse(upper == m, Inf, upper))        .omdf$upper &lt;- with(.omdf, ifelse(!diag, Inf, upper))        .ret$control$nomega &lt;- length(.omdf$lower)        .ret$control$neta &lt;- sum(.omdf$diag)        .ret$control$ntheta &lt;- length(lower)        .ret$control$nfixed &lt;- sum(fixed)        lower &lt;- c(lower, .omdf$lower)        upper &lt;- c(upper, .omdf$upper)    }    else {        .ret$control$nomega &lt;- 0        .ret$control$neta &lt;- 0        .ret$xType &lt;- -1        .ret$control$ntheta &lt;- length(lower)        .ret$control$nfixed &lt;- sum(fixed)    }    .ret$lower &lt;- lower    .ret$upper &lt;- upper    .ret$thetaIni &lt;- inits$THTA    .scaleC &lt;- double(length(lower))    if (is.null(control$scaleC)) {        .scaleC &lt;- rep(NA_real_, length(lower))    }    else {        .scaleC &lt;- as.double(control$scaleC)        if (length(lower) &gt; length(.scaleC)) {            .scaleC &lt;- c(.scaleC, rep(NA_real_, length(lower) -                 length(.scaleC)))        }        else if (length(lower) &lt; length(.scaleC)) {            .scaleC &lt;- .scaleC[seq(1, length(lower))]            warning("scaleC control option has more options than estimated population parameters, please check.")        }    }    .ret$scaleC &lt;- .scaleC    if (exists("uif", envir = .ret)) {        .ini &lt;- as.data.frame(.ret$uif$ini)[!is.na(.ret$uif$ini$err),             c("est", "err", "ntheta")]        for (.i in seq_along(.ini$err)) {            if (is.na(.ret$scaleC[.ini$ntheta[.i]])) {                if (any(.ini$err[.i] == c("boxCox", "yeoJohnson",                   "pow2", "tbs", "tbsYj"))) {                  .ret$scaleC[.ini$ntheta[.i]] &lt;- 1                }                else if (any(.ini$err[.i] == c("prop", "add",                   "norm", "dnorm", "logn", "dlogn", "lnorm",                   "dlnorm"))) {                  .ret$scaleC[.ini$ntheta[.i]] &lt;- 0.5 * abs(.ini$est[.i])                }            }        }        for (.i in .ini$model$extraProps$powTheta) {            if (is.na(.ret$scaleC[.i]))                 .ret$scaleC[.i] &lt;- 1        }        .ini &lt;- as.data.frame(.ret$uif$ini)        for (.i in .ini$model$extraProps$factorial) {            if (is.na(.ret$scaleC[.i]))                 .ret$scaleC[.i] &lt;- abs(1/digamma(.ini$est[.i] +                   1))        }        for (.i in .ini$model$extraProps$gamma) {            if (is.na(.ret$scaleC[.i]))                 .ret$scaleC[.i] &lt;- abs(1/digamma(.ini$est[.i]))        }        for (.i in .ini$model$extraProps$log) {            if (is.na(.ret$scaleC[.i]))                 .ret$scaleC[.i] &lt;- log(abs(.ini$est[.i])) * abs(.ini$est[.i])        }        for (.i in .ret$logitThetas) {            .b &lt;- .ret$logitThetasLow[.i]            .c &lt;- .ret$logitThetasHi[.i]            .a &lt;- .ini$est[.i]            if (is.na(.ret$scaleC[.i])) {                .ret$scaleC[.i] &lt;- 1 * (-.b + .c) * exp(-.a)/((1 +                   exp(-.a))^2 * (.b + 1 * (-.b + .c)/(1 + exp(-.a))))            }        }    }    names(.ret$thetaIni) &lt;- sprintf("THETA[%d]", seq_along(.ret$thetaIni))    if (is.null(etaMat) &amp; !is.null(control$etaMat)) {        .ret$etaMat &lt;- control$etaMat    }    else {        .ret$etaMat &lt;- etaMat    }    .ret$setupTime &lt;- (proc.time() - .pt)["elapsed"]    if (exists("uif", envir = .ret)) {        .tmp &lt;- .ret$uif$logThetasList        .ret$logThetas &lt;- .tmp[[1]]        .ret$logThetasF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$logitThetasList        .ret$logitThetas &lt;- .tmp[[1]]        .ret$logitThetasF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$logitThetasListLow        .ret$logitThetasLow &lt;- .tmp[[1]]        .ret$logitThetasLowF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$logitThetasListHi        .ret$logitThetasHi &lt;- .tmp[[1]]        .ret$logitThetasHiF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$probitThetasList        .ret$probitThetas &lt;- .tmp[[1]]        .ret$probitThetasF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$probitThetasListLow        .ret$probitThetasLow &lt;- .tmp[[1]]        .ret$probitThetasLowF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$probitThetasListHi        .ret$probitThetasHi &lt;- .tmp[[1]]        .ret$probitThetasHiF &lt;- .tmp[[2]]    }    else {        .ret$logThetasF &lt;- integer(0)        .ret$logitThetasF &lt;- integer(0)        .ret$logitThetasHiF &lt;- numeric(0)        .ret$logitThetasLowF &lt;- numeric(0)        .ret$logitThetas &lt;- integer(0)        .ret$logitThetasHi &lt;- numeric(0)        .ret$logitThetasLow &lt;- numeric(0)        .ret$probitThetasF &lt;- integer(0)        .ret$probitThetasHiF &lt;- numeric(0)        .ret$probitThetasLowF &lt;- numeric(0)        .ret$probitThetas &lt;- integer(0)        .ret$probitThetasHi &lt;- numeric(0)        .ret$probitThetasLow &lt;- numeric(0)    }    if (exists("noLik", envir = .ret)) {        if (!.ret$noLik) {            .ret$.params &lt;- c(sprintf("THETA[%d]", seq_along(.ret$thetaIni)),                 sprintf("ETA[%d]", seq(1, dim(.om0)[1])))            .ret$.thetan &lt;- length(.ret$thetaIni)            .ret$nobs &lt;- sum(data$EVID == 0)        }    }    .ret$control$printTop &lt;- TRUE    .ret$control$nF &lt;- 0    .est0 &lt;- .ret$thetaIni    if (!is.null(.ret$model$pred.nolhs)) {        .ret$control$predNeq &lt;- length(.ret$model$pred.nolhs$state)    }    else {        .ret$control$predNeq &lt;- 0L    }    .fitFun &lt;- function(.ret) {        this.env &lt;- environment()        assign("err", "theta reset", this.env)        while (this.env$err == "theta reset") {            assign("err", "", this.env)            .ret0 &lt;- tryCatch({                foceiFitCpp_(.ret)            }, error = function(e) {                if (regexpr("theta reset", e$message) != -1) {                  assign("zeroOuter", FALSE, this.env)                  assign("zeroGrad", FALSE, this.env)                  if (regexpr("theta reset0", e$message) != -1) {                    assign("zeroGrad", TRUE, this.env)                  }                  else if (regexpr("theta resetZ", e$message) !=                     -1) {                    assign("zeroOuter", TRUE, this.env)                  }                  assign("err", "theta reset", this.env)                }                else {                  assign("err", e$message, this.env)                }            })            if (this.env$err == "theta reset") {                .nm &lt;- names(.ret$thetaIni)                .ret$thetaIni &lt;- setNames(.thetaReset$thetaIni +                   0, .nm)                .ret$rxInv$theta &lt;- .thetaReset$omegaTheta                .ret$control$printTop &lt;- FALSE                .ret$etaMat &lt;- .thetaReset$etaMat                .ret$control$etaMat &lt;- .thetaReset$etaMat                .ret$control$maxInnerIterations &lt;- .thetaReset$maxInnerIterations                .ret$control$nF &lt;- .thetaReset$nF                .ret$control$gillRetC &lt;- .thetaReset$gillRetC                .ret$control$gillRet &lt;- .thetaReset$gillRet                .ret$control$gillRet &lt;- .thetaReset$gillRet                .ret$control$gillDf &lt;- .thetaReset$gillDf                .ret$control$gillDf2 &lt;- .thetaReset$gillDf2                .ret$control$gillErr &lt;- .thetaReset$gillErr                .ret$control$rEps &lt;- .thetaReset$rEps                .ret$control$aEps &lt;- .thetaReset$aEps                .ret$control$rEpsC &lt;- .thetaReset$rEpsC                .ret$control$aEpsC &lt;- .thetaReset$aEpsC                .ret$control$c1 &lt;- .thetaReset$c1                .ret$control$c2 &lt;- .thetaReset$c2                if (this.env$zeroOuter) {                  message("Posthoc reset")                  .ret$control$maxOuterIterations &lt;- 0L                }                else if (this.env$zeroGrad) {                  message("Theta reset (zero gradient values); Switch to bobyqa")                  RxODE::rxReq("minqa")                  .ret$control$outerOptFun &lt;- .bobyqa                  .ret$control$outerOpt &lt;- -1L                }                else {                  message("Theta reset (ETA drift)")                }            }        }        if (this.env$err != "") {            stop(this.env$err)        }        else {            return(.ret0)        }    }    .ret0 &lt;- try(.fitFun(.ret))    .n &lt;- 1    while (inherits(.ret0, "try-error") &amp;&amp; control$maxOuterIterations !=         0 &amp;&amp; .n &lt;= control$nRetries) {        message(sprintf("Restart %s", .n))        .ret$control$nF &lt;- 0        .estNew &lt;- .est0 + 0.2 * .n * abs(.est0) * stats::runif(length(.est0)) -             0.1 * .n        .estNew &lt;- sapply(seq_along(.est0), function(.i) {            if (.ret$thetaFixed[.i]) {                return(.est0[.i])            }            else if (.estNew[.i] &lt; lower[.i]) {                return(lower + (.Machine$double.eps)^(1/7))            }            else if (.estNew[.i] &gt; upper[.i]) {                return(upper - (.Machine$double.eps)^(1/7))            }            else {                return(.estNew[.i])            }        })        .ret$thetaIni &lt;- .estNew        .ret0 &lt;- try(.fitFun(.ret))        .n &lt;- .n + 1    }    if (inherits(.ret0, "try-error"))         stop("Could not fit data.")    .ret &lt;- .ret0    if (exists("parHistData", .ret)) {        .tmp &lt;- .ret$parHistData        .tmp &lt;- .tmp[.tmp$type == "Unscaled", names(.tmp) !=             "type"]        .iter &lt;- .tmp$iter        .tmp &lt;- .tmp[, names(.tmp) != "iter"]        .ret$parHistStacked &lt;- data.frame(stack(.tmp), iter = .iter)        names(.ret$parHistStacked) &lt;- c("val", "par", "iter")        .ret$parHist &lt;- data.frame(iter = .iter, .tmp)    }    if (.mixed) {        .etas &lt;- .ret$ranef        .thetas &lt;- .ret$fixef        .pars &lt;- .Call(`_nlmixr_nlmixrParameters`, .thetas, .etas)        .ret$shrink &lt;- .Call(`_nlmixr_calcShrinkOnly`, .ret$omega,             .pars$eta.lst, length(.etas$ID))        .updateParFixed(.ret)    }    else {        .updateParFixed(.ret)    }    if (!exists("table", .ret)) {        .ret$table &lt;- tableControl()    }    if (control$calcTables) {        .ret &lt;- addTable(.ret, updateObject = "no", keep = keep,             drop = drop, table = .ret$table)    }    .ret})(data = dat, inits = .FoceiInits, PKpars = .pars, model = .mod,     pred = function() {        return(nlmixr_pred)    }, err = uif$error, lower = uif$focei.lower, upper = uif$focei.upper,     fixed = uif$focei.fixed, thetaNames = uif$focei.names, etaNames = uif$eta.names,     control = control, env = env, keep = .keep, drop = .drop): Not all the covariates are in the dataset.</span></div><div class='output co'>#&gt; <span class='message'>Timing stopped at: 6.666 0.38 7.044</span></div><div class='input'><span class='va'>f_nlmixr_dfop_sfo_saem_obs</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/pkg/nlmixr/man/nlmixr.html'>nlmixr</a></span><span class='op'>(</span><span class='va'>f_mmkin_obs</span><span class='op'>[</span><span class='st'>"DFOP-SFO"</span>, <span class='op'>]</span>, est <span class='op'>=</span> <span class='st'>"saem"</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> parameter labels from comments are typically ignored in non-interactive mode</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> Need to run with the source intact to parse comments</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'>→ generate SAEM model</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='error'>Error in configsaem(model = model, data = dat, inits = inits, mcmc = .mcmc,     ODEopt = .ODEopt, seed = .seed, distribution = .dist, DEBUG = .DEBUG,     addProp = .addProp, tol = .tol, itmax = .itmax, type = .type,     powRange = .powRange, lambdaRange = .lambdaRange): covariate(s) not found: f_parent_to_A1</span></div><div class='output co'>#&gt; <span class='message'>Timing stopped at: 1.39 0.093 1.483</span></div><div class='input'><span class='va'>f_nlmixr_dfop_sfo_focei_obs</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/pkg/nlmixr/man/nlmixr.html'>nlmixr</a></span><span class='op'>(</span><span class='va'>f_mmkin_obs</span><span class='op'>[</span><span class='st'>"DFOP-SFO"</span>, <span class='op'>]</span>, est <span class='op'>=</span> <span class='st'>"focei"</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> parameter labels from comments are typically ignored in non-interactive mode</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> Need to run with the source intact to parse comments</span></div><div class='output co'>#&gt; <span class='message'>→ creating full model...</span></div><div class='output co'>#&gt; <span class='message'>→ pruning branches (<span style='color: #262626; background-color: #DADADA;'>`if`</span>/<span style='color: #262626; background-color: #DADADA;'>`else`</span>)...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ loading into <span style='color: #0000BB;'>symengine</span> environment...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ creating full model...</span></div><div class='output co'>#&gt; <span class='message'>→ pruning branches (<span style='color: #262626; background-color: #DADADA;'>`if`</span>/<span style='color: #262626; background-color: #DADADA;'>`else`</span>)...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ loading into <span style='color: #0000BB;'>symengine</span> environment...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ calculate jacobian</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate sensitivities</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate ∂(f)/∂(η)</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate ∂(R²)/∂(η)</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in inner model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in inner model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in EBE model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in EBE model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ compiling inner model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in FD model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in FD model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ compiling EBE model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ compiling events FD model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>Model:</span></div><div class='output co'>#&gt; <span class='message'>cmt(parent);</span>
#&gt; <span class='message'>cmt(A1);</span>
#&gt; <span class='message'>rx_expr_6~ETA[1]+THETA[1];</span>
#&gt; <span class='message'>parent(0)=rx_expr_6;</span>
#&gt; <span class='message'>rx_expr_7~ETA[4]+THETA[4];</span>
#&gt; <span class='message'>rx_expr_8~ETA[6]+THETA[6];</span>
#&gt; <span class='message'>rx_expr_9~ETA[5]+THETA[5];</span>
#&gt; <span class='message'>rx_expr_12~exp(rx_expr_7);</span>
#&gt; <span class='message'>rx_expr_13~exp(rx_expr_9);</span>
#&gt; <span class='message'>rx_expr_15~t*rx_expr_12;</span>
#&gt; <span class='message'>rx_expr_16~t*rx_expr_13;</span>
#&gt; <span class='message'>rx_expr_17~exp(-(rx_expr_8));</span>
#&gt; <span class='message'>rx_expr_19~1+rx_expr_17;</span>
#&gt; <span class='message'>rx_expr_24~1/(rx_expr_19);</span>
#&gt; <span class='message'>rx_expr_26~(rx_expr_24);</span>
#&gt; <span class='message'>rx_expr_27~1-rx_expr_26;</span>
#&gt; <span class='message'>d/dt(parent)=-parent*(exp(rx_expr_7-rx_expr_15)/(rx_expr_19)+exp(rx_expr_9-rx_expr_16)*(rx_expr_27))/(exp(-t*rx_expr_12)/(rx_expr_19)+exp(-t*rx_expr_13)*(rx_expr_27));</span>
#&gt; <span class='message'>rx_expr_10~ETA[2]+THETA[2];</span>
#&gt; <span class='message'>rx_expr_14~exp(rx_expr_10);</span>
#&gt; <span class='message'>d/dt(A1)=-rx_expr_14*A1+parent*f_parent_to_A1*(exp(rx_expr_7-rx_expr_15)/(rx_expr_19)+exp(rx_expr_9-rx_expr_16)*(rx_expr_27))/(exp(-t*rx_expr_12)/(rx_expr_19)+exp(-t*rx_expr_13)*(rx_expr_27));</span>
#&gt; <span class='message'>rx_expr_0~CMT==2;</span>
#&gt; <span class='message'>rx_expr_1~CMT==1;</span>
#&gt; <span class='message'>rx_expr_2~1-(rx_expr_0);</span>
#&gt; <span class='message'>rx_yj_~2*(rx_expr_2)*(rx_expr_1)+2*(rx_expr_0);</span>
#&gt; <span class='message'>rx_expr_3~(rx_expr_0);</span>
#&gt; <span class='message'>rx_expr_5~(rx_expr_2);</span>
#&gt; <span class='message'>rx_expr_18~rx_expr_5*(rx_expr_1);</span>
#&gt; <span class='message'>rx_lambda_~rx_expr_18+rx_expr_3;</span>
#&gt; <span class='message'>rx_hi_~rx_expr_18+rx_expr_3;</span>
#&gt; <span class='message'>rx_low_~0;</span>
#&gt; <span class='message'>rx_expr_4~A1*(rx_expr_0);</span>
#&gt; <span class='message'>rx_expr_11~parent*(rx_expr_2);</span>
#&gt; <span class='message'>rx_expr_22~rx_expr_11*(rx_expr_1);</span>
#&gt; <span class='message'>rx_pred_=(rx_expr_4+rx_expr_22)*(rx_expr_0)+(rx_expr_4+rx_expr_22)*(rx_expr_2)*(rx_expr_1);</span>
#&gt; <span class='message'>rx_r_=(rx_expr_0)*Rx_pow_di(THETA[8],2)+(rx_expr_2)*(rx_expr_1)*Rx_pow_di(THETA[7],2);</span>
#&gt; <span class='message'>parent_0=THETA[1];</span>
#&gt; <span class='message'>log_k_A1=THETA[2];</span>
#&gt; <span class='message'>f_parent_qlogis=THETA[3];</span>
#&gt; <span class='message'>log_k1=THETA[4];</span>
#&gt; <span class='message'>log_k2=THETA[5];</span>
#&gt; <span class='message'>g_qlogis=THETA[6];</span>
#&gt; <span class='message'>sigma_parent=THETA[7];</span>
#&gt; <span class='message'>sigma_A1=THETA[8];</span>
#&gt; <span class='message'>eta.parent_0=ETA[1];</span>
#&gt; <span class='message'>eta.log_k_A1=ETA[2];</span>
#&gt; <span class='message'>eta.f_parent_qlogis=ETA[3];</span>
#&gt; <span class='message'>eta.log_k1=ETA[4];</span>
#&gt; <span class='message'>eta.log_k2=ETA[5];</span>
#&gt; <span class='message'>eta.g_qlogis=ETA[6];</span>
#&gt; <span class='message'>parent_0_model=rx_expr_6;</span>
#&gt; <span class='message'>k_A1=rx_expr_14;</span>
#&gt; <span class='message'>k1=rx_expr_12;</span>
#&gt; <span class='message'>k2=rx_expr_13;</span>
#&gt; <span class='message'>f_parent=1/(1+exp(-(ETA[3]+THETA[3])));</span>
#&gt; <span class='message'>g=1/(rx_expr_19);</span>
#&gt; <span class='message'>tad=tad();</span>
#&gt; <span class='message'>dosenum=dosenum();</span></div><div class='output co'>#&gt; <span class='message'>Needed Covariates:</span></div><div class='output co'>#&gt; <span class='message'>[1] "f_parent_to_A1" "CMT"           </span></div><div class='output co'>#&gt; <span class='error'>Error in (function (data, inits, PKpars, model = NULL, pred = NULL, err = NULL,     lower = -Inf, upper = Inf, fixed = NULL, skipCov = NULL,     control = foceiControl(), thetaNames = NULL, etaNames = NULL,     etaMat = NULL, ..., env = NULL, keep = NULL, drop = NULL) {    set.seed(control$seed)    .pt &lt;- proc.time()    RxODE::.setWarnIdSort(FALSE)    on.exit(RxODE::.setWarnIdSort(TRUE))    loadNamespace("n1qn1")    if (!RxODE::rxIs(control, "foceiControl")) {        control &lt;- do.call(foceiControl, control)    }    if (is.null(env)) {        .ret &lt;- new.env(parent = emptyenv())    }    else {        .ret &lt;- env    }    .ret$origData &lt;- data    .ret$etaNames &lt;- etaNames    .ret$thetaFixed &lt;- fixed    .ret$control &lt;- control    .ret$control$focei.mu.ref &lt;- integer(0)    if (is(model, "RxODE") || is(model, "character")) {        .ret$ODEmodel &lt;- TRUE        if (class(pred) != "function") {            stop("pred must be a function specifying the prediction variables in this model.")        }    }    else {        .ret$ODEmodel &lt;- TRUE        model &lt;- RxODE::rxGetLin(PKpars)        pred &lt;- eval(parse(text = "function(){return(Central);}"))    }    .square &lt;- function(x) x * x    .ret$diagXformInv &lt;- c(sqrt = ".square", log = "exp", identity = "identity")[control$diagXform]    if (is.null(err)) {        err &lt;- eval(parse(text = paste0("function(){err", paste(inits$ERROR[[1]],             collapse = ""), "}")))    }    .covNames &lt;- .parNames &lt;- c()    .ret$adjLik &lt;- control$adjLik    .mixed &lt;- !is.null(inits$OMGA) &amp;&amp; length(inits$OMGA) &gt; 0    if (!exists("noLik", envir = .ret)) {        .atol &lt;- rep(control$atol, length(RxODE::rxModelVars(model)$state))        .rtol &lt;- rep(control$rtol, length(RxODE::rxModelVars(model)$state))        .ssAtol &lt;- rep(control$ssAtol, length(RxODE::rxModelVars(model)$state))        .ssRtol &lt;- rep(control$ssRtol, length(RxODE::rxModelVars(model)$state))        .ret$model &lt;- RxODE::rxSymPySetupPred(model, pred, PKpars,             err, grad = (control$derivMethod == 2L), pred.minus.dv = TRUE,             sum.prod = control$sumProd, theta.derivs = FALSE,             optExpression = control$optExpression, interaction = (control$interaction ==                 1L), only.numeric = !.mixed, run.internal = TRUE,             addProp = control$addProp)        if (!is.null(.ret$model$inner)) {            .atol &lt;- c(.atol, rep(control$atolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                 length(.atol)))            .rtol &lt;- c(.rtol, rep(control$rtolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                 length(.rtol)))            .ret$control$rxControl$atol &lt;- .atol            .ret$control$rxControl$rtol &lt;- .rtol            .ssAtol &lt;- c(.ssAtol, rep(control$ssAtolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                 length(.ssAtol)))            .ssRtol &lt;- c(.ssRtol, rep(control$ssRtolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                 length(.ssRtol)))            .ret$control$rxControl$ssAtol &lt;- .ssAtol            .ret$control$rxControl$ssRtol &lt;- .ssRtol        }        .covNames &lt;- .parNames &lt;- RxODE::rxParams(.ret$model$pred.only)        .covNames &lt;- .covNames[regexpr(rex::rex(start, or("THETA",             "ETA"), "[", numbers, "]", end), .covNames) == -1]        colnames(data) &lt;- sapply(names(data), function(x) {            if (any(x == .covNames)) {                return(x)            }            else {                return(toupper(x))            }        })        .lhs &lt;- c(names(RxODE::rxInits(.ret$model$pred.only)),             RxODE::rxLhs(.ret$model$pred.only))        if (length(.lhs) &gt; 0) {            .covNames &lt;- .covNames[regexpr(rex::rex(start, or(.lhs),                 end), .covNames) == -1]        }        if (length(.covNames) &gt; 0) {            if (!all(.covNames %in% names(data))) {                message("Model:")                RxODE::rxCat(.ret$model$pred.only)                message("Needed Covariates:")                nlmixrPrint(.covNames)                stop("Not all the covariates are in the dataset.")            }            message("Needed Covariates:")            print(.covNames)        }        .extraPars &lt;- .ret$model$extra.pars    }    else {        if (.ret$noLik) {            .atol &lt;- rep(control$atol, length(RxODE::rxModelVars(model)$state))            .rtol &lt;- rep(control$rtol, length(RxODE::rxModelVars(model)$state))            .ret$model &lt;- RxODE::rxSymPySetupPred(model, pred,                 PKpars, err, grad = FALSE, pred.minus.dv = TRUE,                 sum.prod = control$sumProd, theta.derivs = FALSE,                 optExpression = control$optExpression, run.internal = TRUE,                 only.numeric = TRUE, addProp = control$addProp)            if (!is.null(.ret$model$inner)) {                .atol &lt;- c(.atol, rep(control$atolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                   length(.atol)))                .rtol &lt;- c(.rtol, rep(control$rtolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                   length(.rtol)))                .ret$control$rxControl$atol &lt;- .atol                .ret$control$rxControl$rtol &lt;- .rtol            }            .covNames &lt;- .parNames &lt;- RxODE::rxParams(.ret$model$pred.only)            .covNames &lt;- .covNames[regexpr(rex::rex(start, or("THETA",                 "ETA"), "[", numbers, "]", end), .covNames) ==                 -1]            colnames(data) &lt;- sapply(names(data), function(x) {                if (any(x == .covNames)) {                  return(x)                }                else {                  return(toupper(x))                }            })            .lhs &lt;- c(names(RxODE::rxInits(.ret$model$pred.only)),                 RxODE::rxLhs(.ret$model$pred.only))            if (length(.lhs) &gt; 0) {                .covNames &lt;- .covNames[regexpr(rex::rex(start,                   or(.lhs), end), .covNames) == -1]            }            if (length(.covNames) &gt; 0) {                if (!all(.covNames %in% names(data))) {                  message("Model:")                  RxODE::rxCat(.ret$model$pred.only)                  message("Needed Covariates:")                  nlmixrPrint(.covNames)                  stop("Not all the covariates are in the dataset.")                }                message("Needed Covariates:")                print(.covNames)            }            .extraPars &lt;- .ret$model$extra.pars        }        else {            .extraPars &lt;- NULL        }    }    .ret$skipCov &lt;- skipCov    if (is.null(skipCov)) {        if (is.null(fixed)) {            .tmp &lt;- rep(FALSE, length(inits$THTA))        }        else {            if (length(fixed) &lt; length(inits$THTA)) {                .tmp &lt;- c(fixed, rep(FALSE, length(inits$THTA) -                   length(fixed)))            }            else {                .tmp &lt;- fixed[1:length(inits$THTA)]            }        }        if (exists("uif", envir = .ret)) {            .uifErr &lt;- .ret$uif$ini$err[!is.na(.ret$uif$ini$ntheta)]            .uifErr &lt;- sapply(.uifErr, function(x) {                if (is.na(x)) {                  return(FALSE)                }                return(!any(x == c("pow2", "tbs", "tbsYj")))            })            .tmp &lt;- (.tmp | .uifErr)        }        .ret$skipCov &lt;- c(.tmp, rep(TRUE, length(.extraPars)))        .ret$control$focei.mu.ref &lt;- .ret$uif$focei.mu.ref    }    if (is.null(.extraPars)) {        .nms &lt;- c(sprintf("THETA[%s]", seq_along(inits$THTA)))    }    else {        .nms &lt;- c(sprintf("THETA[%s]", seq_along(inits$THTA)),             sprintf("ERR[%s]", seq_along(.extraPars)))    }    if (!is.null(thetaNames) &amp;&amp; (length(inits$THTA) + length(.extraPars)) ==         length(thetaNames)) {        .nms &lt;- thetaNames    }    .ret$thetaNames &lt;- .nms    .thetaReset$thetaNames &lt;- .nms    if (length(lower) == 1) {        lower &lt;- rep(lower, length(inits$THTA))    }    else if (length(lower) != length(inits$THTA)) {        print(inits$THTA)        print(lower)        stop("Lower must be a single constant for all the THETA lower bounds, or match the dimension of THETA.")    }    if (length(upper) == 1) {        upper &lt;- rep(upper, length(inits$THTA))    }    else if (length(lower) != length(inits$THTA)) {        stop("Upper must be a single constant for all the THETA lower bounds, or match the dimension of THETA.")    }    if (!is.null(.extraPars)) {        .ret$model$extra.pars &lt;- eval(call(control$diagXform,             .ret$model$extra.pars))        if (length(.ret$model$extra.pars) &gt; 0) {            inits$THTA &lt;- c(inits$THTA, .ret$model$extra.pars)            .lowerErr &lt;- rep(control$atol[1] * 10, length(.ret$model$extra.pars))            .upperErr &lt;- rep(Inf, length(.ret$model$extra.pars))            lower &lt;- c(lower, .lowerErr)            upper &lt;- c(upper, .upperErr)        }    }    if (is.null(data$ID))         stop("\"ID\" not found in data")    if (is.null(data$DV))         stop("\"DV\" not found in data")    if (is.null(data$EVID))         data$EVID &lt;- 0    if (is.null(data$AMT))         data$AMT &lt;- 0    for (.v in c("TIME", "AMT", "DV", .covNames)) {        data[[.v]] &lt;- as.double(data[[.v]])    }    .ret$dataSav &lt;- data    .ds &lt;- data[data$EVID != 0 &amp; data$EVID != 2, c("ID", "TIME",         "AMT", "EVID", .covNames)]    .w &lt;- which(tolower(names(data)) == "limit")    .limitName &lt;- NULL    if (length(.w) == 1L) {        .limitName &lt;- names(data)[.w]    }    .censName &lt;- NULL    .w &lt;- which(tolower(names(data)) == "cens")    if (length(.w) == 1L) {        .censName &lt;- names(data[.w])    }    data &lt;- data[data$EVID == 0 | data$EVID == 2, c("ID", "TIME",         "DV", "EVID", .covNames, .limitName, .censName)]    .w &lt;- which(!(names(.ret$dataSav) %in% c(.covNames, keep)))    names(.ret$dataSav)[.w] &lt;- tolower(names(.ret$dataSav[.w]))    if (.mixed) {        .lh &lt;- .parseOM(inits$OMGA)        .nlh &lt;- sapply(.lh, length)        .osplt &lt;- rep(1:length(.lh), .nlh)        .lini &lt;- list(inits$THTA, unlist(.lh))        .nlini &lt;- sapply(.lini, length)        .nsplt &lt;- rep(1:length(.lini), .nlini)        .om0 &lt;- .genOM(.lh)        if (length(etaNames) == dim(.om0)[1]) {            .ret$etaNames &lt;- .ret$etaNames        }        else {            .ret$etaNames &lt;- sprintf("ETA[%d]", seq(1, dim(.om0)[1]))        }        .ret$rxInv &lt;- RxODE::rxSymInvCholCreate(mat = .om0, diag.xform = control$diagXform)        .ret$xType &lt;- .ret$rxInv$xType        .om0a &lt;- .om0        .om0a &lt;- .om0a/control$diagOmegaBoundLower        .om0b &lt;- .om0        .om0b &lt;- .om0b * control$diagOmegaBoundUpper        .om0a &lt;- RxODE::rxSymInvCholCreate(mat = .om0a, diag.xform = control$diagXform)        .om0b &lt;- RxODE::rxSymInvCholCreate(mat = .om0b, diag.xform = control$diagXform)        .omdf &lt;- data.frame(a = .om0a$theta, m = .ret$rxInv$theta,             b = .om0b$theta, diag = .om0a$theta.diag)        .omdf$lower &lt;- with(.omdf, ifelse(a &gt; b, b, a))        .omdf$lower &lt;- with(.omdf, ifelse(lower == m, -Inf, lower))        .omdf$lower &lt;- with(.omdf, ifelse(!diag, -Inf, lower))        .omdf$upper &lt;- with(.omdf, ifelse(a &lt; b, b, a))        .omdf$upper &lt;- with(.omdf, ifelse(upper == m, Inf, upper))        .omdf$upper &lt;- with(.omdf, ifelse(!diag, Inf, upper))        .ret$control$nomega &lt;- length(.omdf$lower)        .ret$control$neta &lt;- sum(.omdf$diag)        .ret$control$ntheta &lt;- length(lower)        .ret$control$nfixed &lt;- sum(fixed)        lower &lt;- c(lower, .omdf$lower)        upper &lt;- c(upper, .omdf$upper)    }    else {        .ret$control$nomega &lt;- 0        .ret$control$neta &lt;- 0        .ret$xType &lt;- -1        .ret$control$ntheta &lt;- length(lower)        .ret$control$nfixed &lt;- sum(fixed)    }    .ret$lower &lt;- lower    .ret$upper &lt;- upper    .ret$thetaIni &lt;- inits$THTA    .scaleC &lt;- double(length(lower))    if (is.null(control$scaleC)) {        .scaleC &lt;- rep(NA_real_, length(lower))    }    else {        .scaleC &lt;- as.double(control$scaleC)        if (length(lower) &gt; length(.scaleC)) {            .scaleC &lt;- c(.scaleC, rep(NA_real_, length(lower) -                 length(.scaleC)))        }        else if (length(lower) &lt; length(.scaleC)) {            .scaleC &lt;- .scaleC[seq(1, length(lower))]            warning("scaleC control option has more options than estimated population parameters, please check.")        }    }    .ret$scaleC &lt;- .scaleC    if (exists("uif", envir = .ret)) {        .ini &lt;- as.data.frame(.ret$uif$ini)[!is.na(.ret$uif$ini$err),             c("est", "err", "ntheta")]        for (.i in seq_along(.ini$err)) {            if (is.na(.ret$scaleC[.ini$ntheta[.i]])) {                if (any(.ini$err[.i] == c("boxCox", "yeoJohnson",                   "pow2", "tbs", "tbsYj"))) {                  .ret$scaleC[.ini$ntheta[.i]] &lt;- 1                }                else if (any(.ini$err[.i] == c("prop", "add",                   "norm", "dnorm", "logn", "dlogn", "lnorm",                   "dlnorm"))) {                  .ret$scaleC[.ini$ntheta[.i]] &lt;- 0.5 * abs(.ini$est[.i])                }            }        }        for (.i in .ini$model$extraProps$powTheta) {            if (is.na(.ret$scaleC[.i]))                 .ret$scaleC[.i] &lt;- 1        }        .ini &lt;- as.data.frame(.ret$uif$ini)        for (.i in .ini$model$extraProps$factorial) {            if (is.na(.ret$scaleC[.i]))                 .ret$scaleC[.i] &lt;- abs(1/digamma(.ini$est[.i] +                   1))        }        for (.i in .ini$model$extraProps$gamma) {            if (is.na(.ret$scaleC[.i]))                 .ret$scaleC[.i] &lt;- abs(1/digamma(.ini$est[.i]))        }        for (.i in .ini$model$extraProps$log) {            if (is.na(.ret$scaleC[.i]))                 .ret$scaleC[.i] &lt;- log(abs(.ini$est[.i])) * abs(.ini$est[.i])        }        for (.i in .ret$logitThetas) {            .b &lt;- .ret$logitThetasLow[.i]            .c &lt;- .ret$logitThetasHi[.i]            .a &lt;- .ini$est[.i]            if (is.na(.ret$scaleC[.i])) {                .ret$scaleC[.i] &lt;- 1 * (-.b + .c) * exp(-.a)/((1 +                   exp(-.a))^2 * (.b + 1 * (-.b + .c)/(1 + exp(-.a))))            }        }    }    names(.ret$thetaIni) &lt;- sprintf("THETA[%d]", seq_along(.ret$thetaIni))    if (is.null(etaMat) &amp; !is.null(control$etaMat)) {        .ret$etaMat &lt;- control$etaMat    }    else {        .ret$etaMat &lt;- etaMat    }    .ret$setupTime &lt;- (proc.time() - .pt)["elapsed"]    if (exists("uif", envir = .ret)) {        .tmp &lt;- .ret$uif$logThetasList        .ret$logThetas &lt;- .tmp[[1]]        .ret$logThetasF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$logitThetasList        .ret$logitThetas &lt;- .tmp[[1]]        .ret$logitThetasF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$logitThetasListLow        .ret$logitThetasLow &lt;- .tmp[[1]]        .ret$logitThetasLowF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$logitThetasListHi        .ret$logitThetasHi &lt;- .tmp[[1]]        .ret$logitThetasHiF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$probitThetasList        .ret$probitThetas &lt;- .tmp[[1]]        .ret$probitThetasF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$probitThetasListLow        .ret$probitThetasLow &lt;- .tmp[[1]]        .ret$probitThetasLowF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$probitThetasListHi        .ret$probitThetasHi &lt;- .tmp[[1]]        .ret$probitThetasHiF &lt;- .tmp[[2]]    }    else {        .ret$logThetasF &lt;- integer(0)        .ret$logitThetasF &lt;- integer(0)        .ret$logitThetasHiF &lt;- numeric(0)        .ret$logitThetasLowF &lt;- numeric(0)        .ret$logitThetas &lt;- integer(0)        .ret$logitThetasHi &lt;- numeric(0)        .ret$logitThetasLow &lt;- numeric(0)        .ret$probitThetasF &lt;- integer(0)        .ret$probitThetasHiF &lt;- numeric(0)        .ret$probitThetasLowF &lt;- numeric(0)        .ret$probitThetas &lt;- integer(0)        .ret$probitThetasHi &lt;- numeric(0)        .ret$probitThetasLow &lt;- numeric(0)    }    if (exists("noLik", envir = .ret)) {        if (!.ret$noLik) {            .ret$.params &lt;- c(sprintf("THETA[%d]", seq_along(.ret$thetaIni)),                 sprintf("ETA[%d]", seq(1, dim(.om0)[1])))            .ret$.thetan &lt;- length(.ret$thetaIni)            .ret$nobs &lt;- sum(data$EVID == 0)        }    }    .ret$control$printTop &lt;- TRUE    .ret$control$nF &lt;- 0    .est0 &lt;- .ret$thetaIni    if (!is.null(.ret$model$pred.nolhs)) {        .ret$control$predNeq &lt;- length(.ret$model$pred.nolhs$state)    }    else {        .ret$control$predNeq &lt;- 0L    }    .fitFun &lt;- function(.ret) {        this.env &lt;- environment()        assign("err", "theta reset", this.env)        while (this.env$err == "theta reset") {            assign("err", "", this.env)            .ret0 &lt;- tryCatch({                foceiFitCpp_(.ret)            }, error = function(e) {                if (regexpr("theta reset", e$message) != -1) {                  assign("zeroOuter", FALSE, this.env)                  assign("zeroGrad", FALSE, this.env)                  if (regexpr("theta reset0", e$message) != -1) {                    assign("zeroGrad", TRUE, this.env)                  }                  else if (regexpr("theta resetZ", e$message) !=                     -1) {                    assign("zeroOuter", TRUE, this.env)                  }                  assign("err", "theta reset", this.env)                }                else {                  assign("err", e$message, this.env)                }            })            if (this.env$err == "theta reset") {                .nm &lt;- names(.ret$thetaIni)                .ret$thetaIni &lt;- setNames(.thetaReset$thetaIni +                   0, .nm)                .ret$rxInv$theta &lt;- .thetaReset$omegaTheta                .ret$control$printTop &lt;- FALSE                .ret$etaMat &lt;- .thetaReset$etaMat                .ret$control$etaMat &lt;- .thetaReset$etaMat                .ret$control$maxInnerIterations &lt;- .thetaReset$maxInnerIterations                .ret$control$nF &lt;- .thetaReset$nF                .ret$control$gillRetC &lt;- .thetaReset$gillRetC                .ret$control$gillRet &lt;- .thetaReset$gillRet                .ret$control$gillRet &lt;- .thetaReset$gillRet                .ret$control$gillDf &lt;- .thetaReset$gillDf                .ret$control$gillDf2 &lt;- .thetaReset$gillDf2                .ret$control$gillErr &lt;- .thetaReset$gillErr                .ret$control$rEps &lt;- .thetaReset$rEps                .ret$control$aEps &lt;- .thetaReset$aEps                .ret$control$rEpsC &lt;- .thetaReset$rEpsC                .ret$control$aEpsC &lt;- .thetaReset$aEpsC                .ret$control$c1 &lt;- .thetaReset$c1                .ret$control$c2 &lt;- .thetaReset$c2                if (this.env$zeroOuter) {                  message("Posthoc reset")                  .ret$control$maxOuterIterations &lt;- 0L                }                else if (this.env$zeroGrad) {                  message("Theta reset (zero gradient values); Switch to bobyqa")                  RxODE::rxReq("minqa")                  .ret$control$outerOptFun &lt;- .bobyqa                  .ret$control$outerOpt &lt;- -1L                }                else {                  message("Theta reset (ETA drift)")                }            }        }        if (this.env$err != "") {            stop(this.env$err)        }        else {            return(.ret0)        }    }    .ret0 &lt;- try(.fitFun(.ret))    .n &lt;- 1    while (inherits(.ret0, "try-error") &amp;&amp; control$maxOuterIterations !=         0 &amp;&amp; .n &lt;= control$nRetries) {        message(sprintf("Restart %s", .n))        .ret$control$nF &lt;- 0        .estNew &lt;- .est0 + 0.2 * .n * abs(.est0) * stats::runif(length(.est0)) -             0.1 * .n        .estNew &lt;- sapply(seq_along(.est0), function(.i) {            if (.ret$thetaFixed[.i]) {                return(.est0[.i])            }            else if (.estNew[.i] &lt; lower[.i]) {                return(lower + (.Machine$double.eps)^(1/7))            }            else if (.estNew[.i] &gt; upper[.i]) {                return(upper - (.Machine$double.eps)^(1/7))            }            else {                return(.estNew[.i])            }        })        .ret$thetaIni &lt;- .estNew        .ret0 &lt;- try(.fitFun(.ret))        .n &lt;- .n + 1    }    if (inherits(.ret0, "try-error"))         stop("Could not fit data.")    .ret &lt;- .ret0    if (exists("parHistData", .ret)) {        .tmp &lt;- .ret$parHistData        .tmp &lt;- .tmp[.tmp$type == "Unscaled", names(.tmp) !=             "type"]        .iter &lt;- .tmp$iter        .tmp &lt;- .tmp[, names(.tmp) != "iter"]        .ret$parHistStacked &lt;- data.frame(stack(.tmp), iter = .iter)        names(.ret$parHistStacked) &lt;- c("val", "par", "iter")        .ret$parHist &lt;- data.frame(iter = .iter, .tmp)    }    if (.mixed) {        .etas &lt;- .ret$ranef        .thetas &lt;- .ret$fixef        .pars &lt;- .Call(`_nlmixr_nlmixrParameters`, .thetas, .etas)        .ret$shrink &lt;- .Call(`_nlmixr_calcShrinkOnly`, .ret$omega,             .pars$eta.lst, length(.etas$ID))        .updateParFixed(.ret)    }    else {        .updateParFixed(.ret)    }    if (!exists("table", .ret)) {        .ret$table &lt;- tableControl()    }    if (control$calcTables) {        .ret &lt;- addTable(.ret, updateObject = "no", keep = keep,             drop = drop, table = .ret$table)    }    .ret})(data = dat, inits = .FoceiInits, PKpars = .pars, model = .mod,     pred = function() {        return(nlmixr_pred)    }, err = uif$error, lower = uif$focei.lower, upper = uif$focei.upper,     fixed = uif$focei.fixed, thetaNames = uif$focei.names, etaNames = uif$eta.names,     control = control, env = env, keep = .keep, drop = .drop): Not all the covariates are in the dataset.</span></div><div class='output co'>#&gt; <span class='message'>Timing stopped at: 14.67 0.529 15.2</span></div><div class='input'>
<span class='co'># Identical two-component error for all variables is only possible with</span>
<span class='co'># est = 'focei' in nlmixr</span>
<span class='va'>f_nlmixr_fomc_sfo_focei_tc</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/pkg/nlmixr/man/nlmixr.html'>nlmixr</a></span><span class='op'>(</span><span class='va'>f_mmkin_tc</span><span class='op'>[</span><span class='st'>"FOMC-SFO"</span>, <span class='op'>]</span>, est <span class='op'>=</span> <span class='st'>"focei"</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> parameter labels from comments are typically ignored in non-interactive mode</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> Need to run with the source intact to parse comments</span></div><div class='output co'>#&gt; <span class='message'>→ creating full model...</span></div><div class='output co'>#&gt; <span class='message'>→ pruning branches (<span style='color: #262626; background-color: #DADADA;'>`if`</span>/<span style='color: #262626; background-color: #DADADA;'>`else`</span>)...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ loading into <span style='color: #0000BB;'>symengine</span> environment...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ creating full model...</span></div><div class='output co'>#&gt; <span class='message'>→ pruning branches (<span style='color: #262626; background-color: #DADADA;'>`if`</span>/<span style='color: #262626; background-color: #DADADA;'>`else`</span>)...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ loading into <span style='color: #0000BB;'>symengine</span> environment...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ calculate jacobian</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate sensitivities</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate ∂(f)/∂(η)</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate ∂(R²)/∂(η)</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in inner model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in inner model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in EBE model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in EBE model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ compiling inner model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in FD model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in FD model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ compiling EBE model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ compiling events FD model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>Model:</span></div><div class='output co'>#&gt; <span class='message'>cmt(parent);</span>
#&gt; <span class='message'>cmt(A1);</span>
#&gt; <span class='message'>rx_expr_6~ETA[1]+THETA[1];</span>
#&gt; <span class='message'>parent(0)=rx_expr_6;</span>
#&gt; <span class='message'>rx_expr_7~ETA[4]+THETA[4];</span>
#&gt; <span class='message'>rx_expr_8~ETA[5]+THETA[5];</span>
#&gt; <span class='message'>rx_expr_14~exp(-(rx_expr_8));</span>
#&gt; <span class='message'>rx_expr_16~t*rx_expr_14;</span>
#&gt; <span class='message'>rx_expr_17~1+rx_expr_16;</span>
#&gt; <span class='message'>rx_expr_19~rx_expr_7-(rx_expr_8);</span>
#&gt; <span class='message'>rx_expr_21~exp(rx_expr_19);</span>
#&gt; <span class='message'>d/dt(parent)=-rx_expr_21*parent/(rx_expr_17);</span>
#&gt; <span class='message'>rx_expr_9~ETA[2]+THETA[2];</span>
#&gt; <span class='message'>rx_expr_11~exp(rx_expr_9);</span>
#&gt; <span class='message'>d/dt(A1)=-rx_expr_11*A1+rx_expr_21*parent*f_parent_to_A1/(rx_expr_17);</span>
#&gt; <span class='message'>rx_expr_0~CMT==2;</span>
#&gt; <span class='message'>rx_expr_1~CMT==1;</span>
#&gt; <span class='message'>rx_expr_2~1-(rx_expr_0);</span>
#&gt; <span class='message'>rx_yj_~2*(rx_expr_2)*(rx_expr_1)+2*(rx_expr_0);</span>
#&gt; <span class='message'>rx_expr_3~(rx_expr_0);</span>
#&gt; <span class='message'>rx_expr_5~(rx_expr_2);</span>
#&gt; <span class='message'>rx_expr_15~rx_expr_5*(rx_expr_1);</span>
#&gt; <span class='message'>rx_lambda_~rx_expr_15+rx_expr_3;</span>
#&gt; <span class='message'>rx_hi_~rx_expr_15+rx_expr_3;</span>
#&gt; <span class='message'>rx_low_~0;</span>
#&gt; <span class='message'>rx_expr_4~A1*(rx_expr_0);</span>
#&gt; <span class='message'>rx_expr_10~parent*(rx_expr_2);</span>
#&gt; <span class='message'>rx_expr_18~rx_expr_10*(rx_expr_1);</span>
#&gt; <span class='message'>rx_pred_=(rx_expr_4+rx_expr_18)*(rx_expr_0)+(rx_expr_4+rx_expr_18)*(rx_expr_2)*(rx_expr_1);</span>
#&gt; <span class='message'>rx_expr_12~Rx_pow_di(THETA[7],2);</span>
#&gt; <span class='message'>rx_expr_13~Rx_pow_di(THETA[6],2);</span>
#&gt; <span class='message'>rx_r_=(Rx_pow_di(((rx_expr_4+rx_expr_18)*(rx_expr_0)+(rx_expr_4+rx_expr_18)*(rx_expr_2)*(rx_expr_1)),2)*rx_expr_12+rx_expr_13)*(rx_expr_0)+(rx_expr_12*Rx_pow_di(((rx_expr_4+rx_expr_18)*(rx_expr_1)),2)+rx_expr_13)*(rx_expr_2)*(rx_expr_1);</span>
#&gt; <span class='message'>parent_0=THETA[1];</span>
#&gt; <span class='message'>log_k_A1=THETA[2];</span>
#&gt; <span class='message'>f_parent_qlogis=THETA[3];</span>
#&gt; <span class='message'>log_alpha=THETA[4];</span>
#&gt; <span class='message'>log_beta=THETA[5];</span>
#&gt; <span class='message'>sigma_low=THETA[6];</span>
#&gt; <span class='message'>rsd_high=THETA[7];</span>
#&gt; <span class='message'>eta.parent_0=ETA[1];</span>
#&gt; <span class='message'>eta.log_k_A1=ETA[2];</span>
#&gt; <span class='message'>eta.f_parent_qlogis=ETA[3];</span>
#&gt; <span class='message'>eta.log_alpha=ETA[4];</span>
#&gt; <span class='message'>eta.log_beta=ETA[5];</span>
#&gt; <span class='message'>parent_0_model=rx_expr_6;</span>
#&gt; <span class='message'>k_A1=rx_expr_11;</span>
#&gt; <span class='message'>alpha=exp(rx_expr_7);</span>
#&gt; <span class='message'>beta=exp(rx_expr_8);</span>
#&gt; <span class='message'>f_parent=1/(1+exp(-(ETA[3]+THETA[3])));</span>
#&gt; <span class='message'>tad=tad();</span>
#&gt; <span class='message'>dosenum=dosenum();</span></div><div class='output co'>#&gt; <span class='message'>Needed Covariates:</span></div><div class='output co'>#&gt; <span class='message'>[1] "f_parent_to_A1" "CMT"           </span></div><div class='output co'>#&gt; <span class='error'>Error in (function (data, inits, PKpars, model = NULL, pred = NULL, err = NULL,     lower = -Inf, upper = Inf, fixed = NULL, skipCov = NULL,     control = foceiControl(), thetaNames = NULL, etaNames = NULL,     etaMat = NULL, ..., env = NULL, keep = NULL, drop = NULL) {    set.seed(control$seed)    .pt &lt;- proc.time()    RxODE::.setWarnIdSort(FALSE)    on.exit(RxODE::.setWarnIdSort(TRUE))    loadNamespace("n1qn1")    if (!RxODE::rxIs(control, "foceiControl")) {        control &lt;- do.call(foceiControl, control)    }    if (is.null(env)) {        .ret &lt;- new.env(parent = emptyenv())    }    else {        .ret &lt;- env    }    .ret$origData &lt;- data    .ret$etaNames &lt;- etaNames    .ret$thetaFixed &lt;- fixed    .ret$control &lt;- control    .ret$control$focei.mu.ref &lt;- integer(0)    if (is(model, "RxODE") || is(model, "character")) {        .ret$ODEmodel &lt;- TRUE        if (class(pred) != "function") {            stop("pred must be a function specifying the prediction variables in this model.")        }    }    else {        .ret$ODEmodel &lt;- TRUE        model &lt;- RxODE::rxGetLin(PKpars)        pred &lt;- eval(parse(text = "function(){return(Central);}"))    }    .square &lt;- function(x) x * x    .ret$diagXformInv &lt;- c(sqrt = ".square", log = "exp", identity = "identity")[control$diagXform]    if (is.null(err)) {        err &lt;- eval(parse(text = paste0("function(){err", paste(inits$ERROR[[1]],             collapse = ""), "}")))    }    .covNames &lt;- .parNames &lt;- c()    .ret$adjLik &lt;- control$adjLik    .mixed &lt;- !is.null(inits$OMGA) &amp;&amp; length(inits$OMGA) &gt; 0    if (!exists("noLik", envir = .ret)) {        .atol &lt;- rep(control$atol, length(RxODE::rxModelVars(model)$state))        .rtol &lt;- rep(control$rtol, length(RxODE::rxModelVars(model)$state))        .ssAtol &lt;- rep(control$ssAtol, length(RxODE::rxModelVars(model)$state))        .ssRtol &lt;- rep(control$ssRtol, length(RxODE::rxModelVars(model)$state))        .ret$model &lt;- RxODE::rxSymPySetupPred(model, pred, PKpars,             err, grad = (control$derivMethod == 2L), pred.minus.dv = TRUE,             sum.prod = control$sumProd, theta.derivs = FALSE,             optExpression = control$optExpression, interaction = (control$interaction ==                 1L), only.numeric = !.mixed, run.internal = TRUE,             addProp = control$addProp)        if (!is.null(.ret$model$inner)) {            .atol &lt;- c(.atol, rep(control$atolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                 length(.atol)))            .rtol &lt;- c(.rtol, rep(control$rtolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                 length(.rtol)))            .ret$control$rxControl$atol &lt;- .atol            .ret$control$rxControl$rtol &lt;- .rtol            .ssAtol &lt;- c(.ssAtol, rep(control$ssAtolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                 length(.ssAtol)))            .ssRtol &lt;- c(.ssRtol, rep(control$ssRtolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                 length(.ssRtol)))            .ret$control$rxControl$ssAtol &lt;- .ssAtol            .ret$control$rxControl$ssRtol &lt;- .ssRtol        }        .covNames &lt;- .parNames &lt;- RxODE::rxParams(.ret$model$pred.only)        .covNames &lt;- .covNames[regexpr(rex::rex(start, or("THETA",             "ETA"), "[", numbers, "]", end), .covNames) == -1]        colnames(data) &lt;- sapply(names(data), function(x) {            if (any(x == .covNames)) {                return(x)            }            else {                return(toupper(x))            }        })        .lhs &lt;- c(names(RxODE::rxInits(.ret$model$pred.only)),             RxODE::rxLhs(.ret$model$pred.only))        if (length(.lhs) &gt; 0) {            .covNames &lt;- .covNames[regexpr(rex::rex(start, or(.lhs),                 end), .covNames) == -1]        }        if (length(.covNames) &gt; 0) {            if (!all(.covNames %in% names(data))) {                message("Model:")                RxODE::rxCat(.ret$model$pred.only)                message("Needed Covariates:")                nlmixrPrint(.covNames)                stop("Not all the covariates are in the dataset.")            }            message("Needed Covariates:")            print(.covNames)        }        .extraPars &lt;- .ret$model$extra.pars    }    else {        if (.ret$noLik) {            .atol &lt;- rep(control$atol, length(RxODE::rxModelVars(model)$state))            .rtol &lt;- rep(control$rtol, length(RxODE::rxModelVars(model)$state))            .ret$model &lt;- RxODE::rxSymPySetupPred(model, pred,                 PKpars, err, grad = FALSE, pred.minus.dv = TRUE,                 sum.prod = control$sumProd, theta.derivs = FALSE,                 optExpression = control$optExpression, run.internal = TRUE,                 only.numeric = TRUE, addProp = control$addProp)            if (!is.null(.ret$model$inner)) {                .atol &lt;- c(.atol, rep(control$atolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                   length(.atol)))                .rtol &lt;- c(.rtol, rep(control$rtolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                   length(.rtol)))                .ret$control$rxControl$atol &lt;- .atol                .ret$control$rxControl$rtol &lt;- .rtol            }            .covNames &lt;- .parNames &lt;- RxODE::rxParams(.ret$model$pred.only)            .covNames &lt;- .covNames[regexpr(rex::rex(start, or("THETA",                 "ETA"), "[", numbers, "]", end), .covNames) ==                 -1]            colnames(data) &lt;- sapply(names(data), function(x) {                if (any(x == .covNames)) {                  return(x)                }                else {                  return(toupper(x))                }            })            .lhs &lt;- c(names(RxODE::rxInits(.ret$model$pred.only)),                 RxODE::rxLhs(.ret$model$pred.only))            if (length(.lhs) &gt; 0) {                .covNames &lt;- .covNames[regexpr(rex::rex(start,                   or(.lhs), end), .covNames) == -1]            }            if (length(.covNames) &gt; 0) {                if (!all(.covNames %in% names(data))) {                  message("Model:")                  RxODE::rxCat(.ret$model$pred.only)                  message("Needed Covariates:")                  nlmixrPrint(.covNames)                  stop("Not all the covariates are in the dataset.")                }                message("Needed Covariates:")                print(.covNames)            }            .extraPars &lt;- .ret$model$extra.pars        }        else {            .extraPars &lt;- NULL        }    }    .ret$skipCov &lt;- skipCov    if (is.null(skipCov)) {        if (is.null(fixed)) {            .tmp &lt;- rep(FALSE, length(inits$THTA))        }        else {            if (length(fixed) &lt; length(inits$THTA)) {                .tmp &lt;- c(fixed, rep(FALSE, length(inits$THTA) -                   length(fixed)))            }            else {                .tmp &lt;- fixed[1:length(inits$THTA)]            }        }        if (exists("uif", envir = .ret)) {            .uifErr &lt;- .ret$uif$ini$err[!is.na(.ret$uif$ini$ntheta)]            .uifErr &lt;- sapply(.uifErr, function(x) {                if (is.na(x)) {                  return(FALSE)                }                return(!any(x == c("pow2", "tbs", "tbsYj")))            })            .tmp &lt;- (.tmp | .uifErr)        }        .ret$skipCov &lt;- c(.tmp, rep(TRUE, length(.extraPars)))        .ret$control$focei.mu.ref &lt;- .ret$uif$focei.mu.ref    }    if (is.null(.extraPars)) {        .nms &lt;- c(sprintf("THETA[%s]", seq_along(inits$THTA)))    }    else {        .nms &lt;- c(sprintf("THETA[%s]", seq_along(inits$THTA)),             sprintf("ERR[%s]", seq_along(.extraPars)))    }    if (!is.null(thetaNames) &amp;&amp; (length(inits$THTA) + length(.extraPars)) ==         length(thetaNames)) {        .nms &lt;- thetaNames    }    .ret$thetaNames &lt;- .nms    .thetaReset$thetaNames &lt;- .nms    if (length(lower) == 1) {        lower &lt;- rep(lower, length(inits$THTA))    }    else if (length(lower) != length(inits$THTA)) {        print(inits$THTA)        print(lower)        stop("Lower must be a single constant for all the THETA lower bounds, or match the dimension of THETA.")    }    if (length(upper) == 1) {        upper &lt;- rep(upper, length(inits$THTA))    }    else if (length(lower) != length(inits$THTA)) {        stop("Upper must be a single constant for all the THETA lower bounds, or match the dimension of THETA.")    }    if (!is.null(.extraPars)) {        .ret$model$extra.pars &lt;- eval(call(control$diagXform,             .ret$model$extra.pars))        if (length(.ret$model$extra.pars) &gt; 0) {            inits$THTA &lt;- c(inits$THTA, .ret$model$extra.pars)            .lowerErr &lt;- rep(control$atol[1] * 10, length(.ret$model$extra.pars))            .upperErr &lt;- rep(Inf, length(.ret$model$extra.pars))            lower &lt;- c(lower, .lowerErr)            upper &lt;- c(upper, .upperErr)        }    }    if (is.null(data$ID))         stop("\"ID\" not found in data")    if (is.null(data$DV))         stop("\"DV\" not found in data")    if (is.null(data$EVID))         data$EVID &lt;- 0    if (is.null(data$AMT))         data$AMT &lt;- 0    for (.v in c("TIME", "AMT", "DV", .covNames)) {        data[[.v]] &lt;- as.double(data[[.v]])    }    .ret$dataSav &lt;- data    .ds &lt;- data[data$EVID != 0 &amp; data$EVID != 2, c("ID", "TIME",         "AMT", "EVID", .covNames)]    .w &lt;- which(tolower(names(data)) == "limit")    .limitName &lt;- NULL    if (length(.w) == 1L) {        .limitName &lt;- names(data)[.w]    }    .censName &lt;- NULL    .w &lt;- which(tolower(names(data)) == "cens")    if (length(.w) == 1L) {        .censName &lt;- names(data[.w])    }    data &lt;- data[data$EVID == 0 | data$EVID == 2, c("ID", "TIME",         "DV", "EVID", .covNames, .limitName, .censName)]    .w &lt;- which(!(names(.ret$dataSav) %in% c(.covNames, keep)))    names(.ret$dataSav)[.w] &lt;- tolower(names(.ret$dataSav[.w]))    if (.mixed) {        .lh &lt;- .parseOM(inits$OMGA)        .nlh &lt;- sapply(.lh, length)        .osplt &lt;- rep(1:length(.lh), .nlh)        .lini &lt;- list(inits$THTA, unlist(.lh))        .nlini &lt;- sapply(.lini, length)        .nsplt &lt;- rep(1:length(.lini), .nlini)        .om0 &lt;- .genOM(.lh)        if (length(etaNames) == dim(.om0)[1]) {            .ret$etaNames &lt;- .ret$etaNames        }        else {            .ret$etaNames &lt;- sprintf("ETA[%d]", seq(1, dim(.om0)[1]))        }        .ret$rxInv &lt;- RxODE::rxSymInvCholCreate(mat = .om0, diag.xform = control$diagXform)        .ret$xType &lt;- .ret$rxInv$xType        .om0a &lt;- .om0        .om0a &lt;- .om0a/control$diagOmegaBoundLower        .om0b &lt;- .om0        .om0b &lt;- .om0b * control$diagOmegaBoundUpper        .om0a &lt;- RxODE::rxSymInvCholCreate(mat = .om0a, diag.xform = control$diagXform)        .om0b &lt;- RxODE::rxSymInvCholCreate(mat = .om0b, diag.xform = control$diagXform)        .omdf &lt;- data.frame(a = .om0a$theta, m = .ret$rxInv$theta,             b = .om0b$theta, diag = .om0a$theta.diag)        .omdf$lower &lt;- with(.omdf, ifelse(a &gt; b, b, a))        .omdf$lower &lt;- with(.omdf, ifelse(lower == m, -Inf, lower))        .omdf$lower &lt;- with(.omdf, ifelse(!diag, -Inf, lower))        .omdf$upper &lt;- with(.omdf, ifelse(a &lt; b, b, a))        .omdf$upper &lt;- with(.omdf, ifelse(upper == m, Inf, upper))        .omdf$upper &lt;- with(.omdf, ifelse(!diag, Inf, upper))        .ret$control$nomega &lt;- length(.omdf$lower)        .ret$control$neta &lt;- sum(.omdf$diag)        .ret$control$ntheta &lt;- length(lower)        .ret$control$nfixed &lt;- sum(fixed)        lower &lt;- c(lower, .omdf$lower)        upper &lt;- c(upper, .omdf$upper)    }    else {        .ret$control$nomega &lt;- 0        .ret$control$neta &lt;- 0        .ret$xType &lt;- -1        .ret$control$ntheta &lt;- length(lower)        .ret$control$nfixed &lt;- sum(fixed)    }    .ret$lower &lt;- lower    .ret$upper &lt;- upper    .ret$thetaIni &lt;- inits$THTA    .scaleC &lt;- double(length(lower))    if (is.null(control$scaleC)) {        .scaleC &lt;- rep(NA_real_, length(lower))    }    else {        .scaleC &lt;- as.double(control$scaleC)        if (length(lower) &gt; length(.scaleC)) {            .scaleC &lt;- c(.scaleC, rep(NA_real_, length(lower) -                 length(.scaleC)))        }        else if (length(lower) &lt; length(.scaleC)) {            .scaleC &lt;- .scaleC[seq(1, length(lower))]            warning("scaleC control option has more options than estimated population parameters, please check.")        }    }    .ret$scaleC &lt;- .scaleC    if (exists("uif", envir = .ret)) {        .ini &lt;- as.data.frame(.ret$uif$ini)[!is.na(.ret$uif$ini$err),             c("est", "err", "ntheta")]        for (.i in seq_along(.ini$err)) {            if (is.na(.ret$scaleC[.ini$ntheta[.i]])) {                if (any(.ini$err[.i] == c("boxCox", "yeoJohnson",                   "pow2", "tbs", "tbsYj"))) {                  .ret$scaleC[.ini$ntheta[.i]] &lt;- 1                }                else if (any(.ini$err[.i] == c("prop", "add",                   "norm", "dnorm", "logn", "dlogn", "lnorm",                   "dlnorm"))) {                  .ret$scaleC[.ini$ntheta[.i]] &lt;- 0.5 * abs(.ini$est[.i])                }            }        }        for (.i in .ini$model$extraProps$powTheta) {            if (is.na(.ret$scaleC[.i]))                 .ret$scaleC[.i] &lt;- 1        }        .ini &lt;- as.data.frame(.ret$uif$ini)        for (.i in .ini$model$extraProps$factorial) {            if (is.na(.ret$scaleC[.i]))                 .ret$scaleC[.i] &lt;- abs(1/digamma(.ini$est[.i] +                   1))        }        for (.i in .ini$model$extraProps$gamma) {            if (is.na(.ret$scaleC[.i]))                 .ret$scaleC[.i] &lt;- abs(1/digamma(.ini$est[.i]))        }        for (.i in .ini$model$extraProps$log) {            if (is.na(.ret$scaleC[.i]))                 .ret$scaleC[.i] &lt;- log(abs(.ini$est[.i])) * abs(.ini$est[.i])        }        for (.i in .ret$logitThetas) {            .b &lt;- .ret$logitThetasLow[.i]            .c &lt;- .ret$logitThetasHi[.i]            .a &lt;- .ini$est[.i]            if (is.na(.ret$scaleC[.i])) {                .ret$scaleC[.i] &lt;- 1 * (-.b + .c) * exp(-.a)/((1 +                   exp(-.a))^2 * (.b + 1 * (-.b + .c)/(1 + exp(-.a))))            }        }    }    names(.ret$thetaIni) &lt;- sprintf("THETA[%d]", seq_along(.ret$thetaIni))    if (is.null(etaMat) &amp; !is.null(control$etaMat)) {        .ret$etaMat &lt;- control$etaMat    }    else {        .ret$etaMat &lt;- etaMat    }    .ret$setupTime &lt;- (proc.time() - .pt)["elapsed"]    if (exists("uif", envir = .ret)) {        .tmp &lt;- .ret$uif$logThetasList        .ret$logThetas &lt;- .tmp[[1]]        .ret$logThetasF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$logitThetasList        .ret$logitThetas &lt;- .tmp[[1]]        .ret$logitThetasF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$logitThetasListLow        .ret$logitThetasLow &lt;- .tmp[[1]]        .ret$logitThetasLowF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$logitThetasListHi        .ret$logitThetasHi &lt;- .tmp[[1]]        .ret$logitThetasHiF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$probitThetasList        .ret$probitThetas &lt;- .tmp[[1]]        .ret$probitThetasF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$probitThetasListLow        .ret$probitThetasLow &lt;- .tmp[[1]]        .ret$probitThetasLowF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$probitThetasListHi        .ret$probitThetasHi &lt;- .tmp[[1]]        .ret$probitThetasHiF &lt;- .tmp[[2]]    }    else {        .ret$logThetasF &lt;- integer(0)        .ret$logitThetasF &lt;- integer(0)        .ret$logitThetasHiF &lt;- numeric(0)        .ret$logitThetasLowF &lt;- numeric(0)        .ret$logitThetas &lt;- integer(0)        .ret$logitThetasHi &lt;- numeric(0)        .ret$logitThetasLow &lt;- numeric(0)        .ret$probitThetasF &lt;- integer(0)        .ret$probitThetasHiF &lt;- numeric(0)        .ret$probitThetasLowF &lt;- numeric(0)        .ret$probitThetas &lt;- integer(0)        .ret$probitThetasHi &lt;- numeric(0)        .ret$probitThetasLow &lt;- numeric(0)    }    if (exists("noLik", envir = .ret)) {        if (!.ret$noLik) {            .ret$.params &lt;- c(sprintf("THETA[%d]", seq_along(.ret$thetaIni)),                 sprintf("ETA[%d]", seq(1, dim(.om0)[1])))            .ret$.thetan &lt;- length(.ret$thetaIni)            .ret$nobs &lt;- sum(data$EVID == 0)        }    }    .ret$control$printTop &lt;- TRUE    .ret$control$nF &lt;- 0    .est0 &lt;- .ret$thetaIni    if (!is.null(.ret$model$pred.nolhs)) {        .ret$control$predNeq &lt;- length(.ret$model$pred.nolhs$state)    }    else {        .ret$control$predNeq &lt;- 0L    }    .fitFun &lt;- function(.ret) {        this.env &lt;- environment()        assign("err", "theta reset", this.env)        while (this.env$err == "theta reset") {            assign("err", "", this.env)            .ret0 &lt;- tryCatch({                foceiFitCpp_(.ret)            }, error = function(e) {                if (regexpr("theta reset", e$message) != -1) {                  assign("zeroOuter", FALSE, this.env)                  assign("zeroGrad", FALSE, this.env)                  if (regexpr("theta reset0", e$message) != -1) {                    assign("zeroGrad", TRUE, this.env)                  }                  else if (regexpr("theta resetZ", e$message) !=                     -1) {                    assign("zeroOuter", TRUE, this.env)                  }                  assign("err", "theta reset", this.env)                }                else {                  assign("err", e$message, this.env)                }            })            if (this.env$err == "theta reset") {                .nm &lt;- names(.ret$thetaIni)                .ret$thetaIni &lt;- setNames(.thetaReset$thetaIni +                   0, .nm)                .ret$rxInv$theta &lt;- .thetaReset$omegaTheta                .ret$control$printTop &lt;- FALSE                .ret$etaMat &lt;- .thetaReset$etaMat                .ret$control$etaMat &lt;- .thetaReset$etaMat                .ret$control$maxInnerIterations &lt;- .thetaReset$maxInnerIterations                .ret$control$nF &lt;- .thetaReset$nF                .ret$control$gillRetC &lt;- .thetaReset$gillRetC                .ret$control$gillRet &lt;- .thetaReset$gillRet                .ret$control$gillRet &lt;- .thetaReset$gillRet                .ret$control$gillDf &lt;- .thetaReset$gillDf                .ret$control$gillDf2 &lt;- .thetaReset$gillDf2                .ret$control$gillErr &lt;- .thetaReset$gillErr                .ret$control$rEps &lt;- .thetaReset$rEps                .ret$control$aEps &lt;- .thetaReset$aEps                .ret$control$rEpsC &lt;- .thetaReset$rEpsC                .ret$control$aEpsC &lt;- .thetaReset$aEpsC                .ret$control$c1 &lt;- .thetaReset$c1                .ret$control$c2 &lt;- .thetaReset$c2                if (this.env$zeroOuter) {                  message("Posthoc reset")                  .ret$control$maxOuterIterations &lt;- 0L                }                else if (this.env$zeroGrad) {                  message("Theta reset (zero gradient values); Switch to bobyqa")                  RxODE::rxReq("minqa")                  .ret$control$outerOptFun &lt;- .bobyqa                  .ret$control$outerOpt &lt;- -1L                }                else {                  message("Theta reset (ETA drift)")                }            }        }        if (this.env$err != "") {            stop(this.env$err)        }        else {            return(.ret0)        }    }    .ret0 &lt;- try(.fitFun(.ret))    .n &lt;- 1    while (inherits(.ret0, "try-error") &amp;&amp; control$maxOuterIterations !=         0 &amp;&amp; .n &lt;= control$nRetries) {        message(sprintf("Restart %s", .n))        .ret$control$nF &lt;- 0        .estNew &lt;- .est0 + 0.2 * .n * abs(.est0) * stats::runif(length(.est0)) -             0.1 * .n        .estNew &lt;- sapply(seq_along(.est0), function(.i) {            if (.ret$thetaFixed[.i]) {                return(.est0[.i])            }            else if (.estNew[.i] &lt; lower[.i]) {                return(lower + (.Machine$double.eps)^(1/7))            }            else if (.estNew[.i] &gt; upper[.i]) {                return(upper - (.Machine$double.eps)^(1/7))            }            else {                return(.estNew[.i])            }        })        .ret$thetaIni &lt;- .estNew        .ret0 &lt;- try(.fitFun(.ret))        .n &lt;- .n + 1    }    if (inherits(.ret0, "try-error"))         stop("Could not fit data.")    .ret &lt;- .ret0    if (exists("parHistData", .ret)) {        .tmp &lt;- .ret$parHistData        .tmp &lt;- .tmp[.tmp$type == "Unscaled", names(.tmp) !=             "type"]        .iter &lt;- .tmp$iter        .tmp &lt;- .tmp[, names(.tmp) != "iter"]        .ret$parHistStacked &lt;- data.frame(stack(.tmp), iter = .iter)        names(.ret$parHistStacked) &lt;- c("val", "par", "iter")        .ret$parHist &lt;- data.frame(iter = .iter, .tmp)    }    if (.mixed) {        .etas &lt;- .ret$ranef        .thetas &lt;- .ret$fixef        .pars &lt;- .Call(`_nlmixr_nlmixrParameters`, .thetas, .etas)        .ret$shrink &lt;- .Call(`_nlmixr_calcShrinkOnly`, .ret$omega,             .pars$eta.lst, length(.etas$ID))        .updateParFixed(.ret)    }    else {        .updateParFixed(.ret)    }    if (!exists("table", .ret)) {        .ret$table &lt;- tableControl()    }    if (control$calcTables) {        .ret &lt;- addTable(.ret, updateObject = "no", keep = keep,             drop = drop, table = .ret$table)    }    .ret})(data = dat, inits = .FoceiInits, PKpars = .pars, model = .mod,     pred = function() {        return(nlmixr_pred)    }, err = uif$error, lower = uif$focei.lower, upper = uif$focei.upper,     fixed = uif$focei.fixed, thetaNames = uif$focei.names, etaNames = uif$eta.names,     control = control, env = env, keep = .keep, drop = .drop): Not all the covariates are in the dataset.</span></div><div class='output co'>#&gt; <span class='message'>Timing stopped at: 8.455 0.377 8.841</span></div><div class='input'><span class='va'>f_nlmixr_dfop_sfo_focei_tc</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/pkg/nlmixr/man/nlmixr.html'>nlmixr</a></span><span class='op'>(</span><span class='va'>f_mmkin_tc</span><span class='op'>[</span><span class='st'>"DFOP-SFO"</span>, <span class='op'>]</span>, est <span class='op'>=</span> <span class='st'>"focei"</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> parameter labels from comments are typically ignored in non-interactive mode</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> Need to run with the source intact to parse comments</span></div><div class='output co'>#&gt; <span class='message'>→ creating full model...</span></div><div class='output co'>#&gt; <span class='message'>→ pruning branches (<span style='color: #262626; background-color: #DADADA;'>`if`</span>/<span style='color: #262626; background-color: #DADADA;'>`else`</span>)...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ loading into <span style='color: #0000BB;'>symengine</span> environment...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ creating full model...</span></div><div class='output co'>#&gt; <span class='message'>→ pruning branches (<span style='color: #262626; background-color: #DADADA;'>`if`</span>/<span style='color: #262626; background-color: #DADADA;'>`else`</span>)...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ loading into <span style='color: #0000BB;'>symengine</span> environment...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ calculate jacobian</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate sensitivities</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate ∂(f)/∂(η)</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate ∂(R²)/∂(η)</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in inner model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in inner model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in EBE model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in EBE model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ compiling inner model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in FD model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in FD model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ compiling EBE model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ compiling events FD model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>Model:</span></div><div class='output co'>#&gt; <span class='message'>cmt(parent);</span>
#&gt; <span class='message'>cmt(A1);</span>
#&gt; <span class='message'>rx_expr_6~ETA[1]+THETA[1];</span>
#&gt; <span class='message'>parent(0)=rx_expr_6;</span>
#&gt; <span class='message'>rx_expr_7~ETA[4]+THETA[4];</span>
#&gt; <span class='message'>rx_expr_8~ETA[6]+THETA[6];</span>
#&gt; <span class='message'>rx_expr_9~ETA[5]+THETA[5];</span>
#&gt; <span class='message'>rx_expr_12~exp(rx_expr_7);</span>
#&gt; <span class='message'>rx_expr_13~exp(rx_expr_9);</span>
#&gt; <span class='message'>rx_expr_15~t*rx_expr_12;</span>
#&gt; <span class='message'>rx_expr_16~t*rx_expr_13;</span>
#&gt; <span class='message'>rx_expr_19~exp(-(rx_expr_8));</span>
#&gt; <span class='message'>rx_expr_21~1+rx_expr_19;</span>
#&gt; <span class='message'>rx_expr_26~1/(rx_expr_21);</span>
#&gt; <span class='message'>rx_expr_28~(rx_expr_26);</span>
#&gt; <span class='message'>rx_expr_29~1-rx_expr_28;</span>
#&gt; <span class='message'>d/dt(parent)=-parent*(exp(rx_expr_7-rx_expr_15)/(rx_expr_21)+exp(rx_expr_9-rx_expr_16)*(rx_expr_29))/(exp(-t*rx_expr_12)/(rx_expr_21)+exp(-t*rx_expr_13)*(rx_expr_29));</span>
#&gt; <span class='message'>rx_expr_10~ETA[2]+THETA[2];</span>
#&gt; <span class='message'>rx_expr_14~exp(rx_expr_10);</span>
#&gt; <span class='message'>d/dt(A1)=-rx_expr_14*A1+parent*f_parent_to_A1*(exp(rx_expr_7-rx_expr_15)/(rx_expr_21)+exp(rx_expr_9-rx_expr_16)*(rx_expr_29))/(exp(-t*rx_expr_12)/(rx_expr_21)+exp(-t*rx_expr_13)*(rx_expr_29));</span>
#&gt; <span class='message'>rx_expr_0~CMT==2;</span>
#&gt; <span class='message'>rx_expr_1~CMT==1;</span>
#&gt; <span class='message'>rx_expr_2~1-(rx_expr_0);</span>
#&gt; <span class='message'>rx_yj_~2*(rx_expr_2)*(rx_expr_1)+2*(rx_expr_0);</span>
#&gt; <span class='message'>rx_expr_3~(rx_expr_0);</span>
#&gt; <span class='message'>rx_expr_5~(rx_expr_2);</span>
#&gt; <span class='message'>rx_expr_20~rx_expr_5*(rx_expr_1);</span>
#&gt; <span class='message'>rx_lambda_~rx_expr_20+rx_expr_3;</span>
#&gt; <span class='message'>rx_hi_~rx_expr_20+rx_expr_3;</span>
#&gt; <span class='message'>rx_low_~0;</span>
#&gt; <span class='message'>rx_expr_4~A1*(rx_expr_0);</span>
#&gt; <span class='message'>rx_expr_11~parent*(rx_expr_2);</span>
#&gt; <span class='message'>rx_expr_24~rx_expr_11*(rx_expr_1);</span>
#&gt; <span class='message'>rx_pred_=(rx_expr_4+rx_expr_24)*(rx_expr_0)+(rx_expr_4+rx_expr_24)*(rx_expr_2)*(rx_expr_1);</span>
#&gt; <span class='message'>rx_expr_17~Rx_pow_di(THETA[8],2);</span>
#&gt; <span class='message'>rx_expr_18~Rx_pow_di(THETA[7],2);</span>
#&gt; <span class='message'>rx_r_=(Rx_pow_di(((rx_expr_4+rx_expr_24)*(rx_expr_0)+(rx_expr_4+rx_expr_24)*(rx_expr_2)*(rx_expr_1)),2)*rx_expr_17+rx_expr_18)*(rx_expr_0)+(rx_expr_17*Rx_pow_di(((rx_expr_4+rx_expr_24)*(rx_expr_1)),2)+rx_expr_18)*(rx_expr_2)*(rx_expr_1);</span>
#&gt; <span class='message'>parent_0=THETA[1];</span>
#&gt; <span class='message'>log_k_A1=THETA[2];</span>
#&gt; <span class='message'>f_parent_qlogis=THETA[3];</span>
#&gt; <span class='message'>log_k1=THETA[4];</span>
#&gt; <span class='message'>log_k2=THETA[5];</span>
#&gt; <span class='message'>g_qlogis=THETA[6];</span>
#&gt; <span class='message'>sigma_low=THETA[7];</span>
#&gt; <span class='message'>rsd_high=THETA[8];</span>
#&gt; <span class='message'>eta.parent_0=ETA[1];</span>
#&gt; <span class='message'>eta.log_k_A1=ETA[2];</span>
#&gt; <span class='message'>eta.f_parent_qlogis=ETA[3];</span>
#&gt; <span class='message'>eta.log_k1=ETA[4];</span>
#&gt; <span class='message'>eta.log_k2=ETA[5];</span>
#&gt; <span class='message'>eta.g_qlogis=ETA[6];</span>
#&gt; <span class='message'>parent_0_model=rx_expr_6;</span>
#&gt; <span class='message'>k_A1=rx_expr_14;</span>
#&gt; <span class='message'>k1=rx_expr_12;</span>
#&gt; <span class='message'>k2=rx_expr_13;</span>
#&gt; <span class='message'>f_parent=1/(1+exp(-(ETA[3]+THETA[3])));</span>
#&gt; <span class='message'>g=1/(rx_expr_21);</span>
#&gt; <span class='message'>tad=tad();</span>
#&gt; <span class='message'>dosenum=dosenum();</span></div><div class='output co'>#&gt; <span class='message'>Needed Covariates:</span></div><div class='output co'>#&gt; <span class='message'>[1] "f_parent_to_A1" "CMT"           </span></div><div class='output co'>#&gt; <span class='error'>Error in (function (data, inits, PKpars, model = NULL, pred = NULL, err = NULL,     lower = -Inf, upper = Inf, fixed = NULL, skipCov = NULL,     control = foceiControl(), thetaNames = NULL, etaNames = NULL,     etaMat = NULL, ..., env = NULL, keep = NULL, drop = NULL) {    set.seed(control$seed)    .pt &lt;- proc.time()    RxODE::.setWarnIdSort(FALSE)    on.exit(RxODE::.setWarnIdSort(TRUE))    loadNamespace("n1qn1")    if (!RxODE::rxIs(control, "foceiControl")) {        control &lt;- do.call(foceiControl, control)    }    if (is.null(env)) {        .ret &lt;- new.env(parent = emptyenv())    }    else {        .ret &lt;- env    }    .ret$origData &lt;- data    .ret$etaNames &lt;- etaNames    .ret$thetaFixed &lt;- fixed    .ret$control &lt;- control    .ret$control$focei.mu.ref &lt;- integer(0)    if (is(model, "RxODE") || is(model, "character")) {        .ret$ODEmodel &lt;- TRUE        if (class(pred) != "function") {            stop("pred must be a function specifying the prediction variables in this model.")        }    }    else {        .ret$ODEmodel &lt;- TRUE        model &lt;- RxODE::rxGetLin(PKpars)        pred &lt;- eval(parse(text = "function(){return(Central);}"))    }    .square &lt;- function(x) x * x    .ret$diagXformInv &lt;- c(sqrt = ".square", log = "exp", identity = "identity")[control$diagXform]    if (is.null(err)) {        err &lt;- eval(parse(text = paste0("function(){err", paste(inits$ERROR[[1]],             collapse = ""), "}")))    }    .covNames &lt;- .parNames &lt;- c()    .ret$adjLik &lt;- control$adjLik    .mixed &lt;- !is.null(inits$OMGA) &amp;&amp; length(inits$OMGA) &gt; 0    if (!exists("noLik", envir = .ret)) {        .atol &lt;- rep(control$atol, length(RxODE::rxModelVars(model)$state))        .rtol &lt;- rep(control$rtol, length(RxODE::rxModelVars(model)$state))        .ssAtol &lt;- rep(control$ssAtol, length(RxODE::rxModelVars(model)$state))        .ssRtol &lt;- rep(control$ssRtol, length(RxODE::rxModelVars(model)$state))        .ret$model &lt;- RxODE::rxSymPySetupPred(model, pred, PKpars,             err, grad = (control$derivMethod == 2L), pred.minus.dv = TRUE,             sum.prod = control$sumProd, theta.derivs = FALSE,             optExpression = control$optExpression, interaction = (control$interaction ==                 1L), only.numeric = !.mixed, run.internal = TRUE,             addProp = control$addProp)        if (!is.null(.ret$model$inner)) {            .atol &lt;- c(.atol, rep(control$atolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                 length(.atol)))            .rtol &lt;- c(.rtol, rep(control$rtolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                 length(.rtol)))            .ret$control$rxControl$atol &lt;- .atol            .ret$control$rxControl$rtol &lt;- .rtol            .ssAtol &lt;- c(.ssAtol, rep(control$ssAtolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                 length(.ssAtol)))            .ssRtol &lt;- c(.ssRtol, rep(control$ssRtolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                 length(.ssRtol)))            .ret$control$rxControl$ssAtol &lt;- .ssAtol            .ret$control$rxControl$ssRtol &lt;- .ssRtol        }        .covNames &lt;- .parNames &lt;- RxODE::rxParams(.ret$model$pred.only)        .covNames &lt;- .covNames[regexpr(rex::rex(start, or("THETA",             "ETA"), "[", numbers, "]", end), .covNames) == -1]        colnames(data) &lt;- sapply(names(data), function(x) {            if (any(x == .covNames)) {                return(x)            }            else {                return(toupper(x))            }        })        .lhs &lt;- c(names(RxODE::rxInits(.ret$model$pred.only)),             RxODE::rxLhs(.ret$model$pred.only))        if (length(.lhs) &gt; 0) {            .covNames &lt;- .covNames[regexpr(rex::rex(start, or(.lhs),                 end), .covNames) == -1]        }        if (length(.covNames) &gt; 0) {            if (!all(.covNames %in% names(data))) {                message("Model:")                RxODE::rxCat(.ret$model$pred.only)                message("Needed Covariates:")                nlmixrPrint(.covNames)                stop("Not all the covariates are in the dataset.")            }            message("Needed Covariates:")            print(.covNames)        }        .extraPars &lt;- .ret$model$extra.pars    }    else {        if (.ret$noLik) {            .atol &lt;- rep(control$atol, length(RxODE::rxModelVars(model)$state))            .rtol &lt;- rep(control$rtol, length(RxODE::rxModelVars(model)$state))            .ret$model &lt;- RxODE::rxSymPySetupPred(model, pred,                 PKpars, err, grad = FALSE, pred.minus.dv = TRUE,                 sum.prod = control$sumProd, theta.derivs = FALSE,                 optExpression = control$optExpression, run.internal = TRUE,                 only.numeric = TRUE, addProp = control$addProp)            if (!is.null(.ret$model$inner)) {                .atol &lt;- c(.atol, rep(control$atolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                   length(.atol)))                .rtol &lt;- c(.rtol, rep(control$rtolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                   length(.rtol)))                .ret$control$rxControl$atol &lt;- .atol                .ret$control$rxControl$rtol &lt;- .rtol            }            .covNames &lt;- .parNames &lt;- RxODE::rxParams(.ret$model$pred.only)            .covNames &lt;- .covNames[regexpr(rex::rex(start, or("THETA",                 "ETA"), "[", numbers, "]", end), .covNames) ==                 -1]            colnames(data) &lt;- sapply(names(data), function(x) {                if (any(x == .covNames)) {                  return(x)                }                else {                  return(toupper(x))                }            })            .lhs &lt;- c(names(RxODE::rxInits(.ret$model$pred.only)),                 RxODE::rxLhs(.ret$model$pred.only))            if (length(.lhs) &gt; 0) {                .covNames &lt;- .covNames[regexpr(rex::rex(start,                   or(.lhs), end), .covNames) == -1]            }            if (length(.covNames) &gt; 0) {                if (!all(.covNames %in% names(data))) {                  message("Model:")                  RxODE::rxCat(.ret$model$pred.only)                  message("Needed Covariates:")                  nlmixrPrint(.covNames)                  stop("Not all the covariates are in the dataset.")                }                message("Needed Covariates:")                print(.covNames)            }            .extraPars &lt;- .ret$model$extra.pars        }        else {            .extraPars &lt;- NULL        }    }    .ret$skipCov &lt;- skipCov    if (is.null(skipCov)) {        if (is.null(fixed)) {            .tmp &lt;- rep(FALSE, length(inits$THTA))        }        else {            if (length(fixed) &lt; length(inits$THTA)) {                .tmp &lt;- c(fixed, rep(FALSE, length(inits$THTA) -                   length(fixed)))            }            else {                .tmp &lt;- fixed[1:length(inits$THTA)]            }        }        if (exists("uif", envir = .ret)) {            .uifErr &lt;- .ret$uif$ini$err[!is.na(.ret$uif$ini$ntheta)]            .uifErr &lt;- sapply(.uifErr, function(x) {                if (is.na(x)) {                  return(FALSE)                }                return(!any(x == c("pow2", "tbs", "tbsYj")))            })            .tmp &lt;- (.tmp | .uifErr)        }        .ret$skipCov &lt;- c(.tmp, rep(TRUE, length(.extraPars)))        .ret$control$focei.mu.ref &lt;- .ret$uif$focei.mu.ref    }    if (is.null(.extraPars)) {        .nms &lt;- c(sprintf("THETA[%s]", seq_along(inits$THTA)))    }    else {        .nms &lt;- c(sprintf("THETA[%s]", seq_along(inits$THTA)),             sprintf("ERR[%s]", seq_along(.extraPars)))    }    if (!is.null(thetaNames) &amp;&amp; (length(inits$THTA) + length(.extraPars)) ==         length(thetaNames)) {        .nms &lt;- thetaNames    }    .ret$thetaNames &lt;- .nms    .thetaReset$thetaNames &lt;- .nms    if (length(lower) == 1) {        lower &lt;- rep(lower, length(inits$THTA))    }    else if (length(lower) != length(inits$THTA)) {        print(inits$THTA)        print(lower)        stop("Lower must be a single constant for all the THETA lower bounds, or match the dimension of THETA.")    }    if (length(upper) == 1) {        upper &lt;- rep(upper, length(inits$THTA))    }    else if (length(lower) != length(inits$THTA)) {        stop("Upper must be a single constant for all the THETA lower bounds, or match the dimension of THETA.")    }    if (!is.null(.extraPars)) {        .ret$model$extra.pars &lt;- eval(call(control$diagXform,             .ret$model$extra.pars))        if (length(.ret$model$extra.pars) &gt; 0) {            inits$THTA &lt;- c(inits$THTA, .ret$model$extra.pars)            .lowerErr &lt;- rep(control$atol[1] * 10, length(.ret$model$extra.pars))            .upperErr &lt;- rep(Inf, length(.ret$model$extra.pars))            lower &lt;- c(lower, .lowerErr)            upper &lt;- c(upper, .upperErr)        }    }    if (is.null(data$ID))         stop("\"ID\" not found in data")    if (is.null(data$DV))         stop("\"DV\" not found in data")    if (is.null(data$EVID))         data$EVID &lt;- 0    if (is.null(data$AMT))         data$AMT &lt;- 0    for (.v in c("TIME", "AMT", "DV", .covNames)) {        data[[.v]] &lt;- as.double(data[[.v]])    }    .ret$dataSav &lt;- data    .ds &lt;- data[data$EVID != 0 &amp; data$EVID != 2, c("ID", "TIME",         "AMT", "EVID", .covNames)]    .w &lt;- which(tolower(names(data)) == "limit")    .limitName &lt;- NULL    if (length(.w) == 1L) {        .limitName &lt;- names(data)[.w]    }    .censName &lt;- NULL    .w &lt;- which(tolower(names(data)) == "cens")    if (length(.w) == 1L) {        .censName &lt;- names(data[.w])    }    data &lt;- data[data$EVID == 0 | data$EVID == 2, c("ID", "TIME",         "DV", "EVID", .covNames, .limitName, .censName)]    .w &lt;- which(!(names(.ret$dataSav) %in% c(.covNames, keep)))    names(.ret$dataSav)[.w] &lt;- tolower(names(.ret$dataSav[.w]))    if (.mixed) {        .lh &lt;- .parseOM(inits$OMGA)        .nlh &lt;- sapply(.lh, length)        .osplt &lt;- rep(1:length(.lh), .nlh)        .lini &lt;- list(inits$THTA, unlist(.lh))        .nlini &lt;- sapply(.lini, length)        .nsplt &lt;- rep(1:length(.lini), .nlini)        .om0 &lt;- .genOM(.lh)        if (length(etaNames) == dim(.om0)[1]) {            .ret$etaNames &lt;- .ret$etaNames        }        else {            .ret$etaNames &lt;- sprintf("ETA[%d]", seq(1, dim(.om0)[1]))        }        .ret$rxInv &lt;- RxODE::rxSymInvCholCreate(mat = .om0, diag.xform = control$diagXform)        .ret$xType &lt;- .ret$rxInv$xType        .om0a &lt;- .om0        .om0a &lt;- .om0a/control$diagOmegaBoundLower        .om0b &lt;- .om0        .om0b &lt;- .om0b * control$diagOmegaBoundUpper        .om0a &lt;- RxODE::rxSymInvCholCreate(mat = .om0a, diag.xform = control$diagXform)        .om0b &lt;- RxODE::rxSymInvCholCreate(mat = .om0b, diag.xform = control$diagXform)        .omdf &lt;- data.frame(a = .om0a$theta, m = .ret$rxInv$theta,             b = .om0b$theta, diag = .om0a$theta.diag)        .omdf$lower &lt;- with(.omdf, ifelse(a &gt; b, b, a))        .omdf$lower &lt;- with(.omdf, ifelse(lower == m, -Inf, lower))        .omdf$lower &lt;- with(.omdf, ifelse(!diag, -Inf, lower))        .omdf$upper &lt;- with(.omdf, ifelse(a &lt; b, b, a))        .omdf$upper &lt;- with(.omdf, ifelse(upper == m, Inf, upper))        .omdf$upper &lt;- with(.omdf, ifelse(!diag, Inf, upper))        .ret$control$nomega &lt;- length(.omdf$lower)        .ret$control$neta &lt;- sum(.omdf$diag)        .ret$control$ntheta &lt;- length(lower)        .ret$control$nfixed &lt;- sum(fixed)        lower &lt;- c(lower, .omdf$lower)        upper &lt;- c(upper, .omdf$upper)    }    else {        .ret$control$nomega &lt;- 0        .ret$control$neta &lt;- 0        .ret$xType &lt;- -1        .ret$control$ntheta &lt;- length(lower)        .ret$control$nfixed &lt;- sum(fixed)    }    .ret$lower &lt;- lower    .ret$upper &lt;- upper    .ret$thetaIni &lt;- inits$THTA    .scaleC &lt;- double(length(lower))    if (is.null(control$scaleC)) {        .scaleC &lt;- rep(NA_real_, length(lower))    }    else {        .scaleC &lt;- as.double(control$scaleC)        if (length(lower) &gt; length(.scaleC)) {            .scaleC &lt;- c(.scaleC, rep(NA_real_, length(lower) -                 length(.scaleC)))        }        else if (length(lower) &lt; length(.scaleC)) {            .scaleC &lt;- .scaleC[seq(1, length(lower))]            warning("scaleC control option has more options than estimated population parameters, please check.")        }    }    .ret$scaleC &lt;- .scaleC    if (exists("uif", envir = .ret)) {        .ini &lt;- as.data.frame(.ret$uif$ini)[!is.na(.ret$uif$ini$err),             c("est", "err", "ntheta")]        for (.i in seq_along(.ini$err)) {            if (is.na(.ret$scaleC[.ini$ntheta[.i]])) {                if (any(.ini$err[.i] == c("boxCox", "yeoJohnson",                   "pow2", "tbs", "tbsYj"))) {                  .ret$scaleC[.ini$ntheta[.i]] &lt;- 1                }                else if (any(.ini$err[.i] == c("prop", "add",                   "norm", "dnorm", "logn", "dlogn", "lnorm",                   "dlnorm"))) {                  .ret$scaleC[.ini$ntheta[.i]] &lt;- 0.5 * abs(.ini$est[.i])                }            }        }        for (.i in .ini$model$extraProps$powTheta) {            if (is.na(.ret$scaleC[.i]))                 .ret$scaleC[.i] &lt;- 1        }        .ini &lt;- as.data.frame(.ret$uif$ini)        for (.i in .ini$model$extraProps$factorial) {            if (is.na(.ret$scaleC[.i]))                 .ret$scaleC[.i] &lt;- abs(1/digamma(.ini$est[.i] +                   1))        }        for (.i in .ini$model$extraProps$gamma) {            if (is.na(.ret$scaleC[.i]))                 .ret$scaleC[.i] &lt;- abs(1/digamma(.ini$est[.i]))        }        for (.i in .ini$model$extraProps$log) {            if (is.na(.ret$scaleC[.i]))                 .ret$scaleC[.i] &lt;- log(abs(.ini$est[.i])) * abs(.ini$est[.i])        }        for (.i in .ret$logitThetas) {            .b &lt;- .ret$logitThetasLow[.i]            .c &lt;- .ret$logitThetasHi[.i]            .a &lt;- .ini$est[.i]            if (is.na(.ret$scaleC[.i])) {                .ret$scaleC[.i] &lt;- 1 * (-.b + .c) * exp(-.a)/((1 +                   exp(-.a))^2 * (.b + 1 * (-.b + .c)/(1 + exp(-.a))))            }        }    }    names(.ret$thetaIni) &lt;- sprintf("THETA[%d]", seq_along(.ret$thetaIni))    if (is.null(etaMat) &amp; !is.null(control$etaMat)) {        .ret$etaMat &lt;- control$etaMat    }    else {        .ret$etaMat &lt;- etaMat    }    .ret$setupTime &lt;- (proc.time() - .pt)["elapsed"]    if (exists("uif", envir = .ret)) {        .tmp &lt;- .ret$uif$logThetasList        .ret$logThetas &lt;- .tmp[[1]]        .ret$logThetasF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$logitThetasList        .ret$logitThetas &lt;- .tmp[[1]]        .ret$logitThetasF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$logitThetasListLow        .ret$logitThetasLow &lt;- .tmp[[1]]        .ret$logitThetasLowF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$logitThetasListHi        .ret$logitThetasHi &lt;- .tmp[[1]]        .ret$logitThetasHiF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$probitThetasList        .ret$probitThetas &lt;- .tmp[[1]]        .ret$probitThetasF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$probitThetasListLow        .ret$probitThetasLow &lt;- .tmp[[1]]        .ret$probitThetasLowF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$probitThetasListHi        .ret$probitThetasHi &lt;- .tmp[[1]]        .ret$probitThetasHiF &lt;- .tmp[[2]]    }    else {        .ret$logThetasF &lt;- integer(0)        .ret$logitThetasF &lt;- integer(0)        .ret$logitThetasHiF &lt;- numeric(0)        .ret$logitThetasLowF &lt;- numeric(0)        .ret$logitThetas &lt;- integer(0)        .ret$logitThetasHi &lt;- numeric(0)        .ret$logitThetasLow &lt;- numeric(0)        .ret$probitThetasF &lt;- integer(0)        .ret$probitThetasHiF &lt;- numeric(0)        .ret$probitThetasLowF &lt;- numeric(0)        .ret$probitThetas &lt;- integer(0)        .ret$probitThetasHi &lt;- numeric(0)        .ret$probitThetasLow &lt;- numeric(0)    }    if (exists("noLik", envir = .ret)) {        if (!.ret$noLik) {            .ret$.params &lt;- c(sprintf("THETA[%d]", seq_along(.ret$thetaIni)),                 sprintf("ETA[%d]", seq(1, dim(.om0)[1])))            .ret$.thetan &lt;- length(.ret$thetaIni)            .ret$nobs &lt;- sum(data$EVID == 0)        }    }    .ret$control$printTop &lt;- TRUE    .ret$control$nF &lt;- 0    .est0 &lt;- .ret$thetaIni    if (!is.null(.ret$model$pred.nolhs)) {        .ret$control$predNeq &lt;- length(.ret$model$pred.nolhs$state)    }    else {        .ret$control$predNeq &lt;- 0L    }    .fitFun &lt;- function(.ret) {        this.env &lt;- environment()        assign("err", "theta reset", this.env)        while (this.env$err == "theta reset") {            assign("err", "", this.env)            .ret0 &lt;- tryCatch({                foceiFitCpp_(.ret)            }, error = function(e) {                if (regexpr("theta reset", e$message) != -1) {                  assign("zeroOuter", FALSE, this.env)                  assign("zeroGrad", FALSE, this.env)                  if (regexpr("theta reset0", e$message) != -1) {                    assign("zeroGrad", TRUE, this.env)                  }                  else if (regexpr("theta resetZ", e$message) !=                     -1) {                    assign("zeroOuter", TRUE, this.env)                  }                  assign("err", "theta reset", this.env)                }                else {                  assign("err", e$message, this.env)                }            })            if (this.env$err == "theta reset") {                .nm &lt;- names(.ret$thetaIni)                .ret$thetaIni &lt;- setNames(.thetaReset$thetaIni +                   0, .nm)                .ret$rxInv$theta &lt;- .thetaReset$omegaTheta                .ret$control$printTop &lt;- FALSE                .ret$etaMat &lt;- .thetaReset$etaMat                .ret$control$etaMat &lt;- .thetaReset$etaMat                .ret$control$maxInnerIterations &lt;- .thetaReset$maxInnerIterations                .ret$control$nF &lt;- .thetaReset$nF                .ret$control$gillRetC &lt;- .thetaReset$gillRetC                .ret$control$gillRet &lt;- .thetaReset$gillRet                .ret$control$gillRet &lt;- .thetaReset$gillRet                .ret$control$gillDf &lt;- .thetaReset$gillDf                .ret$control$gillDf2 &lt;- .thetaReset$gillDf2                .ret$control$gillErr &lt;- .thetaReset$gillErr                .ret$control$rEps &lt;- .thetaReset$rEps                .ret$control$aEps &lt;- .thetaReset$aEps                .ret$control$rEpsC &lt;- .thetaReset$rEpsC                .ret$control$aEpsC &lt;- .thetaReset$aEpsC                .ret$control$c1 &lt;- .thetaReset$c1                .ret$control$c2 &lt;- .thetaReset$c2                if (this.env$zeroOuter) {                  message("Posthoc reset")                  .ret$control$maxOuterIterations &lt;- 0L                }                else if (this.env$zeroGrad) {                  message("Theta reset (zero gradient values); Switch to bobyqa")                  RxODE::rxReq("minqa")                  .ret$control$outerOptFun &lt;- .bobyqa                  .ret$control$outerOpt &lt;- -1L                }                else {                  message("Theta reset (ETA drift)")                }            }        }        if (this.env$err != "") {            stop(this.env$err)        }        else {            return(.ret0)        }    }    .ret0 &lt;- try(.fitFun(.ret))    .n &lt;- 1    while (inherits(.ret0, "try-error") &amp;&amp; control$maxOuterIterations !=         0 &amp;&amp; .n &lt;= control$nRetries) {        message(sprintf("Restart %s", .n))        .ret$control$nF &lt;- 0        .estNew &lt;- .est0 + 0.2 * .n * abs(.est0) * stats::runif(length(.est0)) -             0.1 * .n        .estNew &lt;- sapply(seq_along(.est0), function(.i) {            if (.ret$thetaFixed[.i]) {                return(.est0[.i])            }            else if (.estNew[.i] &lt; lower[.i]) {                return(lower + (.Machine$double.eps)^(1/7))            }            else if (.estNew[.i] &gt; upper[.i]) {                return(upper - (.Machine$double.eps)^(1/7))            }            else {                return(.estNew[.i])            }        })        .ret$thetaIni &lt;- .estNew        .ret0 &lt;- try(.fitFun(.ret))        .n &lt;- .n + 1    }    if (inherits(.ret0, "try-error"))         stop("Could not fit data.")    .ret &lt;- .ret0    if (exists("parHistData", .ret)) {        .tmp &lt;- .ret$parHistData        .tmp &lt;- .tmp[.tmp$type == "Unscaled", names(.tmp) !=             "type"]        .iter &lt;- .tmp$iter        .tmp &lt;- .tmp[, names(.tmp) != "iter"]        .ret$parHistStacked &lt;- data.frame(stack(.tmp), iter = .iter)        names(.ret$parHistStacked) &lt;- c("val", "par", "iter")        .ret$parHist &lt;- data.frame(iter = .iter, .tmp)    }    if (.mixed) {        .etas &lt;- .ret$ranef        .thetas &lt;- .ret$fixef        .pars &lt;- .Call(`_nlmixr_nlmixrParameters`, .thetas, .etas)        .ret$shrink &lt;- .Call(`_nlmixr_calcShrinkOnly`, .ret$omega,             .pars$eta.lst, length(.etas$ID))        .updateParFixed(.ret)    }    else {        .updateParFixed(.ret)    }    if (!exists("table", .ret)) {        .ret$table &lt;- tableControl()    }    if (control$calcTables) {        .ret &lt;- addTable(.ret, updateObject = "no", keep = keep,             drop = drop, table = .ret$table)    }    .ret})(data = dat, inits = .FoceiInits, PKpars = .pars, model = .mod,     pred = function() {        return(nlmixr_pred)    }, err = uif$error, lower = uif$focei.lower, upper = uif$focei.upper,     fixed = uif$focei.fixed, thetaNames = uif$focei.names, etaNames = uif$eta.names,     control = control, env = env, keep = .keep, drop = .drop): Not all the covariates are in the dataset.</span></div><div class='output co'>#&gt; <span class='message'>Timing stopped at: 17.73 0.679 18.41</span></div><div class='input'>
<span class='co'># Two-component error by variable is possible with both estimation methods</span>
<span class='co'># Variance by variable is supported by 'saem' and 'focei'</span>
<span class='va'>f_nlmixr_fomc_sfo_saem_obs_tc</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/pkg/nlmixr/man/nlmixr.html'>nlmixr</a></span><span class='op'>(</span><span class='va'>f_mmkin_tc</span><span class='op'>[</span><span class='st'>"FOMC-SFO"</span>, <span class='op'>]</span>, est <span class='op'>=</span> <span class='st'>"saem"</span>,
  error_model <span class='op'>=</span> <span class='st'>"obs_tc"</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> parameter labels from comments are typically ignored in non-interactive mode</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> Need to run with the source intact to parse comments</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='error'>Error in configsaem(model = model, data = dat, inits = inits, mcmc = .mcmc,     ODEopt = .ODEopt, seed = .seed, distribution = .dist, DEBUG = .DEBUG,     addProp = .addProp, tol = .tol, itmax = .itmax, type = .type,     powRange = .powRange, lambdaRange = .lambdaRange): covariate(s) not found: f_parent_to_A1</span></div><div class='output co'>#&gt; <span class='message'>Timing stopped at: 0.775 0.024 0.799</span></div><div class='input'><span class='va'>f_nlmixr_fomc_sfo_focei_obs_tc</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/pkg/nlmixr/man/nlmixr.html'>nlmixr</a></span><span class='op'>(</span><span class='va'>f_mmkin_tc</span><span class='op'>[</span><span class='st'>"FOMC-SFO"</span>, <span class='op'>]</span>, est <span class='op'>=</span> <span class='st'>"focei"</span>,
  error_model <span class='op'>=</span> <span class='st'>"obs_tc"</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> parameter labels from comments are typically ignored in non-interactive mode</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> Need to run with the source intact to parse comments</span></div><div class='output co'>#&gt; <span class='message'>→ creating full model...</span></div><div class='output co'>#&gt; <span class='message'>→ pruning branches (<span style='color: #262626; background-color: #DADADA;'>`if`</span>/<span style='color: #262626; background-color: #DADADA;'>`else`</span>)...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ loading into <span style='color: #0000BB;'>symengine</span> environment...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ creating full model...</span></div><div class='output co'>#&gt; <span class='message'>→ pruning branches (<span style='color: #262626; background-color: #DADADA;'>`if`</span>/<span style='color: #262626; background-color: #DADADA;'>`else`</span>)...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ loading into <span style='color: #0000BB;'>symengine</span> environment...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ calculate jacobian</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate sensitivities</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate ∂(f)/∂(η)</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate ∂(R²)/∂(η)</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in inner model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in inner model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in EBE model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in EBE model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ compiling inner model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in FD model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in FD model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ compiling EBE model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ compiling events FD model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>Model:</span></div><div class='output co'>#&gt; <span class='message'>cmt(parent);</span>
#&gt; <span class='message'>cmt(A1);</span>
#&gt; <span class='message'>rx_expr_6~ETA[1]+THETA[1];</span>
#&gt; <span class='message'>parent(0)=rx_expr_6;</span>
#&gt; <span class='message'>rx_expr_7~ETA[4]+THETA[4];</span>
#&gt; <span class='message'>rx_expr_8~ETA[5]+THETA[5];</span>
#&gt; <span class='message'>rx_expr_12~exp(-(rx_expr_8));</span>
#&gt; <span class='message'>rx_expr_14~t*rx_expr_12;</span>
#&gt; <span class='message'>rx_expr_15~1+rx_expr_14;</span>
#&gt; <span class='message'>rx_expr_17~rx_expr_7-(rx_expr_8);</span>
#&gt; <span class='message'>rx_expr_19~exp(rx_expr_17);</span>
#&gt; <span class='message'>d/dt(parent)=-rx_expr_19*parent/(rx_expr_15);</span>
#&gt; <span class='message'>rx_expr_9~ETA[2]+THETA[2];</span>
#&gt; <span class='message'>rx_expr_11~exp(rx_expr_9);</span>
#&gt; <span class='message'>d/dt(A1)=-rx_expr_11*A1+rx_expr_19*parent*f_parent_to_A1/(rx_expr_15);</span>
#&gt; <span class='message'>rx_expr_0~CMT==2;</span>
#&gt; <span class='message'>rx_expr_1~CMT==1;</span>
#&gt; <span class='message'>rx_expr_2~1-(rx_expr_0);</span>
#&gt; <span class='message'>rx_yj_~2*(rx_expr_2)*(rx_expr_1)+2*(rx_expr_0);</span>
#&gt; <span class='message'>rx_expr_3~(rx_expr_0);</span>
#&gt; <span class='message'>rx_expr_5~(rx_expr_2);</span>
#&gt; <span class='message'>rx_expr_13~rx_expr_5*(rx_expr_1);</span>
#&gt; <span class='message'>rx_lambda_~rx_expr_13+rx_expr_3;</span>
#&gt; <span class='message'>rx_hi_~rx_expr_13+rx_expr_3;</span>
#&gt; <span class='message'>rx_low_~0;</span>
#&gt; <span class='message'>rx_expr_4~A1*(rx_expr_0);</span>
#&gt; <span class='message'>rx_expr_10~parent*(rx_expr_2);</span>
#&gt; <span class='message'>rx_expr_16~rx_expr_10*(rx_expr_1);</span>
#&gt; <span class='message'>rx_pred_=(rx_expr_4+rx_expr_16)*(rx_expr_0)+(rx_expr_4+rx_expr_16)*(rx_expr_2)*(rx_expr_1);</span>
#&gt; <span class='message'>rx_r_=(Rx_pow_di(((rx_expr_4+rx_expr_16)*(rx_expr_0)+(rx_expr_4+rx_expr_16)*(rx_expr_2)*(rx_expr_1)),2)*Rx_pow_di(THETA[9],2)+Rx_pow_di(THETA[8],2))*(rx_expr_0)+(Rx_pow_di(THETA[7],2)*Rx_pow_di(((rx_expr_4+rx_expr_16)*(rx_expr_1)),2)+Rx_pow_di(THETA[6],2))*(rx_expr_2)*(rx_expr_1);</span>
#&gt; <span class='message'>parent_0=THETA[1];</span>
#&gt; <span class='message'>log_k_A1=THETA[2];</span>
#&gt; <span class='message'>f_parent_qlogis=THETA[3];</span>
#&gt; <span class='message'>log_alpha=THETA[4];</span>
#&gt; <span class='message'>log_beta=THETA[5];</span>
#&gt; <span class='message'>sigma_low_parent=THETA[6];</span>
#&gt; <span class='message'>rsd_high_parent=THETA[7];</span>
#&gt; <span class='message'>sigma_low_A1=THETA[8];</span>
#&gt; <span class='message'>rsd_high_A1=THETA[9];</span>
#&gt; <span class='message'>eta.parent_0=ETA[1];</span>
#&gt; <span class='message'>eta.log_k_A1=ETA[2];</span>
#&gt; <span class='message'>eta.f_parent_qlogis=ETA[3];</span>
#&gt; <span class='message'>eta.log_alpha=ETA[4];</span>
#&gt; <span class='message'>eta.log_beta=ETA[5];</span>
#&gt; <span class='message'>parent_0_model=rx_expr_6;</span>
#&gt; <span class='message'>k_A1=rx_expr_11;</span>
#&gt; <span class='message'>alpha=exp(rx_expr_7);</span>
#&gt; <span class='message'>beta=exp(rx_expr_8);</span>
#&gt; <span class='message'>f_parent=1/(1+exp(-(ETA[3]+THETA[3])));</span>
#&gt; <span class='message'>tad=tad();</span>
#&gt; <span class='message'>dosenum=dosenum();</span></div><div class='output co'>#&gt; <span class='message'>Needed Covariates:</span></div><div class='output co'>#&gt; <span class='message'>[1] "f_parent_to_A1" "CMT"           </span></div><div class='output co'>#&gt; <span class='error'>Error in (function (data, inits, PKpars, model = NULL, pred = NULL, err = NULL,     lower = -Inf, upper = Inf, fixed = NULL, skipCov = NULL,     control = foceiControl(), thetaNames = NULL, etaNames = NULL,     etaMat = NULL, ..., env = NULL, keep = NULL, drop = NULL) {    set.seed(control$seed)    .pt &lt;- proc.time()    RxODE::.setWarnIdSort(FALSE)    on.exit(RxODE::.setWarnIdSort(TRUE))    loadNamespace("n1qn1")    if (!RxODE::rxIs(control, "foceiControl")) {        control &lt;- do.call(foceiControl, control)    }    if (is.null(env)) {        .ret &lt;- new.env(parent = emptyenv())    }    else {        .ret &lt;- env    }    .ret$origData &lt;- data    .ret$etaNames &lt;- etaNames    .ret$thetaFixed &lt;- fixed    .ret$control &lt;- control    .ret$control$focei.mu.ref &lt;- integer(0)    if (is(model, "RxODE") || is(model, "character")) {        .ret$ODEmodel &lt;- TRUE        if (class(pred) != "function") {            stop("pred must be a function specifying the prediction variables in this model.")        }    }    else {        .ret$ODEmodel &lt;- TRUE        model &lt;- RxODE::rxGetLin(PKpars)        pred &lt;- eval(parse(text = "function(){return(Central);}"))    }    .square &lt;- function(x) x * x    .ret$diagXformInv &lt;- c(sqrt = ".square", log = "exp", identity = "identity")[control$diagXform]    if (is.null(err)) {        err &lt;- eval(parse(text = paste0("function(){err", paste(inits$ERROR[[1]],             collapse = ""), "}")))    }    .covNames &lt;- .parNames &lt;- c()    .ret$adjLik &lt;- control$adjLik    .mixed &lt;- !is.null(inits$OMGA) &amp;&amp; length(inits$OMGA) &gt; 0    if (!exists("noLik", envir = .ret)) {        .atol &lt;- rep(control$atol, length(RxODE::rxModelVars(model)$state))        .rtol &lt;- rep(control$rtol, length(RxODE::rxModelVars(model)$state))        .ssAtol &lt;- rep(control$ssAtol, length(RxODE::rxModelVars(model)$state))        .ssRtol &lt;- rep(control$ssRtol, length(RxODE::rxModelVars(model)$state))        .ret$model &lt;- RxODE::rxSymPySetupPred(model, pred, PKpars,             err, grad = (control$derivMethod == 2L), pred.minus.dv = TRUE,             sum.prod = control$sumProd, theta.derivs = FALSE,             optExpression = control$optExpression, interaction = (control$interaction ==                 1L), only.numeric = !.mixed, run.internal = TRUE,             addProp = control$addProp)        if (!is.null(.ret$model$inner)) {            .atol &lt;- c(.atol, rep(control$atolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                 length(.atol)))            .rtol &lt;- c(.rtol, rep(control$rtolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                 length(.rtol)))            .ret$control$rxControl$atol &lt;- .atol            .ret$control$rxControl$rtol &lt;- .rtol            .ssAtol &lt;- c(.ssAtol, rep(control$ssAtolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                 length(.ssAtol)))            .ssRtol &lt;- c(.ssRtol, rep(control$ssRtolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                 length(.ssRtol)))            .ret$control$rxControl$ssAtol &lt;- .ssAtol            .ret$control$rxControl$ssRtol &lt;- .ssRtol        }        .covNames &lt;- .parNames &lt;- RxODE::rxParams(.ret$model$pred.only)        .covNames &lt;- .covNames[regexpr(rex::rex(start, or("THETA",             "ETA"), "[", numbers, "]", end), .covNames) == -1]        colnames(data) &lt;- sapply(names(data), function(x) {            if (any(x == .covNames)) {                return(x)            }            else {                return(toupper(x))            }        })        .lhs &lt;- c(names(RxODE::rxInits(.ret$model$pred.only)),             RxODE::rxLhs(.ret$model$pred.only))        if (length(.lhs) &gt; 0) {            .covNames &lt;- .covNames[regexpr(rex::rex(start, or(.lhs),                 end), .covNames) == -1]        }        if (length(.covNames) &gt; 0) {            if (!all(.covNames %in% names(data))) {                message("Model:")                RxODE::rxCat(.ret$model$pred.only)                message("Needed Covariates:")                nlmixrPrint(.covNames)                stop("Not all the covariates are in the dataset.")            }            message("Needed Covariates:")            print(.covNames)        }        .extraPars &lt;- .ret$model$extra.pars    }    else {        if (.ret$noLik) {            .atol &lt;- rep(control$atol, length(RxODE::rxModelVars(model)$state))            .rtol &lt;- rep(control$rtol, length(RxODE::rxModelVars(model)$state))            .ret$model &lt;- RxODE::rxSymPySetupPred(model, pred,                 PKpars, err, grad = FALSE, pred.minus.dv = TRUE,                 sum.prod = control$sumProd, theta.derivs = FALSE,                 optExpression = control$optExpression, run.internal = TRUE,                 only.numeric = TRUE, addProp = control$addProp)            if (!is.null(.ret$model$inner)) {                .atol &lt;- c(.atol, rep(control$atolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                   length(.atol)))                .rtol &lt;- c(.rtol, rep(control$rtolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                   length(.rtol)))                .ret$control$rxControl$atol &lt;- .atol                .ret$control$rxControl$rtol &lt;- .rtol            }            .covNames &lt;- .parNames &lt;- RxODE::rxParams(.ret$model$pred.only)            .covNames &lt;- .covNames[regexpr(rex::rex(start, or("THETA",                 "ETA"), "[", numbers, "]", end), .covNames) ==                 -1]            colnames(data) &lt;- sapply(names(data), function(x) {                if (any(x == .covNames)) {                  return(x)                }                else {                  return(toupper(x))                }            })            .lhs &lt;- c(names(RxODE::rxInits(.ret$model$pred.only)),                 RxODE::rxLhs(.ret$model$pred.only))            if (length(.lhs) &gt; 0) {                .covNames &lt;- .covNames[regexpr(rex::rex(start,                   or(.lhs), end), .covNames) == -1]            }            if (length(.covNames) &gt; 0) {                if (!all(.covNames %in% names(data))) {                  message("Model:")                  RxODE::rxCat(.ret$model$pred.only)                  message("Needed Covariates:")                  nlmixrPrint(.covNames)                  stop("Not all the covariates are in the dataset.")                }                message("Needed Covariates:")                print(.covNames)            }            .extraPars &lt;- .ret$model$extra.pars        }        else {            .extraPars &lt;- NULL        }    }    .ret$skipCov &lt;- skipCov    if (is.null(skipCov)) {        if (is.null(fixed)) {            .tmp &lt;- rep(FALSE, length(inits$THTA))        }        else {            if (length(fixed) &lt; length(inits$THTA)) {                .tmp &lt;- c(fixed, rep(FALSE, length(inits$THTA) -                   length(fixed)))            }            else {                .tmp &lt;- fixed[1:length(inits$THTA)]            }        }        if (exists("uif", envir = .ret)) {            .uifErr &lt;- .ret$uif$ini$err[!is.na(.ret$uif$ini$ntheta)]            .uifErr &lt;- sapply(.uifErr, function(x) {                if (is.na(x)) {                  return(FALSE)                }                return(!any(x == c("pow2", "tbs", "tbsYj")))            })            .tmp &lt;- (.tmp | .uifErr)        }        .ret$skipCov &lt;- c(.tmp, rep(TRUE, length(.extraPars)))        .ret$control$focei.mu.ref &lt;- .ret$uif$focei.mu.ref    }    if (is.null(.extraPars)) {        .nms &lt;- c(sprintf("THETA[%s]", seq_along(inits$THTA)))    }    else {        .nms &lt;- c(sprintf("THETA[%s]", seq_along(inits$THTA)),             sprintf("ERR[%s]", seq_along(.extraPars)))    }    if (!is.null(thetaNames) &amp;&amp; (length(inits$THTA) + length(.extraPars)) ==         length(thetaNames)) {        .nms &lt;- thetaNames    }    .ret$thetaNames &lt;- .nms    .thetaReset$thetaNames &lt;- .nms    if (length(lower) == 1) {        lower &lt;- rep(lower, length(inits$THTA))    }    else if (length(lower) != length(inits$THTA)) {        print(inits$THTA)        print(lower)        stop("Lower must be a single constant for all the THETA lower bounds, or match the dimension of THETA.")    }    if (length(upper) == 1) {        upper &lt;- rep(upper, length(inits$THTA))    }    else if (length(lower) != length(inits$THTA)) {        stop("Upper must be a single constant for all the THETA lower bounds, or match the dimension of THETA.")    }    if (!is.null(.extraPars)) {        .ret$model$extra.pars &lt;- eval(call(control$diagXform,             .ret$model$extra.pars))        if (length(.ret$model$extra.pars) &gt; 0) {            inits$THTA &lt;- c(inits$THTA, .ret$model$extra.pars)            .lowerErr &lt;- rep(control$atol[1] * 10, length(.ret$model$extra.pars))            .upperErr &lt;- rep(Inf, length(.ret$model$extra.pars))            lower &lt;- c(lower, .lowerErr)            upper &lt;- c(upper, .upperErr)        }    }    if (is.null(data$ID))         stop("\"ID\" not found in data")    if (is.null(data$DV))         stop("\"DV\" not found in data")    if (is.null(data$EVID))         data$EVID &lt;- 0    if (is.null(data$AMT))         data$AMT &lt;- 0    for (.v in c("TIME", "AMT", "DV", .covNames)) {        data[[.v]] &lt;- as.double(data[[.v]])    }    .ret$dataSav &lt;- data    .ds &lt;- data[data$EVID != 0 &amp; data$EVID != 2, c("ID", "TIME",         "AMT", "EVID", .covNames)]    .w &lt;- which(tolower(names(data)) == "limit")    .limitName &lt;- NULL    if (length(.w) == 1L) {        .limitName &lt;- names(data)[.w]    }    .censName &lt;- NULL    .w &lt;- which(tolower(names(data)) == "cens")    if (length(.w) == 1L) {        .censName &lt;- names(data[.w])    }    data &lt;- data[data$EVID == 0 | data$EVID == 2, c("ID", "TIME",         "DV", "EVID", .covNames, .limitName, .censName)]    .w &lt;- which(!(names(.ret$dataSav) %in% c(.covNames, keep)))    names(.ret$dataSav)[.w] &lt;- tolower(names(.ret$dataSav[.w]))    if (.mixed) {        .lh &lt;- .parseOM(inits$OMGA)        .nlh &lt;- sapply(.lh, length)        .osplt &lt;- rep(1:length(.lh), .nlh)        .lini &lt;- list(inits$THTA, unlist(.lh))        .nlini &lt;- sapply(.lini, length)        .nsplt &lt;- rep(1:length(.lini), .nlini)        .om0 &lt;- .genOM(.lh)        if (length(etaNames) == dim(.om0)[1]) {            .ret$etaNames &lt;- .ret$etaNames        }        else {            .ret$etaNames &lt;- sprintf("ETA[%d]", seq(1, dim(.om0)[1]))        }        .ret$rxInv &lt;- RxODE::rxSymInvCholCreate(mat = .om0, diag.xform = control$diagXform)        .ret$xType &lt;- .ret$rxInv$xType        .om0a &lt;- .om0        .om0a &lt;- .om0a/control$diagOmegaBoundLower        .om0b &lt;- .om0        .om0b &lt;- .om0b * control$diagOmegaBoundUpper        .om0a &lt;- RxODE::rxSymInvCholCreate(mat = .om0a, diag.xform = control$diagXform)        .om0b &lt;- RxODE::rxSymInvCholCreate(mat = .om0b, diag.xform = control$diagXform)        .omdf &lt;- data.frame(a = .om0a$theta, m = .ret$rxInv$theta,             b = .om0b$theta, diag = .om0a$theta.diag)        .omdf$lower &lt;- with(.omdf, ifelse(a &gt; b, b, a))        .omdf$lower &lt;- with(.omdf, ifelse(lower == m, -Inf, lower))        .omdf$lower &lt;- with(.omdf, ifelse(!diag, -Inf, lower))        .omdf$upper &lt;- with(.omdf, ifelse(a &lt; b, b, a))        .omdf$upper &lt;- with(.omdf, ifelse(upper == m, Inf, upper))        .omdf$upper &lt;- with(.omdf, ifelse(!diag, Inf, upper))        .ret$control$nomega &lt;- length(.omdf$lower)        .ret$control$neta &lt;- sum(.omdf$diag)        .ret$control$ntheta &lt;- length(lower)        .ret$control$nfixed &lt;- sum(fixed)        lower &lt;- c(lower, .omdf$lower)        upper &lt;- c(upper, .omdf$upper)    }    else {        .ret$control$nomega &lt;- 0        .ret$control$neta &lt;- 0        .ret$xType &lt;- -1        .ret$control$ntheta &lt;- length(lower)        .ret$control$nfixed &lt;- sum(fixed)    }    .ret$lower &lt;- lower    .ret$upper &lt;- upper    .ret$thetaIni &lt;- inits$THTA    .scaleC &lt;- double(length(lower))    if (is.null(control$scaleC)) {        .scaleC &lt;- rep(NA_real_, length(lower))    }    else {        .scaleC &lt;- as.double(control$scaleC)        if (length(lower) &gt; length(.scaleC)) {            .scaleC &lt;- c(.scaleC, rep(NA_real_, length(lower) -                 length(.scaleC)))        }        else if (length(lower) &lt; length(.scaleC)) {            .scaleC &lt;- .scaleC[seq(1, length(lower))]            warning("scaleC control option has more options than estimated population parameters, please check.")        }    }    .ret$scaleC &lt;- .scaleC    if (exists("uif", envir = .ret)) {        .ini &lt;- as.data.frame(.ret$uif$ini)[!is.na(.ret$uif$ini$err),             c("est", "err", "ntheta")]        for (.i in seq_along(.ini$err)) {            if (is.na(.ret$scaleC[.ini$ntheta[.i]])) {                if (any(.ini$err[.i] == c("boxCox", "yeoJohnson",                   "pow2", "tbs", "tbsYj"))) {                  .ret$scaleC[.ini$ntheta[.i]] &lt;- 1                }                else if (any(.ini$err[.i] == c("prop", "add",                   "norm", "dnorm", "logn", "dlogn", "lnorm",                   "dlnorm"))) {                  .ret$scaleC[.ini$ntheta[.i]] &lt;- 0.5 * abs(.ini$est[.i])                }            }        }        for (.i in .ini$model$extraProps$powTheta) {            if (is.na(.ret$scaleC[.i]))                 .ret$scaleC[.i] &lt;- 1        }        .ini &lt;- as.data.frame(.ret$uif$ini)        for (.i in .ini$model$extraProps$factorial) {            if (is.na(.ret$scaleC[.i]))                 .ret$scaleC[.i] &lt;- abs(1/digamma(.ini$est[.i] +                   1))        }        for (.i in .ini$model$extraProps$gamma) {            if (is.na(.ret$scaleC[.i]))                 .ret$scaleC[.i] &lt;- abs(1/digamma(.ini$est[.i]))        }        for (.i in .ini$model$extraProps$log) {            if (is.na(.ret$scaleC[.i]))                 .ret$scaleC[.i] &lt;- log(abs(.ini$est[.i])) * abs(.ini$est[.i])        }        for (.i in .ret$logitThetas) {            .b &lt;- .ret$logitThetasLow[.i]            .c &lt;- .ret$logitThetasHi[.i]            .a &lt;- .ini$est[.i]            if (is.na(.ret$scaleC[.i])) {                .ret$scaleC[.i] &lt;- 1 * (-.b + .c) * exp(-.a)/((1 +                   exp(-.a))^2 * (.b + 1 * (-.b + .c)/(1 + exp(-.a))))            }        }    }    names(.ret$thetaIni) &lt;- sprintf("THETA[%d]", seq_along(.ret$thetaIni))    if (is.null(etaMat) &amp; !is.null(control$etaMat)) {        .ret$etaMat &lt;- control$etaMat    }    else {        .ret$etaMat &lt;- etaMat    }    .ret$setupTime &lt;- (proc.time() - .pt)["elapsed"]    if (exists("uif", envir = .ret)) {        .tmp &lt;- .ret$uif$logThetasList        .ret$logThetas &lt;- .tmp[[1]]        .ret$logThetasF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$logitThetasList        .ret$logitThetas &lt;- .tmp[[1]]        .ret$logitThetasF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$logitThetasListLow        .ret$logitThetasLow &lt;- .tmp[[1]]        .ret$logitThetasLowF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$logitThetasListHi        .ret$logitThetasHi &lt;- .tmp[[1]]        .ret$logitThetasHiF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$probitThetasList        .ret$probitThetas &lt;- .tmp[[1]]        .ret$probitThetasF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$probitThetasListLow        .ret$probitThetasLow &lt;- .tmp[[1]]        .ret$probitThetasLowF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$probitThetasListHi        .ret$probitThetasHi &lt;- .tmp[[1]]        .ret$probitThetasHiF &lt;- .tmp[[2]]    }    else {        .ret$logThetasF &lt;- integer(0)        .ret$logitThetasF &lt;- integer(0)        .ret$logitThetasHiF &lt;- numeric(0)        .ret$logitThetasLowF &lt;- numeric(0)        .ret$logitThetas &lt;- integer(0)        .ret$logitThetasHi &lt;- numeric(0)        .ret$logitThetasLow &lt;- numeric(0)        .ret$probitThetasF &lt;- integer(0)        .ret$probitThetasHiF &lt;- numeric(0)        .ret$probitThetasLowF &lt;- numeric(0)        .ret$probitThetas &lt;- integer(0)        .ret$probitThetasHi &lt;- numeric(0)        .ret$probitThetasLow &lt;- numeric(0)    }    if (exists("noLik", envir = .ret)) {        if (!.ret$noLik) {            .ret$.params &lt;- c(sprintf("THETA[%d]", seq_along(.ret$thetaIni)),                 sprintf("ETA[%d]", seq(1, dim(.om0)[1])))            .ret$.thetan &lt;- length(.ret$thetaIni)            .ret$nobs &lt;- sum(data$EVID == 0)        }    }    .ret$control$printTop &lt;- TRUE    .ret$control$nF &lt;- 0    .est0 &lt;- .ret$thetaIni    if (!is.null(.ret$model$pred.nolhs)) {        .ret$control$predNeq &lt;- length(.ret$model$pred.nolhs$state)    }    else {        .ret$control$predNeq &lt;- 0L    }    .fitFun &lt;- function(.ret) {        this.env &lt;- environment()        assign("err", "theta reset", this.env)        while (this.env$err == "theta reset") {            assign("err", "", this.env)            .ret0 &lt;- tryCatch({                foceiFitCpp_(.ret)            }, error = function(e) {                if (regexpr("theta reset", e$message) != -1) {                  assign("zeroOuter", FALSE, this.env)                  assign("zeroGrad", FALSE, this.env)                  if (regexpr("theta reset0", e$message) != -1) {                    assign("zeroGrad", TRUE, this.env)                  }                  else if (regexpr("theta resetZ", e$message) !=                     -1) {                    assign("zeroOuter", TRUE, this.env)                  }                  assign("err", "theta reset", this.env)                }                else {                  assign("err", e$message, this.env)                }            })            if (this.env$err == "theta reset") {                .nm &lt;- names(.ret$thetaIni)                .ret$thetaIni &lt;- setNames(.thetaReset$thetaIni +                   0, .nm)                .ret$rxInv$theta &lt;- .thetaReset$omegaTheta                .ret$control$printTop &lt;- FALSE                .ret$etaMat &lt;- .thetaReset$etaMat                .ret$control$etaMat &lt;- .thetaReset$etaMat                .ret$control$maxInnerIterations &lt;- .thetaReset$maxInnerIterations                .ret$control$nF &lt;- .thetaReset$nF                .ret$control$gillRetC &lt;- .thetaReset$gillRetC                .ret$control$gillRet &lt;- .thetaReset$gillRet                .ret$control$gillRet &lt;- .thetaReset$gillRet                .ret$control$gillDf &lt;- .thetaReset$gillDf                .ret$control$gillDf2 &lt;- .thetaReset$gillDf2                .ret$control$gillErr &lt;- .thetaReset$gillErr                .ret$control$rEps &lt;- .thetaReset$rEps                .ret$control$aEps &lt;- .thetaReset$aEps                .ret$control$rEpsC &lt;- .thetaReset$rEpsC                .ret$control$aEpsC &lt;- .thetaReset$aEpsC                .ret$control$c1 &lt;- .thetaReset$c1                .ret$control$c2 &lt;- .thetaReset$c2                if (this.env$zeroOuter) {                  message("Posthoc reset")                  .ret$control$maxOuterIterations &lt;- 0L                }                else if (this.env$zeroGrad) {                  message("Theta reset (zero gradient values); Switch to bobyqa")                  RxODE::rxReq("minqa")                  .ret$control$outerOptFun &lt;- .bobyqa                  .ret$control$outerOpt &lt;- -1L                }                else {                  message("Theta reset (ETA drift)")                }            }        }        if (this.env$err != "") {            stop(this.env$err)        }        else {            return(.ret0)        }    }    .ret0 &lt;- try(.fitFun(.ret))    .n &lt;- 1    while (inherits(.ret0, "try-error") &amp;&amp; control$maxOuterIterations !=         0 &amp;&amp; .n &lt;= control$nRetries) {        message(sprintf("Restart %s", .n))        .ret$control$nF &lt;- 0        .estNew &lt;- .est0 + 0.2 * .n * abs(.est0) * stats::runif(length(.est0)) -             0.1 * .n        .estNew &lt;- sapply(seq_along(.est0), function(.i) {            if (.ret$thetaFixed[.i]) {                return(.est0[.i])            }            else if (.estNew[.i] &lt; lower[.i]) {                return(lower + (.Machine$double.eps)^(1/7))            }            else if (.estNew[.i] &gt; upper[.i]) {                return(upper - (.Machine$double.eps)^(1/7))            }            else {                return(.estNew[.i])            }        })        .ret$thetaIni &lt;- .estNew        .ret0 &lt;- try(.fitFun(.ret))        .n &lt;- .n + 1    }    if (inherits(.ret0, "try-error"))         stop("Could not fit data.")    .ret &lt;- .ret0    if (exists("parHistData", .ret)) {        .tmp &lt;- .ret$parHistData        .tmp &lt;- .tmp[.tmp$type == "Unscaled", names(.tmp) !=             "type"]        .iter &lt;- .tmp$iter        .tmp &lt;- .tmp[, names(.tmp) != "iter"]        .ret$parHistStacked &lt;- data.frame(stack(.tmp), iter = .iter)        names(.ret$parHistStacked) &lt;- c("val", "par", "iter")        .ret$parHist &lt;- data.frame(iter = .iter, .tmp)    }    if (.mixed) {        .etas &lt;- .ret$ranef        .thetas &lt;- .ret$fixef        .pars &lt;- .Call(`_nlmixr_nlmixrParameters`, .thetas, .etas)        .ret$shrink &lt;- .Call(`_nlmixr_calcShrinkOnly`, .ret$omega,             .pars$eta.lst, length(.etas$ID))        .updateParFixed(.ret)    }    else {        .updateParFixed(.ret)    }    if (!exists("table", .ret)) {        .ret$table &lt;- tableControl()    }    if (control$calcTables) {        .ret &lt;- addTable(.ret, updateObject = "no", keep = keep,             drop = drop, table = .ret$table)    }    .ret})(data = dat, inits = .FoceiInits, PKpars = .pars, model = .mod,     pred = function() {        return(nlmixr_pred)    }, err = uif$error, lower = uif$focei.lower, upper = uif$focei.upper,     fixed = uif$focei.fixed, thetaNames = uif$focei.names, etaNames = uif$eta.names,     control = control, env = env, keep = .keep, drop = .drop): Not all the covariates are in the dataset.</span></div><div class='output co'>#&gt; <span class='message'>Timing stopped at: 8.173 0.386 8.556</span></div><div class='input'><span class='va'>f_nlmixr_dfop_sfo_saem_obs_tc</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/pkg/nlmixr/man/nlmixr.html'>nlmixr</a></span><span class='op'>(</span><span class='va'>f_mmkin_tc</span><span class='op'>[</span><span class='st'>"DFOP-SFO"</span>, <span class='op'>]</span>, est <span class='op'>=</span> <span class='st'>"saem"</span>,
  error_model <span class='op'>=</span> <span class='st'>"obs_tc"</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> parameter labels from comments are typically ignored in non-interactive mode</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> Need to run with the source intact to parse comments</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='error'>Error in configsaem(model = model, data = dat, inits = inits, mcmc = .mcmc,     ODEopt = .ODEopt, seed = .seed, distribution = .dist, DEBUG = .DEBUG,     addProp = .addProp, tol = .tol, itmax = .itmax, type = .type,     powRange = .powRange, lambdaRange = .lambdaRange): covariate(s) not found: f_parent_to_A1</span></div><div class='output co'>#&gt; <span class='message'>Timing stopped at: 0.799 0.044 0.842</span></div><div class='input'><span class='va'>f_nlmixr_dfop_sfo_focei_obs_tc</span> <span class='op'>&lt;-</span> <span class='fu'><a href='https://rdrr.io/pkg/nlmixr/man/nlmixr.html'>nlmixr</a></span><span class='op'>(</span><span class='va'>f_mmkin_tc</span><span class='op'>[</span><span class='st'>"DFOP-SFO"</span>, <span class='op'>]</span>, est <span class='op'>=</span> <span class='st'>"focei"</span>,
  error_model <span class='op'>=</span> <span class='st'>"obs_tc"</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> parameter labels from comments are typically ignored in non-interactive mode</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BBBB;'>ℹ</span> Need to run with the source intact to parse comments</span></div><div class='output co'>#&gt; <span class='message'>→ creating full model...</span></div><div class='output co'>#&gt; <span class='message'>→ pruning branches (<span style='color: #262626; background-color: #DADADA;'>`if`</span>/<span style='color: #262626; background-color: #DADADA;'>`else`</span>)...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ loading into <span style='color: #0000BB;'>symengine</span> environment...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ creating full model...</span></div><div class='output co'>#&gt; <span class='message'>→ pruning branches (<span style='color: #262626; background-color: #DADADA;'>`if`</span>/<span style='color: #262626; background-color: #DADADA;'>`else`</span>)...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ loading into <span style='color: #0000BB;'>symengine</span> environment...</span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ calculate jacobian</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate sensitivities</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate ∂(f)/∂(η)</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ calculate ∂(R²)/∂(η)</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in inner model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in inner model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in EBE model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in EBE model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ compiling inner model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ finding duplicate expressions in FD model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ optimizing duplicate expressions in FD model...</span></div><div class='output co'>#&gt; </div><div class='output co'>#&gt; <span class='message'>→ compiling EBE model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>→ compiling events FD model...</span></div><div class='output co'>#&gt; <span class='message'> </span></div><div class='output co'>#&gt; <span class='message'><span style='color: #00BB00;'>✔</span> done</span></div><div class='output co'>#&gt; <span class='message'>Model:</span></div><div class='output co'>#&gt; <span class='message'>cmt(parent);</span>
#&gt; <span class='message'>cmt(A1);</span>
#&gt; <span class='message'>rx_expr_6~ETA[1]+THETA[1];</span>
#&gt; <span class='message'>parent(0)=rx_expr_6;</span>
#&gt; <span class='message'>rx_expr_7~ETA[4]+THETA[4];</span>
#&gt; <span class='message'>rx_expr_8~ETA[6]+THETA[6];</span>
#&gt; <span class='message'>rx_expr_9~ETA[5]+THETA[5];</span>
#&gt; <span class='message'>rx_expr_12~exp(rx_expr_7);</span>
#&gt; <span class='message'>rx_expr_13~exp(rx_expr_9);</span>
#&gt; <span class='message'>rx_expr_15~t*rx_expr_12;</span>
#&gt; <span class='message'>rx_expr_16~t*rx_expr_13;</span>
#&gt; <span class='message'>rx_expr_17~exp(-(rx_expr_8));</span>
#&gt; <span class='message'>rx_expr_19~1+rx_expr_17;</span>
#&gt; <span class='message'>rx_expr_24~1/(rx_expr_19);</span>
#&gt; <span class='message'>rx_expr_26~(rx_expr_24);</span>
#&gt; <span class='message'>rx_expr_27~1-rx_expr_26;</span>
#&gt; <span class='message'>d/dt(parent)=-parent*(exp(rx_expr_7-rx_expr_15)/(rx_expr_19)+exp(rx_expr_9-rx_expr_16)*(rx_expr_27))/(exp(-t*rx_expr_12)/(rx_expr_19)+exp(-t*rx_expr_13)*(rx_expr_27));</span>
#&gt; <span class='message'>rx_expr_10~ETA[2]+THETA[2];</span>
#&gt; <span class='message'>rx_expr_14~exp(rx_expr_10);</span>
#&gt; <span class='message'>d/dt(A1)=-rx_expr_14*A1+parent*f_parent_to_A1*(exp(rx_expr_7-rx_expr_15)/(rx_expr_19)+exp(rx_expr_9-rx_expr_16)*(rx_expr_27))/(exp(-t*rx_expr_12)/(rx_expr_19)+exp(-t*rx_expr_13)*(rx_expr_27));</span>
#&gt; <span class='message'>rx_expr_0~CMT==2;</span>
#&gt; <span class='message'>rx_expr_1~CMT==1;</span>
#&gt; <span class='message'>rx_expr_2~1-(rx_expr_0);</span>
#&gt; <span class='message'>rx_yj_~2*(rx_expr_2)*(rx_expr_1)+2*(rx_expr_0);</span>
#&gt; <span class='message'>rx_expr_3~(rx_expr_0);</span>
#&gt; <span class='message'>rx_expr_5~(rx_expr_2);</span>
#&gt; <span class='message'>rx_expr_18~rx_expr_5*(rx_expr_1);</span>
#&gt; <span class='message'>rx_lambda_~rx_expr_18+rx_expr_3;</span>
#&gt; <span class='message'>rx_hi_~rx_expr_18+rx_expr_3;</span>
#&gt; <span class='message'>rx_low_~0;</span>
#&gt; <span class='message'>rx_expr_4~A1*(rx_expr_0);</span>
#&gt; <span class='message'>rx_expr_11~parent*(rx_expr_2);</span>
#&gt; <span class='message'>rx_expr_22~rx_expr_11*(rx_expr_1);</span>
#&gt; <span class='message'>rx_pred_=(rx_expr_4+rx_expr_22)*(rx_expr_0)+(rx_expr_4+rx_expr_22)*(rx_expr_2)*(rx_expr_1);</span>
#&gt; <span class='message'>rx_r_=(rx_expr_0)*(Rx_pow_di(((rx_expr_4+rx_expr_22)*(rx_expr_0)+(rx_expr_4+rx_expr_22)*(rx_expr_2)*(rx_expr_1)),2)*Rx_pow_di(THETA[10],2)+Rx_pow_di(THETA[9],2))+(Rx_pow_di(THETA[8],2)*Rx_pow_di(((rx_expr_4+rx_expr_22)*(rx_expr_1)),2)+Rx_pow_di(THETA[7],2))*(rx_expr_2)*(rx_expr_1);</span>
#&gt; <span class='message'>parent_0=THETA[1];</span>
#&gt; <span class='message'>log_k_A1=THETA[2];</span>
#&gt; <span class='message'>f_parent_qlogis=THETA[3];</span>
#&gt; <span class='message'>log_k1=THETA[4];</span>
#&gt; <span class='message'>log_k2=THETA[5];</span>
#&gt; <span class='message'>g_qlogis=THETA[6];</span>
#&gt; <span class='message'>sigma_low_parent=THETA[7];</span>
#&gt; <span class='message'>rsd_high_parent=THETA[8];</span>
#&gt; <span class='message'>sigma_low_A1=THETA[9];</span>
#&gt; <span class='message'>rsd_high_A1=THETA[10];</span>
#&gt; <span class='message'>eta.parent_0=ETA[1];</span>
#&gt; <span class='message'>eta.log_k_A1=ETA[2];</span>
#&gt; <span class='message'>eta.f_parent_qlogis=ETA[3];</span>
#&gt; <span class='message'>eta.log_k1=ETA[4];</span>
#&gt; <span class='message'>eta.log_k2=ETA[5];</span>
#&gt; <span class='message'>eta.g_qlogis=ETA[6];</span>
#&gt; <span class='message'>parent_0_model=rx_expr_6;</span>
#&gt; <span class='message'>k_A1=rx_expr_14;</span>
#&gt; <span class='message'>k1=rx_expr_12;</span>
#&gt; <span class='message'>k2=rx_expr_13;</span>
#&gt; <span class='message'>f_parent=1/(1+exp(-(ETA[3]+THETA[3])));</span>
#&gt; <span class='message'>g=1/(rx_expr_19);</span>
#&gt; <span class='message'>tad=tad();</span>
#&gt; <span class='message'>dosenum=dosenum();</span></div><div class='output co'>#&gt; <span class='message'>Needed Covariates:</span></div><div class='output co'>#&gt; <span class='message'>[1] "f_parent_to_A1" "CMT"           </span></div><div class='output co'>#&gt; <span class='error'>Error in (function (data, inits, PKpars, model = NULL, pred = NULL, err = NULL,     lower = -Inf, upper = Inf, fixed = NULL, skipCov = NULL,     control = foceiControl(), thetaNames = NULL, etaNames = NULL,     etaMat = NULL, ..., env = NULL, keep = NULL, drop = NULL) {    set.seed(control$seed)    .pt &lt;- proc.time()    RxODE::.setWarnIdSort(FALSE)    on.exit(RxODE::.setWarnIdSort(TRUE))    loadNamespace("n1qn1")    if (!RxODE::rxIs(control, "foceiControl")) {        control &lt;- do.call(foceiControl, control)    }    if (is.null(env)) {        .ret &lt;- new.env(parent = emptyenv())    }    else {        .ret &lt;- env    }    .ret$origData &lt;- data    .ret$etaNames &lt;- etaNames    .ret$thetaFixed &lt;- fixed    .ret$control &lt;- control    .ret$control$focei.mu.ref &lt;- integer(0)    if (is(model, "RxODE") || is(model, "character")) {        .ret$ODEmodel &lt;- TRUE        if (class(pred) != "function") {            stop("pred must be a function specifying the prediction variables in this model.")        }    }    else {        .ret$ODEmodel &lt;- TRUE        model &lt;- RxODE::rxGetLin(PKpars)        pred &lt;- eval(parse(text = "function(){return(Central);}"))    }    .square &lt;- function(x) x * x    .ret$diagXformInv &lt;- c(sqrt = ".square", log = "exp", identity = "identity")[control$diagXform]    if (is.null(err)) {        err &lt;- eval(parse(text = paste0("function(){err", paste(inits$ERROR[[1]],             collapse = ""), "}")))    }    .covNames &lt;- .parNames &lt;- c()    .ret$adjLik &lt;- control$adjLik    .mixed &lt;- !is.null(inits$OMGA) &amp;&amp; length(inits$OMGA) &gt; 0    if (!exists("noLik", envir = .ret)) {        .atol &lt;- rep(control$atol, length(RxODE::rxModelVars(model)$state))        .rtol &lt;- rep(control$rtol, length(RxODE::rxModelVars(model)$state))        .ssAtol &lt;- rep(control$ssAtol, length(RxODE::rxModelVars(model)$state))        .ssRtol &lt;- rep(control$ssRtol, length(RxODE::rxModelVars(model)$state))        .ret$model &lt;- RxODE::rxSymPySetupPred(model, pred, PKpars,             err, grad = (control$derivMethod == 2L), pred.minus.dv = TRUE,             sum.prod = control$sumProd, theta.derivs = FALSE,             optExpression = control$optExpression, interaction = (control$interaction ==                 1L), only.numeric = !.mixed, run.internal = TRUE,             addProp = control$addProp)        if (!is.null(.ret$model$inner)) {            .atol &lt;- c(.atol, rep(control$atolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                 length(.atol)))            .rtol &lt;- c(.rtol, rep(control$rtolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                 length(.rtol)))            .ret$control$rxControl$atol &lt;- .atol            .ret$control$rxControl$rtol &lt;- .rtol            .ssAtol &lt;- c(.ssAtol, rep(control$ssAtolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                 length(.ssAtol)))            .ssRtol &lt;- c(.ssRtol, rep(control$ssRtolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                 length(.ssRtol)))            .ret$control$rxControl$ssAtol &lt;- .ssAtol            .ret$control$rxControl$ssRtol &lt;- .ssRtol        }        .covNames &lt;- .parNames &lt;- RxODE::rxParams(.ret$model$pred.only)        .covNames &lt;- .covNames[regexpr(rex::rex(start, or("THETA",             "ETA"), "[", numbers, "]", end), .covNames) == -1]        colnames(data) &lt;- sapply(names(data), function(x) {            if (any(x == .covNames)) {                return(x)            }            else {                return(toupper(x))            }        })        .lhs &lt;- c(names(RxODE::rxInits(.ret$model$pred.only)),             RxODE::rxLhs(.ret$model$pred.only))        if (length(.lhs) &gt; 0) {            .covNames &lt;- .covNames[regexpr(rex::rex(start, or(.lhs),                 end), .covNames) == -1]        }        if (length(.covNames) &gt; 0) {            if (!all(.covNames %in% names(data))) {                message("Model:")                RxODE::rxCat(.ret$model$pred.only)                message("Needed Covariates:")                nlmixrPrint(.covNames)                stop("Not all the covariates are in the dataset.")            }            message("Needed Covariates:")            print(.covNames)        }        .extraPars &lt;- .ret$model$extra.pars    }    else {        if (.ret$noLik) {            .atol &lt;- rep(control$atol, length(RxODE::rxModelVars(model)$state))            .rtol &lt;- rep(control$rtol, length(RxODE::rxModelVars(model)$state))            .ret$model &lt;- RxODE::rxSymPySetupPred(model, pred,                 PKpars, err, grad = FALSE, pred.minus.dv = TRUE,                 sum.prod = control$sumProd, theta.derivs = FALSE,                 optExpression = control$optExpression, run.internal = TRUE,                 only.numeric = TRUE, addProp = control$addProp)            if (!is.null(.ret$model$inner)) {                .atol &lt;- c(.atol, rep(control$atolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                   length(.atol)))                .rtol &lt;- c(.rtol, rep(control$rtolSens, length(RxODE::rxModelVars(.ret$model$inner)$state) -                   length(.rtol)))                .ret$control$rxControl$atol &lt;- .atol                .ret$control$rxControl$rtol &lt;- .rtol            }            .covNames &lt;- .parNames &lt;- RxODE::rxParams(.ret$model$pred.only)            .covNames &lt;- .covNames[regexpr(rex::rex(start, or("THETA",                 "ETA"), "[", numbers, "]", end), .covNames) ==                 -1]            colnames(data) &lt;- sapply(names(data), function(x) {                if (any(x == .covNames)) {                  return(x)                }                else {                  return(toupper(x))                }            })            .lhs &lt;- c(names(RxODE::rxInits(.ret$model$pred.only)),                 RxODE::rxLhs(.ret$model$pred.only))            if (length(.lhs) &gt; 0) {                .covNames &lt;- .covNames[regexpr(rex::rex(start,                   or(.lhs), end), .covNames) == -1]            }            if (length(.covNames) &gt; 0) {                if (!all(.covNames %in% names(data))) {                  message("Model:")                  RxODE::rxCat(.ret$model$pred.only)                  message("Needed Covariates:")                  nlmixrPrint(.covNames)                  stop("Not all the covariates are in the dataset.")                }                message("Needed Covariates:")                print(.covNames)            }            .extraPars &lt;- .ret$model$extra.pars        }        else {            .extraPars &lt;- NULL        }    }    .ret$skipCov &lt;- skipCov    if (is.null(skipCov)) {        if (is.null(fixed)) {            .tmp &lt;- rep(FALSE, length(inits$THTA))        }        else {            if (length(fixed) &lt; length(inits$THTA)) {                .tmp &lt;- c(fixed, rep(FALSE, length(inits$THTA) -                   length(fixed)))            }            else {                .tmp &lt;- fixed[1:length(inits$THTA)]            }        }        if (exists("uif", envir = .ret)) {            .uifErr &lt;- .ret$uif$ini$err[!is.na(.ret$uif$ini$ntheta)]            .uifErr &lt;- sapply(.uifErr, function(x) {                if (is.na(x)) {                  return(FALSE)                }                return(!any(x == c("pow2", "tbs", "tbsYj")))            })            .tmp &lt;- (.tmp | .uifErr)        }        .ret$skipCov &lt;- c(.tmp, rep(TRUE, length(.extraPars)))        .ret$control$focei.mu.ref &lt;- .ret$uif$focei.mu.ref    }    if (is.null(.extraPars)) {        .nms &lt;- c(sprintf("THETA[%s]", seq_along(inits$THTA)))    }    else {        .nms &lt;- c(sprintf("THETA[%s]", seq_along(inits$THTA)),             sprintf("ERR[%s]", seq_along(.extraPars)))    }    if (!is.null(thetaNames) &amp;&amp; (length(inits$THTA) + length(.extraPars)) ==         length(thetaNames)) {        .nms &lt;- thetaNames    }    .ret$thetaNames &lt;- .nms    .thetaReset$thetaNames &lt;- .nms    if (length(lower) == 1) {        lower &lt;- rep(lower, length(inits$THTA))    }    else if (length(lower) != length(inits$THTA)) {        print(inits$THTA)        print(lower)        stop("Lower must be a single constant for all the THETA lower bounds, or match the dimension of THETA.")    }    if (length(upper) == 1) {        upper &lt;- rep(upper, length(inits$THTA))    }    else if (length(lower) != length(inits$THTA)) {        stop("Upper must be a single constant for all the THETA lower bounds, or match the dimension of THETA.")    }    if (!is.null(.extraPars)) {        .ret$model$extra.pars &lt;- eval(call(control$diagXform,             .ret$model$extra.pars))        if (length(.ret$model$extra.pars) &gt; 0) {            inits$THTA &lt;- c(inits$THTA, .ret$model$extra.pars)            .lowerErr &lt;- rep(control$atol[1] * 10, length(.ret$model$extra.pars))            .upperErr &lt;- rep(Inf, length(.ret$model$extra.pars))            lower &lt;- c(lower, .lowerErr)            upper &lt;- c(upper, .upperErr)        }    }    if (is.null(data$ID))         stop("\"ID\" not found in data")    if (is.null(data$DV))         stop("\"DV\" not found in data")    if (is.null(data$EVID))         data$EVID &lt;- 0    if (is.null(data$AMT))         data$AMT &lt;- 0    for (.v in c("TIME", "AMT", "DV", .covNames)) {        data[[.v]] &lt;- as.double(data[[.v]])    }    .ret$dataSav &lt;- data    .ds &lt;- data[data$EVID != 0 &amp; data$EVID != 2, c("ID", "TIME",         "AMT", "EVID", .covNames)]    .w &lt;- which(tolower(names(data)) == "limit")    .limitName &lt;- NULL    if (length(.w) == 1L) {        .limitName &lt;- names(data)[.w]    }    .censName &lt;- NULL    .w &lt;- which(tolower(names(data)) == "cens")    if (length(.w) == 1L) {        .censName &lt;- names(data[.w])    }    data &lt;- data[data$EVID == 0 | data$EVID == 2, c("ID", "TIME",         "DV", "EVID", .covNames, .limitName, .censName)]    .w &lt;- which(!(names(.ret$dataSav) %in% c(.covNames, keep)))    names(.ret$dataSav)[.w] &lt;- tolower(names(.ret$dataSav[.w]))    if (.mixed) {        .lh &lt;- .parseOM(inits$OMGA)        .nlh &lt;- sapply(.lh, length)        .osplt &lt;- rep(1:length(.lh), .nlh)        .lini &lt;- list(inits$THTA, unlist(.lh))        .nlini &lt;- sapply(.lini, length)        .nsplt &lt;- rep(1:length(.lini), .nlini)        .om0 &lt;- .genOM(.lh)        if (length(etaNames) == dim(.om0)[1]) {            .ret$etaNames &lt;- .ret$etaNames        }        else {            .ret$etaNames &lt;- sprintf("ETA[%d]", seq(1, dim(.om0)[1]))        }        .ret$rxInv &lt;- RxODE::rxSymInvCholCreate(mat = .om0, diag.xform = control$diagXform)        .ret$xType &lt;- .ret$rxInv$xType        .om0a &lt;- .om0        .om0a &lt;- .om0a/control$diagOmegaBoundLower        .om0b &lt;- .om0        .om0b &lt;- .om0b * control$diagOmegaBoundUpper        .om0a &lt;- RxODE::rxSymInvCholCreate(mat = .om0a, diag.xform = control$diagXform)        .om0b &lt;- RxODE::rxSymInvCholCreate(mat = .om0b, diag.xform = control$diagXform)        .omdf &lt;- data.frame(a = .om0a$theta, m = .ret$rxInv$theta,             b = .om0b$theta, diag = .om0a$theta.diag)        .omdf$lower &lt;- with(.omdf, ifelse(a &gt; b, b, a))        .omdf$lower &lt;- with(.omdf, ifelse(lower == m, -Inf, lower))        .omdf$lower &lt;- with(.omdf, ifelse(!diag, -Inf, lower))        .omdf$upper &lt;- with(.omdf, ifelse(a &lt; b, b, a))        .omdf$upper &lt;- with(.omdf, ifelse(upper == m, Inf, upper))        .omdf$upper &lt;- with(.omdf, ifelse(!diag, Inf, upper))        .ret$control$nomega &lt;- length(.omdf$lower)        .ret$control$neta &lt;- sum(.omdf$diag)        .ret$control$ntheta &lt;- length(lower)        .ret$control$nfixed &lt;- sum(fixed)        lower &lt;- c(lower, .omdf$lower)        upper &lt;- c(upper, .omdf$upper)    }    else {        .ret$control$nomega &lt;- 0        .ret$control$neta &lt;- 0        .ret$xType &lt;- -1        .ret$control$ntheta &lt;- length(lower)        .ret$control$nfixed &lt;- sum(fixed)    }    .ret$lower &lt;- lower    .ret$upper &lt;- upper    .ret$thetaIni &lt;- inits$THTA    .scaleC &lt;- double(length(lower))    if (is.null(control$scaleC)) {        .scaleC &lt;- rep(NA_real_, length(lower))    }    else {        .scaleC &lt;- as.double(control$scaleC)        if (length(lower) &gt; length(.scaleC)) {            .scaleC &lt;- c(.scaleC, rep(NA_real_, length(lower) -                 length(.scaleC)))        }        else if (length(lower) &lt; length(.scaleC)) {            .scaleC &lt;- .scaleC[seq(1, length(lower))]            warning("scaleC control option has more options than estimated population parameters, please check.")        }    }    .ret$scaleC &lt;- .scaleC    if (exists("uif", envir = .ret)) {        .ini &lt;- as.data.frame(.ret$uif$ini)[!is.na(.ret$uif$ini$err),             c("est", "err", "ntheta")]        for (.i in seq_along(.ini$err)) {            if (is.na(.ret$scaleC[.ini$ntheta[.i]])) {                if (any(.ini$err[.i] == c("boxCox", "yeoJohnson",                   "pow2", "tbs", "tbsYj"))) {                  .ret$scaleC[.ini$ntheta[.i]] &lt;- 1                }                else if (any(.ini$err[.i] == c("prop", "add",                   "norm", "dnorm", "logn", "dlogn", "lnorm",                   "dlnorm"))) {                  .ret$scaleC[.ini$ntheta[.i]] &lt;- 0.5 * abs(.ini$est[.i])                }            }        }        for (.i in .ini$model$extraProps$powTheta) {            if (is.na(.ret$scaleC[.i]))                 .ret$scaleC[.i] &lt;- 1        }        .ini &lt;- as.data.frame(.ret$uif$ini)        for (.i in .ini$model$extraProps$factorial) {            if (is.na(.ret$scaleC[.i]))                 .ret$scaleC[.i] &lt;- abs(1/digamma(.ini$est[.i] +                   1))        }        for (.i in .ini$model$extraProps$gamma) {            if (is.na(.ret$scaleC[.i]))                 .ret$scaleC[.i] &lt;- abs(1/digamma(.ini$est[.i]))        }        for (.i in .ini$model$extraProps$log) {            if (is.na(.ret$scaleC[.i]))                 .ret$scaleC[.i] &lt;- log(abs(.ini$est[.i])) * abs(.ini$est[.i])        }        for (.i in .ret$logitThetas) {            .b &lt;- .ret$logitThetasLow[.i]            .c &lt;- .ret$logitThetasHi[.i]            .a &lt;- .ini$est[.i]            if (is.na(.ret$scaleC[.i])) {                .ret$scaleC[.i] &lt;- 1 * (-.b + .c) * exp(-.a)/((1 +                   exp(-.a))^2 * (.b + 1 * (-.b + .c)/(1 + exp(-.a))))            }        }    }    names(.ret$thetaIni) &lt;- sprintf("THETA[%d]", seq_along(.ret$thetaIni))    if (is.null(etaMat) &amp; !is.null(control$etaMat)) {        .ret$etaMat &lt;- control$etaMat    }    else {        .ret$etaMat &lt;- etaMat    }    .ret$setupTime &lt;- (proc.time() - .pt)["elapsed"]    if (exists("uif", envir = .ret)) {        .tmp &lt;- .ret$uif$logThetasList        .ret$logThetas &lt;- .tmp[[1]]        .ret$logThetasF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$logitThetasList        .ret$logitThetas &lt;- .tmp[[1]]        .ret$logitThetasF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$logitThetasListLow        .ret$logitThetasLow &lt;- .tmp[[1]]        .ret$logitThetasLowF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$logitThetasListHi        .ret$logitThetasHi &lt;- .tmp[[1]]        .ret$logitThetasHiF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$probitThetasList        .ret$probitThetas &lt;- .tmp[[1]]        .ret$probitThetasF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$probitThetasListLow        .ret$probitThetasLow &lt;- .tmp[[1]]        .ret$probitThetasLowF &lt;- .tmp[[2]]        .tmp &lt;- .ret$uif$probitThetasListHi        .ret$probitThetasHi &lt;- .tmp[[1]]        .ret$probitThetasHiF &lt;- .tmp[[2]]    }    else {        .ret$logThetasF &lt;- integer(0)        .ret$logitThetasF &lt;- integer(0)        .ret$logitThetasHiF &lt;- numeric(0)        .ret$logitThetasLowF &lt;- numeric(0)        .ret$logitThetas &lt;- integer(0)        .ret$logitThetasHi &lt;- numeric(0)        .ret$logitThetasLow &lt;- numeric(0)        .ret$probitThetasF &lt;- integer(0)        .ret$probitThetasHiF &lt;- numeric(0)        .ret$probitThetasLowF &lt;- numeric(0)        .ret$probitThetas &lt;- integer(0)        .ret$probitThetasHi &lt;- numeric(0)        .ret$probitThetasLow &lt;- numeric(0)    }    if (exists("noLik", envir = .ret)) {        if (!.ret$noLik) {            .ret$.params &lt;- c(sprintf("THETA[%d]", seq_along(.ret$thetaIni)),                 sprintf("ETA[%d]", seq(1, dim(.om0)[1])))            .ret$.thetan &lt;- length(.ret$thetaIni)            .ret$nobs &lt;- sum(data$EVID == 0)        }    }    .ret$control$printTop &lt;- TRUE    .ret$control$nF &lt;- 0    .est0 &lt;- .ret$thetaIni    if (!is.null(.ret$model$pred.nolhs)) {        .ret$control$predNeq &lt;- length(.ret$model$pred.nolhs$state)    }    else {        .ret$control$predNeq &lt;- 0L    }    .fitFun &lt;- function(.ret) {        this.env &lt;- environment()        assign("err", "theta reset", this.env)        while (this.env$err == "theta reset") {            assign("err", "", this.env)            .ret0 &lt;- tryCatch({                foceiFitCpp_(.ret)            }, error = function(e) {                if (regexpr("theta reset", e$message) != -1) {                  assign("zeroOuter", FALSE, this.env)                  assign("zeroGrad", FALSE, this.env)                  if (regexpr("theta reset0", e$message) != -1) {                    assign("zeroGrad", TRUE, this.env)                  }                  else if (regexpr("theta resetZ", e$message) !=                     -1) {                    assign("zeroOuter", TRUE, this.env)                  }                  assign("err", "theta reset", this.env)                }                else {                  assign("err", e$message, this.env)                }            })            if (this.env$err == "theta reset") {                .nm &lt;- names(.ret$thetaIni)                .ret$thetaIni &lt;- setNames(.thetaReset$thetaIni +                   0, .nm)                .ret$rxInv$theta &lt;- .thetaReset$omegaTheta                .ret$control$printTop &lt;- FALSE                .ret$etaMat &lt;- .thetaReset$etaMat                .ret$control$etaMat &lt;- .thetaReset$etaMat                .ret$control$maxInnerIterations &lt;- .thetaReset$maxInnerIterations                .ret$control$nF &lt;- .thetaReset$nF                .ret$control$gillRetC &lt;- .thetaReset$gillRetC                .ret$control$gillRet &lt;- .thetaReset$gillRet                .ret$control$gillRet &lt;- .thetaReset$gillRet                .ret$control$gillDf &lt;- .thetaReset$gillDf                .ret$control$gillDf2 &lt;- .thetaReset$gillDf2                .ret$control$gillErr &lt;- .thetaReset$gillErr                .ret$control$rEps &lt;- .thetaReset$rEps                .ret$control$aEps &lt;- .thetaReset$aEps                .ret$control$rEpsC &lt;- .thetaReset$rEpsC                .ret$control$aEpsC &lt;- .thetaReset$aEpsC                .ret$control$c1 &lt;- .thetaReset$c1                .ret$control$c2 &lt;- .thetaReset$c2                if (this.env$zeroOuter) {                  message("Posthoc reset")                  .ret$control$maxOuterIterations &lt;- 0L                }                else if (this.env$zeroGrad) {                  message("Theta reset (zero gradient values); Switch to bobyqa")                  RxODE::rxReq("minqa")                  .ret$control$outerOptFun &lt;- .bobyqa                  .ret$control$outerOpt &lt;- -1L                }                else {                  message("Theta reset (ETA drift)")                }            }        }        if (this.env$err != "") {            stop(this.env$err)        }        else {            return(.ret0)        }    }    .ret0 &lt;- try(.fitFun(.ret))    .n &lt;- 1    while (inherits(.ret0, "try-error") &amp;&amp; control$maxOuterIterations !=         0 &amp;&amp; .n &lt;= control$nRetries) {        message(sprintf("Restart %s", .n))        .ret$control$nF &lt;- 0        .estNew &lt;- .est0 + 0.2 * .n * abs(.est0) * stats::runif(length(.est0)) -             0.1 * .n        .estNew &lt;- sapply(seq_along(.est0), function(.i) {            if (.ret$thetaFixed[.i]) {                return(.est0[.i])            }            else if (.estNew[.i] &lt; lower[.i]) {                return(lower + (.Machine$double.eps)^(1/7))            }            else if (.estNew[.i] &gt; upper[.i]) {                return(upper - (.Machine$double.eps)^(1/7))            }            else {                return(.estNew[.i])            }        })        .ret$thetaIni &lt;- .estNew        .ret0 &lt;- try(.fitFun(.ret))        .n &lt;- .n + 1    }    if (inherits(.ret0, "try-error"))         stop("Could not fit data.")    .ret &lt;- .ret0    if (exists("parHistData", .ret)) {        .tmp &lt;- .ret$parHistData        .tmp &lt;- .tmp[.tmp$type == "Unscaled", names(.tmp) !=             "type"]        .iter &lt;- .tmp$iter        .tmp &lt;- .tmp[, names(.tmp) != "iter"]        .ret$parHistStacked &lt;- data.frame(stack(.tmp), iter = .iter)        names(.ret$parHistStacked) &lt;- c("val", "par", "iter")        .ret$parHist &lt;- data.frame(iter = .iter, .tmp)    }    if (.mixed) {        .etas &lt;- .ret$ranef        .thetas &lt;- .ret$fixef        .pars &lt;- .Call(`_nlmixr_nlmixrParameters`, .thetas, .etas)        .ret$shrink &lt;- .Call(`_nlmixr_calcShrinkOnly`, .ret$omega,             .pars$eta.lst, length(.etas$ID))        .updateParFixed(.ret)    }    else {        .updateParFixed(.ret)    }    if (!exists("table", .ret)) {        .ret$table &lt;- tableControl()    }    if (control$calcTables) {        .ret &lt;- addTable(.ret, updateObject = "no", keep = keep,             drop = drop, table = .ret$table)    }    .ret})(data = dat, inits = .FoceiInits, PKpars = .pars, model = .mod,     pred = function() {        return(nlmixr_pred)    }, err = uif$error, lower = uif$focei.lower, upper = uif$focei.upper,     fixed = uif$focei.fixed, thetaNames = uif$focei.names, etaNames = uif$eta.names,     control = control, env = env, keep = .keep, drop = .drop): Not all the covariates are in the dataset.</span></div><div class='output co'>#&gt; <span class='message'>Timing stopped at: 17.5 0.646 18.15</span></div><div class='input'>
<span class='fu'><a href='https://rdrr.io/r/stats/AIC.html'>AIC</a></span><span class='op'>(</span>
  <span class='va'>f_nlmixr_sfo_sfo_focei_const</span><span class='op'>$</span><span class='va'>nm</span>,
  <span class='va'>f_nlmixr_fomc_sfo_focei_const</span><span class='op'>$</span><span class='va'>nm</span>,
  <span class='va'>f_nlmixr_dfop_sfo_focei_const</span><span class='op'>$</span><span class='va'>nm</span>,
  <span class='va'>f_nlmixr_fomc_sfo_saem_obs</span><span class='op'>$</span><span class='va'>nm</span>,
  <span class='va'>f_nlmixr_fomc_sfo_focei_obs</span><span class='op'>$</span><span class='va'>nm</span>,
  <span class='va'>f_nlmixr_dfop_sfo_saem_obs</span><span class='op'>$</span><span class='va'>nm</span>,
  <span class='va'>f_nlmixr_dfop_sfo_focei_obs</span><span class='op'>$</span><span class='va'>nm</span>,
  <span class='va'>f_nlmixr_fomc_sfo_focei_tc</span><span class='op'>$</span><span class='va'>nm</span>,
  <span class='va'>f_nlmixr_dfop_sfo_focei_tc</span><span class='op'>$</span><span class='va'>nm</span>,
  <span class='va'>f_nlmixr_fomc_sfo_saem_obs_tc</span><span class='op'>$</span><span class='va'>nm</span>,
  <span class='va'>f_nlmixr_fomc_sfo_focei_obs_tc</span><span class='op'>$</span><span class='va'>nm</span>,
  <span class='va'>f_nlmixr_dfop_sfo_saem_obs_tc</span><span class='op'>$</span><span class='va'>nm</span>,
  <span class='va'>f_nlmixr_dfop_sfo_focei_obs_tc</span><span class='op'>$</span><span class='va'>nm</span>
<span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='error'>Error in AIC(f_nlmixr_sfo_sfo_focei_const$nm, f_nlmixr_fomc_sfo_focei_const$nm,     f_nlmixr_dfop_sfo_focei_const$nm, f_nlmixr_fomc_sfo_saem_obs$nm,     f_nlmixr_fomc_sfo_focei_obs$nm, f_nlmixr_dfop_sfo_saem_obs$nm,     f_nlmixr_dfop_sfo_focei_obs$nm, f_nlmixr_fomc_sfo_focei_tc$nm,     f_nlmixr_dfop_sfo_focei_tc$nm, f_nlmixr_fomc_sfo_saem_obs_tc$nm,     f_nlmixr_fomc_sfo_focei_obs_tc$nm, f_nlmixr_dfop_sfo_saem_obs_tc$nm,     f_nlmixr_dfop_sfo_focei_obs_tc$nm): object 'f_nlmixr_sfo_sfo_focei_const' not found</span></div><div class='input'><span class='co'># Currently, FOMC-SFO with two-component error by variable fitted by focei gives the</span>
<span class='co'># lowest AIC</span>
<span class='fu'><a href='https://rdrr.io/r/graphics/plot.default.html'>plot</a></span><span class='op'>(</span><span class='va'>f_nlmixr_fomc_sfo_focei_obs_tc</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='error'>Error in plot(f_nlmixr_fomc_sfo_focei_obs_tc): object 'f_nlmixr_fomc_sfo_focei_obs_tc' not found</span></div><div class='input'><span class='fu'><a href='https://rdrr.io/r/base/summary.html'>summary</a></span><span class='op'>(</span><span class='va'>f_nlmixr_fomc_sfo_focei_obs_tc</span><span class='op'>)</span>
</div><div class='output co'>#&gt; <span class='error'>Error in summary(f_nlmixr_fomc_sfo_focei_obs_tc): object 'f_nlmixr_fomc_sfo_focei_obs_tc' not found</span></div><div class='input'><span class='co'># }</span>
</div></pre>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top">
      <h2 data-toc-skip>Contents</h2>
    </nav>
  </div>
</div>


      <footer>
      <div class="copyright">
  <p>Developed by Johannes Ranke.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.1.</p>
</div>

      </footer>
   </div>

  


  </body>
</html>


